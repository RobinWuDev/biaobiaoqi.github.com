<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tech | Biaobiaoqi的博客]]></title>
  <link href="http://biaobiaoqi.github.com/blog/categories/tech/atom.xml" rel="self"/>
  <link href="http://biaobiaoqi.github.com/"/>
  <updated>2013-08-01T01:21:59+08:00</updated>
  <id>http://biaobiaoqi.github.com/</id>
  <author>
    <name><![CDATA[Biaobiaoqi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PAT 1011-1020 题解]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/07/31/pat-1011-1020-solutions/"/>
    <updated>2013-07-31T23:41:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/07/31/pat-1011-1020-solutions</id>
    <content type="html"><![CDATA[<p>早期部分代码用Java实现。由于PAT虽然支持各种语言，但只有C/C++标程来限定时间，许多题目用Java读入数据就已经超时，后来转投C/C++。浏览全部代码：<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/tree/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel">请戳</a></p>

<p>本文谨代表个人思路，欢迎讨论;)</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/10111">PAT1011</a></h2>

<h5>题意</h5>

<p>给定一个3*3的矩阵，找到每行的最大值，格式化输出一个运算结果。</p>

<h5>分析</h5>

<p>非常简单的模拟题。</p>

<!--more-->


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/10012">PAT1012</a></h2>

<h5>题意</h5>

<p>给定学生的学号和三个科目的分数，查询输出对应学生单门科目排名和总分排名中最高的那个排名。</p>

<h5>分析</h5>

<p>C里stdlib.h中的qsort()和C++里algorithm中的sort()函数都能实现快排，应对编程题中的排序一般比自己手写的要快。
分别为三个单科和总分做排序，并将rank值记录到map结构中去，便于之后的查找。</p>

<p>需要注意并列排名的情况。比如<code>1 2 2 4</code>，由于并列第2的都两人，那之后的那个人就是第4而不是第3了。</p>

<p>另外，由于有多个需要分别排序、排名的项，抽象出公共逻辑到一个函数里比较必要，否则代码分散难于debug和维护。
这里稍微特殊点的用法是使用了<a href="http://blog.csdn.net/dyx1024/article/details/7562786">函数指针</a>做参数。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1013">PAT1013</a></h2>

<h5>题意</h5>

<p>给定一张图和指定几个点。针对给出的每个点，要求计算在图中除掉连接该点的路径的情况下，保证整个图连通需要添加几条边。</p>

<h5>分析</h5>

<p>计算保证整个图连通需要几个点，亦即求出图中有几个连通分量。两种思路：</p>

<ul>
<li>1.并查集</li>
<li>2.DFS</li>
</ul>


<p>针对每个点，执行算法的过程中，需要注意去除掉改点对应的所有通路。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1014">PAT1014</a></h2>

<h5>题意</h5>

<p>这道题是排队模拟题。银行有N个窗口，每个窗口允许排队M个人，如果N个窗口占满了排队的人，更多的人需要在黄线外等待。
每个人都会选择尽可能人少的窗口排队，如果有多个窗口等待队列一样长，则选择编号小的窗口。
前N个用户设定在8:00开始接受服务。给定了K个用户所需要接受服务的时间长度，要求在这个排队模型下，每个人的完成处理的时间点。</p>

<h5>分析</h5>

<p>相对另外几个队列模拟题，这个题是很简单的。没有达到时间的差异，只需要不断的从等待队列中取出人员即可。
当然，由于黄线内等待的每个窗口都有M人，所以必须单独的模拟每个窗口。
可以使用queue模拟每个窗口，循环遍历下次离开窗口的人，继而从等待队列中补上。
需要注意结束条件，如果17:00以后还没有开始接受服务，则不用再等待。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1015">PAT1015</a></h2>

<h5>题意</h5>

<p>Reversible Primes是指在某个进制下，一个数本身和它翻转过来形成的新数都是素数。
题中给出多组数据，以负数结尾程序。每组数据包含一个数以及一个进制数。判定该数是否是Reversible Primes.</p>

<h5>分析</h5>

<p>两个功能点实现：判定素数和特定进制下的数据倒转。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1016">PAT1016</a></h2>

<h5>题意</h5>

<p>给出一天中每个不同的小时内的电话付费标准，给出一份分为打出和挂断两种记录的通话记录，包括记录发生的时刻和用户名字，
要求整理出当月有效用户的账单，输出格式中需要输出所有的通话记录，包括开始时刻和结束时刻，每次通话的话费以及总计的话费。</p>

<h5>分析</h5>

<p>模拟题。首先对输入的通话记录按照先姓名后时间做qsort()排序，然后遍历排序后的记录，找到合适的匹配对，计算每次通话的时间，并进行统计和输出。</p>

<p>实现的难点主要有两个：</p>

<ul>
<li>1.在排序后的记录中，找到合适的配对。如果某人的通话记录为<code>1.on;2.on;3.off;</code>，则其中<code>1.on</code>将被抛弃，匹配到<code>2.on;3.off;</code>。
题中仅仅保证了所有记录中至少有一对有效记录，但并没有保证每个人都有有效通话记录，所以还需要做好过滤，
如果某人没有有效通话记录，则不输出。整体的控制流程需要谨慎。</li>
<li>2.由于不同时刻的话费不一样，计算一次有效通话的话费比较复杂。可以采用的方式是用起始时刻分阶段追赶结束时刻。追赶的过程分阶段，也就能计算好不同阶段的开销，
先将起始时间调整到跟结束时间为同一天，细节是先让分钟达到0，再让小时迭代到0，天进位，一直迭代到跟结束时间同天；再让起始时刻的小时数追平
结束时刻；最后让分钟追平。以此计算出最终话费。</li>
</ul>


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1017">PAT1017</a></h2>

<h5>题意</h5>

<p>银行有K个窗口，所有到达银行的人都应该在黄线外等待，直到有窗口空余。
每个窗口对单个客人最多服务时间为1小时。N个用户的到达时间和需要处理的时间给出。
8:00到17:00接受服务，逾期不服务，也不计入统计数据。要求格式化输出用户的平均等待时间。</p>

<h5>分析</h5>

<p>又一道排队模拟题。相比PAT1014，此题更复杂在于用户的到达时间是不确定的。
首先使用qsort()按照到达时间对所有人排序。由于每个窗口同时只有一个人在处理，所以窗口之间没有差异，可以用priority_queue建立一个队列，
模拟所有K个窗口。
优先队列将结束时间最早的人放到队列的顶端，每次循环处理一个人的结束。然后步入一个黄线外等待的人。如果那个时刻，下一个人还没有达到，则可以将该人开始执行的时间记录为他的到达时间，并加入队列中。
还有一点需要注意的：HH:MM:SS的时间格式，可以转换为累积秒数的时间，方便计算比较。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1018">PAT10108</a></h2>

<h5>题意</h5>

<p>以杭州的公用自行车站点管理为背景。每个站点是一个节点，每个节点上最多停放Cmax辆自行车，Cmax/2为节点的最佳状态。不同节点间距离不同，整个构成了一张带权无向图。要求从起始点（公用自行车管理中心）出发，去目的地维护目的地节点的车辆状态，如果车辆低于Cmax/2，则给它添加车辆到Cmax/2辆，如果多于Cmax/2，则去除掉几辆车。同时，在去往目的地的过程中，也需要调整所有沿途站点的车辆（这里题目没有交代清楚，实际测试是只能在去往目的地的途中调整，回来的途上不可调整）。求到给定目的地的最短路径，如果有多条最短路径，则按照1.从管理中心送出的车辆越少越好；2.拿回到管理中心的车越少越好的优先级找到结果。</p>

<h5>分析</h5>

<p>题目的大体框架是有权最短路径问题。步骤如下：</p>

<ul>
<li>1.使用Dijkstra找到最短路径，其中注意记录每个节点在最短路径中的【所有】前驱节点；</li>
<li>2.使用DFS的方法，得到所有的最短路径。</li>
<li>3.计算每条最短路径的带出和带回的车辆数量。</li>
</ul>


<p>其中DFS时，归纳所有答案的过程比较通用，需要掌握。</p>

<p>另外值得注意的是，类比到PAT1003，该题采用了直接对每个节点增加状态记录的方式，直接得到最优解，而不是先找到最短路径，然后计算比较。本题是无法用这种方法实现的，需要送出和带回的自行车数量无法直接在Dij算法中每个节点的计算中体现，并不是前面的节点带回和送出的车辆越少，后面的节点就一定能得到更优解。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1019">PAT1019</a></h2>

<h5>题意</h5>

<p>给定一个十进制数和一个进制，要求计算出在给定进制下的表达并判定是否为回文。</p>

<h5>分析</h5>

<p>简单的数字处理。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1020">PAT1020</a></h2>

<h5>题意</h5>

<p>根据二叉树的后序遍历和中序遍历，求层序遍历。</p>

<h5>分析</h5>

<p>具体实现方式：</p>

<ul>
<li>初始：用后序遍历序列确定根节点，在中序遍历序列中找到该根节点，则左右子树分别为中序中该节点左右的序列。</li>
<li>迭代：对各个子树分别执行三步操作，1.在后序序列中找子树的根节点；2。在中序序列中找子树的根节点，并划分开根节点的左右子树；3.根据新生成的左右子树，在后序序列中划分开这些节点，从而得到了两颗子树的后序、中序序列。</li>
</ul>


<p>有一个结论：中序遍历配合另外任何一个遍历，能重建二叉树。其他的任意两个序列的组合都不能唯一的确定重建的二叉树。具体分析参见博文<a href="../../../../2013/04/27/pat1020-pat1043-rebuild-binary-tree/">《根据前中后序和层序重建二叉树(PAT1020、PAT1043)》</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PAT 1001-1010 题解]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/07/31/pat-1001-1010-solutions/"/>
    <updated>2013-07-31T02:03:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/07/31/pat-1001-1010-solutions</id>
    <content type="html"><![CDATA[<p>早期部分代码用Java实现。由于PAT虽然支持各种语言，但只有C/C++标程来限定时间，许多题目用Java读入数据就已经超时，后来转投C/C++。浏览全部代码：<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/tree/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel">请戳</a></p>

<p>本文谨代表个人思路，欢迎讨论;)</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1001">PAT1001</a></h2>

<h5>题意</h5>

<p>格式化输出两数之和。</p>

<h5>分析</h5>

<p>理清输出逻辑即可。</p>

<!--more-->


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1002">PAT1002</a></h2>

<h5>题意</h5>

<p>给定两多项式，相加并格式化输出结果。</p>

<h5>分析</h5>

<p>两种思路</p>

<ul>
<li>1.采用链表的处理方式；</li>
<li>2.预设好int[1005]的数组，用下标表示次方，数组中元素值表示对应系数。</li>
</ul>


<p>第一种方法某种程度上看能节省空间，实现上需要注意操作链表时，循环时的越界问题；
方法二用空间换取时间，且实现上更不容易出错。同时，由于浮点数本身精确位数不够，在判定两浮点数相加是否为0时，
需要对结果值取绝对值后，与1e-6做对比。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1003">PAT1003</a></h2>

<h5>题意</h5>

<p>求两个城市之间的加权最短路径。在有多个最短路径记录的情况下，选择路径中所有节点的权重值之和最小的。</p>

<h5>分析</h5>

<p>Dijkstra算法的变型实现。两种思路：</p>

<ul>
<li>1.计算最短路时，在每个节点上用链表preList记下所有最短路径的前节点。
完成计算后，对preList做dfs获得每条最短路径的权重值之和，比较后得到结果；</li>
<li>2.计算最短路径时，在节点上，除了记录最短路径中前一个节点preNode之外，还对应的记录当前的最短路径上所有节点的权重值之和，
这就不用在Dij完成之后再做dfs了，过程中已经找到了最优解。</li>
</ul>


<p>相比之下，方法2明显更简洁。当然，虽然方法2的思路很通用，还需要确定，这一加权的判定条件是能够迭代处理的。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1004">PAT1004</a></h2>

<h5>题意</h5>

<p>计算给定的树各个层级叶子节点的个数</p>

<h5>分析</h5>

<p>先构建树，鉴于题目的空间限制不严格，可以使用邻接矩阵的方式定义树结构。然后使用dfs遍历树的节点，并记录每层的叶子节点数量。
可以看到，时间空间的trade-off不仅仅是性能上的提升，也会影响带代码实现的复杂程度。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1005">PAT1005</a></h2>

<h5>题意</h5>

<p>计算一个数（&lt;=10<sup>100）的各个位数之和，并用英语按位输出。比如15输出为one</sup> five.</p>

<h5>分析</h5>

<p>简单题，输出的实现上实际上就用到了Hash思想。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1006">PAT1006</a></h2>

<h5>题意</h5>

<p>每个人来到实验室和离开实验室的时间都有记录。找到其中最早来实验室和最晚离开实验室的时间。</p>

<h5>分析</h5>

<p>逻辑上很简单的一个题，遍历所有数据，找到其中最大和最小的值即可。稍微要处理的就是时间。
由于input中给出的是HH:MM:SS的格式，在比较时需要将其换算为int值。实际上，使用C语言读入更方便，<code>scanf("%d:%d:%d", &amp;h, &amp;m, &amp;s);</code>
然后计算出<code>time = 3600*h + 60*m + s</code>，时间比较就没有问题了。在最终的输出时再做对应的转换即可。
而在Java语言中，使用到了String的split方法划分子串和Integer.parseInt()转String为int。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1007">PAT1007</a></h2>

<h5>题意</h5>

<p>给出一组由正负整数组成的序列，求出拥有最大和的连续子序列。</p>

<h5>分析</h5>

<p>最暴力的算法是两个循环的O(n<sup>2)；进一步要使用分治的思想，可以得到O(n*logn)；更好的方法可以达到O(n)，也可以将它看做分治思想。关键在于数学归纳的证明，编程实现非常简单：假定[0,</sup> n-1]的最大连续子串已经求出了，要求[0,n]的最大连续子串。</p>

<ul>
<li>1.如果[0, n-1]中最大子串不包含最右的数字，则判定<code>原最大子串的和</code>与<code>包含最右点的最大子串 + a[n]的和</code>的大小。取大的那个作为[0, n]的最大子串，并保持一个<code>包含最右点的最大子串</code>。</li>
<li>2.如果[0, n-1]中最大子串包含最右的数字，则[0, n]的最大子串为原最大子串+a[n]。</li>
</ul>


<p>实际上，算法的核心是维持了两个量的记录，即当前的<code>最大子串</code>，以及当前<code>包含最右点的最大子串</code>。</p>

<p>更多讨论参见博文<a href="../../../../2013/04/05/maximum-subsequence-sum/">《分治、时间空间的权衡:最大合的连续字串问题 (PAT 1007)
》</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1008">PAT1008</a></h2>

<h5>题意</h5>

<p>给出电梯的行进路径，上下的速度和每层停留时间，计算总时间。</p>

<h5>分析</h5>

<p>简单的模拟题。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1009">PAT1009</a></h2>

<h5>题意</h5>

<p>求两个多项式的乘积。</p>

<h5>分析</h5>

<p>参见PAT1002，使用数组存储虽然空间占用稍大，但比链表实现要便捷很多。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1010">PAT1010</a></h2>

<h5>题意</h5>

<p>给定两个数，其中单个位置上的数值范围可以为[0-z]。指定其中一个数的进制，试确定是否存在可能的进制让两数的实际值相等。</p>

<h5>分析</h5>

<p>此题没有交代清楚input中radix的取值范围以及对一位数有多重可能radix的情况如何输出，坑比较大。下面是需要注意的点。</p>

<ul>
<li>1.input中两个数字可以是10位数，虽然没有告诉radix的范围，但在<code>9*10^10 10 1 200</code>这个示例中，可以看到结果的radix也可以是很大的。从这个角度看，代码中将radix和两个数值都设定为longlong是合适的选择。</li>
<li>2.在计算另一个数的radix时，简单的遍历[2, 10<sup>18]会超时。单调的区间很自然想到使用二分查找。</sup></li>
<li>3.二分查找的上下界确定能减少耗时：下界选数字的所有位上的最大值+1；上界容易想当然的认为就是题中给定了radix的数的值。实际上，示例<code>11 b 1 10</code>就是一个反例，原因在于这个假设忽略了一位数的可能性，解决方案是在取给定radix的数值和下界中较大的那个数。</li>
<li>4.在二分查找时，不可直接计算出某个radix下数的值，因为可能会longlong溢出。于是需要用特定的compare函数，在累加的过程中判定是否大于另一个数。算是一种剪枝。</li>
<li>5.还有一个条件：当两个数都是1时，输出2.当两个数相等且不为1时，输出题中给出的radix。（这是从其他人的结题报告中看到的，完全不理解=。=）</li>
</ul>


<p>注意好这些方面，应该能ac了。保重。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[阿里离线数据处理平台2013暑期学校]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/07/19/odps-in-alibaba/"/>
    <updated>2013-07-19T21:31:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/07/19/odps-in-alibaba</id>
    <content type="html"><![CDATA[<p>本周有幸参加了为期两天的<a href="http://102.alibaba.com/competition/dataSummer.htm">阿里离线数据处理平台2013暑期学校</a>的学习。</p>

<p>阿里的前辈们分不同的专题给大家介绍了飞天平台上的离线数据处理服务ODPS（Open Data Processing Service）。
内容上主要分为两部分，一部分是平台架构，一部分是数据分析。来听课的同学也就分为了两部分，而像我一样关注系统层面的人是少数。</p>

<p>这也正常，用赵本山在『一代宗师』里的话来说，一个是面子，一个是里子。数据分析能直接产生表现层的数据，而系统平台则只是提供支持。
成功了，大家看得到的是分析出的数据，而一旦失败了，那么系统平台的责任就大了。
再者越贴近硬件层次的工作也注定越辛苦，深夜被吵醒也不是没有的事儿。好了，吐槽到此结束，下面是总结笔记整理出几页slides：</p>

<script async class="speakerdeck-embed" data-id="e0022eb0d24d013089506e9621fcaf9a" data-ratio="1.33333333333333" src="http://biaobiaoqi.github.com//speakerdeck.com/assets/embed.js"></script>




<!--more-->


<p>ppt下载链接：<a href="https://speakerdeck.com/biaobiaoqi/odps-learning-summary">请戳我</a></p>

<p>三巨头BAT都自主研发过大数据平台，另外两家在投入大量资金后面对困难最终关闭了项目，而阿里坚持了下来。通过了解ODPS的系统架构，可以看但工业界的系统和学术圈中提出的概念的差异。这也让我更清晰了之后自己的学习路线。</p>

<p>非常感谢阿里暑期学校给予的这次机会来接触飞天系统，非常感谢各位讲师的介绍，特别是杨少华大哥对我的疑惑的耐心解答。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[出栈序列的可能性判定（PAT1051）]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/07/16/verify-pop-sequence-for-stack/"/>
    <updated>2013-07-16T01:32:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/07/16/verify-pop-sequence-for-stack</id>
    <content type="html"><![CDATA[<h2>问题说明</h2>

<p><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1051">PAT1051</a>：给定stack的容量，给定数据的入栈顺序：从1开始的正整数序列，在允许随机的出栈操作的情况下，要求判断某出栈序列是否可能。</p>

<p>比如，告知stack容量为5，入栈序列的最大值为7。有两个序列需要判断合理性：</p>

<ul>
<li><code>1 2 3 4 5 6 7</code>： 这个序列是可能的，只需每次入栈时都做出栈操作。</li>
<li><code>3 2 1 7 5 6 4</code>： 这个序列是不可能的，其中前半部分<code>3 2 1</code>是合法的，先将<code>1 2 3</code>顺序入栈，然后三次执行出栈操作。而之后的<code>7 5 6</code>则是不可能的。</li>
</ul>


<p>要完成判定过程，常规思路是直接使用的stack数据结构模拟出栈序列做操作，然后判定是否会触犯条件。但考虑到PAT1051中时间限制只有10ms，虽然常规方法是线性的，似乎也无法保障（事实证明是错误的，用常规方法也能在PAT上AC），我想到从序列本身的特性入手，找规律，于是有了一种效率更高的判定逻辑。</p>

<h2>常规思路</h2>

<p>直接使用出栈序列指导stack模拟操作。判定条件有两条：</p>

<ul>
<li>1.栈中数据量不超过栈的容量。</li>
<li>2.出栈只能从栈顶取，不应该出现从固定的堆栈中取出其他数据的情况。</li>
</ul>


<p>算法描述如下：</p>

<p>用游标记录当前已知压栈的最大数据cur。如果新的读入数据tmp（即出栈序列中的某数据）大于cur，则将cur到tmp之间的数据顺序压入栈中，更新cur并执行检查1；如果新的读入数据tmp小于cur，则一定是直接出栈获得的，执行检查2。</p>

<p>如果能顺利完成就是合理的，如果操作过程违背了一些规则，则判定为不合理。C++实现代码如下：</p>

<p>``` cpp</p>

<h1>include&lt;stdio.h></h1>

<h1>include<stack></h1>

<p>using namespace::std;
int m, n, k, tmp, cur;
bool flag;
stack<int> s;
int main()
{</p>

<pre><code>scanf("%d %d %d", &amp;m, &amp;n, &amp;k);
while(k --) {
    flag = true;
    cur = 1;
    s.push(1);
    for (int i = 0; i != n; ++ i) {
        scanf("%d", &amp;tmp);
        if (tmp &gt; cur) {
            for (int j = cur + 1; j &lt;= tmp; ++ j)
                s.push(j);
            if (s.size() &gt; m) flag = false;
            cur = tmp;
        }else {
            if (s.top() != tmp)
                flag = false;
        }
        s.pop();
    }

    if (flag) printf("YES\n");
    else printf("NO\n");
}
</code></pre>

<p>}</p>

<p>```</p>

<h2>更高效的判定逻辑</h2>

<p>实际上，在PAT1051的环境下，由于入栈序列数据由小到大排列非常特殊，要通过出栈序列判定可能性是存在简便思路的。</p>

<p>对比分析题中Sample给出的序列，结合上面提到的两条冲突条件入手分析：</p>

<ul>
<li><p>1.栈中数据量不超过栈的容量：</p>

<p>  只有在入栈时，才会需要考虑栈中数据是否超量。出栈序列中的每个数，都以为着在出栈操作之前，它刚入栈，那么当它入栈的时候能否判定是否超过栈容量呢？可以的，（当前的出栈数值 - 已经执行过的出栈操作数量）就是当前栈中元素的数量。</p></li>
</ul>


<!--more-->


<ul>
<li><p>2.出栈只能从栈顶取，不应该出现从固定的堆栈中取出其他数据的情况。</p>

<p>  根据观察分析发现，当某数据m出栈之后，比m小的数据如果在m之后出栈的，它们所组成的序列本身需要保持从大到小的顺序排列。距离如<code>3 2 1 7 5 6 4</code>这个序列，在<code>7</code>之后有<code>5 6 4</code>这个子序列，它们都大于<code>7</code>，但却没有保持一个递减的顺序，不合法。</p></li>
</ul>


<p>C++实现代码如下：</p>

<p>``` cpp</p>

<h1>include&lt;stdio.h></h1>

<p>int m, n, k;
int max, min, tmp;
bool flag;
int main()
{</p>

<pre><code>scanf("%d %d %d", &amp;m, &amp;n, &amp;k);
while(k --) {
    flag = true;
    max = 0;
    min = 1001;

    for (int i = 0; i != n; ++ i) {
        scanf("%d", &amp;tmp);
        if (tmp &gt; max) {
            if (tmp - i &gt; m) flag = false;
            else max = min= tmp;
        } else {
            if ( tmp &gt; min) flag = false;
            else min = tmp;
        }
    }

    if (flag) printf("YES\n");
    else printf("NO\n");
}
</code></pre>

<p>}
```</p>

<h2>总结</h2>

<p>在我的理解之中，经典的算法、数据结构是在面对编程问题的解决过程中所抽象出的通用模型。而生活是多变的，并不像考试卷一样简单的套用数学题所能解决，很多情况下，编程问题也是如此。那么除了这些经典的方法外，认真分析条件，并进行针对性的优化甚至重新设计就非常重要了。这里仅仅是一个小实践。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给博客签上CC协议]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/07/10/cc-license/"/>
    <updated>2013-07-10T22:37:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/07/10/cc-license</id>
    <content type="html"><![CDATA[<p>大家都知道开源软件。通过开放源代码的方式，允许用户学习、修改、增进提高这些软件质量。软件界的开源协议很多，比如常见的Apache，BSD，GPL等等。这是一种充分利用网络的便利性，鼓励分享和创新的协议潮流。从这个层面上来说，Creative Commons也是如此。</p>

<p>这是一个非营利性组织，也是一种创作的授权方式。简称CC协议，中国大陆正式名称为知识共享。次组织的主要宗旨是增加创意作品的流通可及性，作为其他人据以创作及共享的基础，并寻找适当的法律以确保上述理念。</p>

<h2>CC协议的起源</h2>

<p>Creative Commons最先是2002年的12月16号在美国首次发布的。这个协议最初是根据美国版权法设计出来的。技术的发展，网络的发展，出现了开放共享的需求，而传统的作品保护的模式，对作品的使用和内容的开放带来一些限制。怎么样满足这种需求，同时又尊重权利人的著作权？传统的保护模式不能实现这样的作用，它可能关注于保护的时候可能忽略了对公众的，尤其网络环境下对知识文化这样分享的需求。CC协议的设计实际上是基于这样一种大的背景，在这样一个大的网络环境下应运而生，它是来倡导一种合法的分享。</p>

<h2>CC协议内容</h2>

<p>CC协议可以分为四个部分。每个部分对使用者有不同程度的限定。</p>

<ul>
<li><p>1.署名（BY）：作品上必须附有作品的归属。如此之后，作品可以被修改，分发，复制和其它用途。</p></li>
<li><p>2.非商业性使用（NC）：作品可以被修改、分发等等，但不能用于商业目的。</p></li>
<li><p>3.禁止演绎（ND）：这意味着你可以复制和分发它们，但你不能以任何方式修改它们，或基于它们进行二次创作。</p></li>
<li><p>4.相同方式共享（SA）：作品可以被修改、分发或其它操作，但所有的衍生品都要置于CC许可协议下。</p></li>
</ul>


<p>实际使用时，需要对这四种条件分别作出约束。不同的条件共有16种组合方式，其中有的组合方式互斥，简化后剩下了6种常用协议：</p>

<h5>署名（BY）</h5>

<p>此协议最为宽松，只需署名，其他无约束。</p>

<h5>署名（BY）-禁止演绎（ND）</h5>

<p>署名的同时，不得对作品进行改动。但可以用于商业或非商业用途。</p>

<h5>署名（BY）-非商业性使用（NC）</h5>

<p>署名的同时，可以修改作品，但不能用于商业用途。</p>

<h5>署名（BY）-非商业性使用（NC）-禁止演绎（ND）</h5>

<p>署名，且不得用于商业用途和修改。</p>

<h5>署名（BY）-非商业性使用（NC）-相同方式共享（SA）</h5>

<p>署名，不能商用，但可以演绎，且演绎后的内容必须是同样的共享方式。</p>

<h5>署名（BY）-相同方式共享（SA）</h5>

<p>署名，可以商用，可以演绎，但演绎后的作品必须是同样的共享方式。</p>

<!--more-->


<h2>国内的现状</h2>

<p>昨天，为了防止其他网站的不经允许无署名的转载行为，我刚给所有的文章末尾添加了原文链接信息。</p>

<p>实际上，在中国，这种侵犯著作权的行为非常泛滥。有的网站，甚至就致力于爬其他社区产生的优质数据，并直接复制到自己的网页上，以图在网络世界中获得更高的收益。在大数据的时代，越来越多的数据会在网络上产生，会很容易的在网络间流动。这种侵犯著作权的行为将破坏整个互联网信息流动的环境，阻碍社会进步。原有的著作权管理法定条纹相对守旧，面对互联网环境，本身也是水土不服的。CC协议的重要性不言而喻。</p>

<h2>博客的实践</h2>

<p>我想在我的博客中采纳BY-NC-ND协议。其对应的许可协议网络版链接如下：<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh</a></p>

<p>只需要在在<a href="/blog/2013/07/10/decorate-octopress/">昨天的修改</a>基础上，替换html内容，即可得到一个签署了BY-NC-ND协议的展示结果。具体需修改<code>octopress/plugins/post_footer_filter.rb</code>文件：</p>

<p>1.在文件头加上utf-8编码标记，以支持中文。</p>

<p>2.搜索定位到<code>post.content + %Q</code>一行，将内容修改为：
```ruby
post.content + %Q[<p class='post-footer'>&nbsp;#{pre or "原文地址："}<a href='#{post.full_url}'>#{post.full_url}</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>]</p>

<p>```</p>

<h3>参考</h3>

<ul>
<li><a href="http://zh.wikipedia.org/zh-cn/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6">开源软件wiki</a></li>
<li><a href="http://www.awflasher.com/blog/archives/939">五种开源协议的比较(BSD,Apache,GPL,LGPL,MIT) – 整理</a></li>
<li><a href="http://www.baike.com/wiki/CC%E5%8D%8F%E8%AE%AE">CC协议互动百科</a></li>
<li><a href="http://creativecommons.net.cn/2009/11/30/prof-wang-interview-at-hudong/">王春燕教授做客互动百科谈CC</a></li>
<li><a href="http://www.aqee.net/a-short-guide-to-open-source-and-similar-licenses/">开源软件许可协议简介</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
