<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tech | Biaobiaoqi的博客]]></title>
  <link href="http://biaobiaoqi.github.com/blog/categories/tech/atom.xml" rel="self"/>
  <link href="http://biaobiaoqi.github.com/"/>
  <updated>2013-04-23T23:00:53+08:00</updated>
  <id>http://biaobiaoqi.github.com/</id>
  <author>
    <name><![CDATA[Biaobiaoqi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[winsock出错引起的断网]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/04/23/winsock-kills-internet/"/>
    <updated>2013-04-23T22:24:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/04/23/winsock-kills-internet</id>
    <content type="html"><![CDATA[<h3>背景</h3>

<p>实验室有二十来台PC机，30+的服务器集群，网络拓扑比较复杂。简单地说，有网关连着校网，校网无法直接访问学校外的网络，只能通过拨vpn来实现外网访问。而校网最近也不稳定，时常断网。</p>

<p>今天，实验室的一台电脑今天突然出无法上网了，而其他人则在正常上网。症状很奇怪：</p>

<ul>
<li>浏览器只能上google，其他任何网站都上不去。</li>
<li>QQ、ftp等各种需要连网的软件也都无法正常连网。</li>
<li>一切的发生，只是在PC使用者认为正常的操作中发生：上网，连网下围棋，聊QQ，然后…</li>
</ul>


<!--more-->


<p>没有经验的我做出了如下一系列的<em>排查</em>：</p>

<h3>1st：</h3>

<p>为了排除网络环境的因素，我尝试对比了连vpn和不连vpn的情况.</p>

<p>症状没有丝毫改变。</p>

<h3>2nd：</h3>

<p>我尝试着ping了许多网站，检查是否是dns污染。</p>

<p>结果包括学校内部网络和外部网络，都能ping通。</p>

<p>这意味着网络层是没有问题的。那只能是传输层或者更上层的问题了。但奇怪的是，google是能连接上的，大概不会是驱动的问题吧？ =.=，对windows环境的不熟悉，让我无所适从。</p>

<h3>3rd:</h3>

<p>看到了运行着的360安全卫士 =_=!，对它没好感，删单个进程还杀不死，会有其他进程重新将他开启！果断删除。同时，重启，碰碰运气。windows的问题印象里总是各种奇葩。</p>

<p>以失败告终。</p>

<h3>Final:</h3>

<p>最终还是zfz童鞋从网上搜得了解决方法：
打开cmd，输入如下指令，然后重启即可。
```</p>

<blockquote><p>netsh winsock reset
```</p></blockquote>

<p>原来是windows的socket接口出了问题，通过重置来解决。</p>

<p>每每想到windows的不可控性，不禁唏嘘，这次又长见识了。</p>

<h6>参考资料：</h6>

<ul>
<li><a href="http://www.zoublog.com/technology/can-ping-dns-resolution-can-not-open-page-solution.html">《能Ping通，能DNS解析，不能打开网页(登陆QQ等)的解决办法》</a></li>
<li><a href="http://en.wikipedia.org/wiki/Winsock">winsock</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SSH原理和使用]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/04/19/use-ssh/"/>
    <updated>2013-04-19T21:44:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/04/19/use-ssh</id>
    <content type="html"><![CDATA[<p>在linux上工作，ssh是必须要了解的技术方法。它可以建立起多台主机之间的安全的加密传输，以进行远程的访问、操控、传输数据。</p>

<h2>ssh是什么</h2>

<p>SSH為Secure Shell的縮寫。為建立在应用层和传输层基础上的安全协议。</p>

<p>传统的网络服务程序，如FTP、POP和Telnet其本质上都是不安全的；因为它们在网络上用明文传送数据、用户帐号和用户口令，很容易受到中间人（man-in-the-middle）攻击方式的攻击。就是存在另一个人或者一台机器冒充真正的服务器接收用户传给服务器的数据，然后再冒充用户把数据传给真正的服务器。
而SSH是目前较可靠，專为远程登录会话和其他网络服务提供安全性的协议。利用SSH协议可以有效防止远程管理过程中的信息泄露问题。透過SSH可以對所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗。
SSH之另一項優點為其传输的数据是经过压缩的，所以可以加快传输的速度。SSH有很多功能，它既可以代替Telnet，又可以为FTP、POP、甚至为PPP提供一个安全的「通道」。
了解这么多就好了，其实ssh连接也就是可以理解成经过加密的远程访问啦。</p>

<!--more-->


<p>---（来自中文维基）</p>

<h2>ssh连接的验证、加密方式</h2>

<p>ssh连接是CS模型（客户端-服务器），客户端发出连接申请，服务器对客户端进行验证，再考虑是否接受连接申请。</p>

<p>ssh的安全加密方式的理论基础是非对称加密体系。而非对称加密中，常见的一种就是RSA加密算法。在使用ssh，务必先弄清楚非对称加密和rsa的算法流程。详情参见<a href="http://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95">RSA加密算法</a>。</p>

<p>ssh有两种级别的安全验证：账户口令验证、rsa加密验证。详细参数，可以在sshd_config配置文件中设置(Ubuntu是/etc/ssh/sshd_config，mac下是/etc/sshd_config)</p>

<h3>账号口令验证</h3>

<p>直接输入所要登陆的用户的口令是默认的方式。不需要修改配置文件。</p>

<p>如果直接从客户端将用户密码传输到服务器，那么密码信息很容易被中间人截获，从而实现重放攻击。ssh的实现方式是：</p>

<ul>
<li>1.客户端向ssh服务器发出请求，服务器将自己的公钥返回给客户端；</li>
<li>2.客户端用服务器的公钥加密自己的登录密码，再将信息发送给服务器；</li>
<li>3.服务器接收到客户端传送的密码，用自己的私钥解码，如果结果正确，则同意登录，建立起连接。</li>
</ul>


<p>这种方式还是有漏洞的，中间人可以假扮成服务器，骗取客户端的密码。</p>

<h3>RSA加密验证</h3>

<p>rsa加密验证方式，充分利用了非对称加密体系的优势，不需要在网络传输密码，完全杜绝了中间人攻击的可能。步骤如下：</p>

<h5>准备工作</h5>

<ul>
<li>-1.客户端先使用 ssh-keygen 命令，生成私钥和公钥。按照默认配置，私钥会被保存在~/.ssh/id_rsa中，公钥则在~/.ssh/id_rsa.pub中。(一般别修改这里的文件)</li>
<li>0.客户端通过安全的方式将公钥发送给服务器。在服务器端，将客户端发的公钥写入到~/.ssh/authorized_keys文件末尾。</li>
</ul>


<h5>建立连接</h5>

<ul>
<li>1.客户端发出申请。服务器产生session密钥对，返回通过对应客户端的公钥加密后的session公钥。</li>
<li>2.客户端用自己的密钥解密信息，得到session公钥。</li>
<li>3.之后的数据交互，都通过对方方公钥加密，对方收到信息后，用其私钥解密，实现安全加密过程。</li>
</ul>


<h2>免密码的RSA加密方式实施过程</h2>

<ul>
<li>1.安装ssh</li>
</ul>


<p>mac下自带的有，ubuntu下直接sudo apt-get install ssh。</p>

<ul>
<li>2.在客户端生成私钥公钥</li>
</ul>


<p>使用ssh-keygen命令生成密钥对。遇到提示都直接回车（其中passphrase是保护rsa密钥的另一套加密方式）。</p>

<p><code>
$ ssh-keygen   
Generating public/private rsa key pair.  
Enter file in which to save the key (/Users/biaobiaoqi/.ssh/id_rsa): /Users/biaobiaoqi/.ssh/id_rsa  
Enter passphrase (empty for no passphrase):   
Enter same passphrase again:   
Your identification has been saved in /Users/biaobiaoqi/.ssh/id_rsa.  
Your public key has been saved in /Users/biaobiaoqi/.ssh/id_rsa.pub.  
The key fingerprint is:  
b7:c2:5c:3f:83:5e:5e:93:a4:42:db:51:d8:ac:07:66 biaobiaoqi@biaobiaoqi.local  
The key's randomart image is:  
+--[ RSA 2048]----+  
|                 |  
|             +   |  
|            E +  |  
|           o +   |  
|        S + o o  |  
|       o + * = . |  
|        + = B +  |  
|         o + + . |  
|          . .    |  
+-----------------+  
</code></p>

<p>结果是在~/.ssh/下生成了 id_rsa（私钥）和id_rsa.pub（公钥）</p>

<ul>
<li>3.将客户端的公钥id_rsa.pub传递给服务器</li>
</ul>


<p>传送id_rsa.pub到服务器上，并将其内容写入到~/.ssh/authorized_keys文件尾。</p>

<p>可以物理的用U盘转运（似乎更安全），也可以使用scp指令（这个时候就需要运用到口令验证的ssh方式)</p>

<p><code>
$scp ~/.ssh/id_rsa.pub user@host:~/.ssh/tmp_id_rsa.pub
$ssh user@host "cat ~./ssh/tmp_id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys"
</code></p>

<p>在执行scp传输的过程中，如果是第一次ssh连接到服务器，客户端会提示是否信任这个主机，比如：
<code>
$scp ~/.ssh/id_rsa.pub user@host:~/.ssh/tmp_id_rsa.pub
The authenticity of host XXX can't be established.
ECDSA key fingerprint is xxxxxxxxxxxxxxxxxxxxxx.
Are you sure you want to continue connecting (yes/no)?
</code>
原因是，客户端不确定所连接的host是否是真正的host。一般情况，直接输入yes，继续就好了。这里有较详细的解释：<a href="http://stackoverflow.com/questions/3663895/ssh-the-authenticity-of-host-hostname-cant-be-established">点击连接</a></p>

<p>然后就可以免密码、更安全的登录啦
<code>
 ssh xxxx@hostAddress
</code></p>

<p>在ssh登录服务器时，如果出现如下问题：<em>Agent admitted failure to sign using the key</em>则需要手工将客户端私钥加入到ssh管理体系中。使用 ssh-add 指令。（具体机理还不太清楚）
<code>
$ssh-add   ~/.ssh/id_rsa
</code></p>

<h2>and one more thing;)</h2>

<h4>ssh+firefox+autoproy</h4>

<p>看看wall外面的世界，是多么美好的事情。ssh能帮我们做到，只要有一台在wall外的主机做代理。
具体方式参见博文：<a href="http://reverland.bitbucket.org/ssh_climbe.html">ssh+firefox-autoproxy</a></p>

<h4>SCP命令加密赋值数据</h4>

<p>```</p>

<h1>将本地文件复制到远程主机上</h1>

<p>$scp ~./tmp user@rehost:~/tmp</p>

<h1>见远程主机上的文件复制到本地</h1>

<p>$scp user@rehost:~/tmp ~./tmp</p>

<h1>复制的是目录，需要迭代，添加-r参数</h1>

<p>$scp -r user@rehost:~/tmpDir ~./tmpDir
```</p>

<h4>SSH的配置</h4>

<p>具体参数细节参见博文：<a href="http://www.ibm.com/developerworks/cn/aix/library/au-sshsecurity/">SSH 安全性和配置入门</a>
<a href="http://blog.licess.org/sshd_config/">sshd_config配置 详解</a></p>

<h2>推荐阅读：</h2>

<ul>
<li><a href="http://blog.lizhigang.net/archives/249">《linux ssh 使用深度解析（key登录详解）》</a></li>
<li><a href="http://wiki.tuna.tsinghua.edu.cn/SshKeyHowto">《使用 RSA 密钥对进行 SSH 登录验证》</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html">《SSH原理与运用（一）：远程登录》</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html">《SSH原理与运用（二）：远程操作与端口转发》</a></li>
<li><a href="http://reverland.bitbucket.org/ssh_climbe.html">ssh+firefox-autoproxy</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/aix/library/au-sshsecurity/">SSH 安全性和配置入门</a></li>
<li><a href="http://blog.licess.org/sshd_config/">sshd_config配置 详解</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于软件工程的一些看法]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/04/18/some-opinions-about-software-engineering/"/>
    <updated>2013-04-18T18:03:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/04/18/some-opinions-about-software-engineering</id>
    <content type="html"><![CDATA[<p>标题党了，其实实际的内容是[自己的项目经验总结和反思]。</p>

<p>今天在高级软件工程课上，做了一次关于项目经验的展示。展示的主题围绕自己参与的移动互联网团队开发经验展开。借此机会，我整理了一下思路，于是有了以下的slides。没时间码字，就先把slides直接贴上来啦:)</p>

<h2>提纲如下：</h2>

<ul>
<li>背景：对传统软件工程方法和移动互联网项目开发的对比</li>
<li>项目总结体会：</li>
<li><ul>
<li>协同目标<!--more--></li>
</ul>
</li>
<li><ul>
<li>需求的确定</li>
</ul>
</li>
<li><ul>
<li>里程碑</li>
</ul>
</li>
<li><ul>
<li>编码实现</li>
</ul>
</li>
<li><ul>
<li>发布</li>
</ul>
</li>
<li>ReCERD成长模型</li>
<li>推荐书目</li>
</ul>


<p>值得指出的是，所谓的ReCERD小团队项目能力成长模型其实是我根据自身经历所总结的一套方法模型;)， slides中有详细介绍，见笑了，欢迎拍砖。</p>

<p>slides下载地址：<a href="https://www.dropbox.com/s/0b084ccqao8igq8/course-slides.pdf">请点击</a> （使用的dropbox存储文档，可能不太稳定，海涵）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分治、时间空间的权衡:最大合的连续字串问题 (PAT 1007)]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/04/05/maximum-subsequence-sum/"/>
    <updated>2013-04-05T20:16:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/04/05/maximum-subsequence-sum</id>
    <content type="html"><![CDATA[<p><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1007">PAT1007</a>：给定一个整数串，找出连续子串中合最大的子串。</p>

<p>《编程珠玑》中用专门的一章对这个问题进行了讲解。（《编程珠玑（第2版）》P73 第8章 算法设计技术）</p>

<p>第一次在PAT上遇到这个题目时，我的思路如下：</p>

<p><del>最简单的淡然是一个三层循环咯，O(n3)，肯定会超时。节省时间的话，用动态规划吧。但简单的动态规划，显然是会超出内存限制的。有没有更巧妙的子问题划分方法呢？</del>先找到子问题：因为要求的串必须连续，分治的时候需要考虑如何延续这个连续性，那么每个子问题中就得考虑找出三个串：1.即左端连续的最大串，2.右端连续的最大串，3.整个串中的最大串.<del>由于每个问题都有三个量要维护，难道我得造出三个表来？卡主:(</del></p>

<!--more-->


<p>《编程珠玑》列出了性能上依次递进的四个算法。这里我结合个人理解和感悟做一些阐释。</p>

<ul>
<li>1.粗暴的brute forse。三层循环嵌套，据说当n 为100000的时候，就需要运行15天时间=.=</li>
</ul>


<p>```
maxsofar = 0
for i = 0 [0, n)</p>

<pre><code>for j = [i, n)
    sum = 0;
    for k = [i, j]
     sum += x[k]
     /*sum is sum of x[i..j]*/
     maxsofar = max(maxsofar, sum)
</code></pre>

<p>```</p>

<ul>
<li>2.针对第一个算法做出了优化。利用零时变量保存状态，避免了过多的重复操作，即所谓的<strong>memoization思想</strong>。时间复杂度下降到O(n*logn)。不过这份代码在PAT的OJ上仍然会超时。</li>
</ul>


<p>```
maxsofar = 0;
for i = [0, n)</p>

<pre><code>sum = 0;
for j = [i, n)
    sum += x[j]
    /* sum is sum of x[i..j]*/
    max sofar = max(maxsofar, sum)
</code></pre>

<p>```</p>

<p>相比之下，动态规划的策略也是有memoization的思想在的，不过，在这里用DP将会创建一张很大的表。。。超出内存限定。</p>

<ul>
<li><p>3.分治算法</p>

<p>  其实之前我自己在思考DP更好的子问题划分时，已经考虑到了这种分治策略。但它的实现，<strong>并非需要DP支持</strong>。</p>

<p>  divide：将串平均分为两段，如下代码第6行。分别处理两个子串，并拼接计算。</p>

<p>  conquer： 计算1.自身包含左端的最大子串；2.包含右端的最大子串；（这两个子串用于与其他子串拼接）；3.自身的最大子串。</p></li>
</ul>


<p>```
float maxsum3(l, u)</p>

<pre><code>if (l &gt; u) /* zero elements*/
    return 0
if (l == u) /* one element*/
    return max (0, x[l]);
m = (1 + u) / 2

/* find max crossing to left */
lmax = sum = 0
for (i = m; i &gt;= 1; i--)
    sum += x[i]
lmax = max(lmax, sum)

/* find max croosing to right */
rmax = sum = 0;
for i = (m, u]
    sum += x[i]
rmax = max(rmax, sum)

return max(lmax+rmax, maxsum3(l, m), maxsum3(m+1, u))   
</code></pre>

<p>```</p>

<ul>
<li><p>4.扫描算法</p>

<p>  类似于<strong>数学归纳法</strong>的思想。从串的最左端开始扫描。对于子串[0, k],其最大子串要么存在于[0, k-1]中而不包含[k]，称其为maxsofar，要么包含[k]，称其maxendingright。</p>

<p>  maxsofar和maxendingright是可能重合的。maxendingright的作用在于对[0,k+1]的子串而言，新的元素[k+1]可以与之结合，从而产生可能的新的子串。</p>

<p>  如果[k+1]本身就是负数呢？不要紧，将[k+1]加入到maxendingright的过程本身就是试错以产生可能的过程。当maxendingright降到0以下时，放弃掉这一子串就好了，因为无论如何扩张，它都是会拖后退的。别忘了，我们还维护着maxsofar，它记录最大的子串。有点绕，但是可以严格的证明算法的正确性。</p>

<p>  伪代码如下：</p></li>
</ul>


<p>```
maxsofa = 0
maxendingright = 0
for i = [0, n)</p>

<pre><code>/* invariant: maxendingright and maxsofar are accurate for x[0..i-1]*/
maxendingright = max(maxendingright + x[i], 0)
maxsofar = max(maxsofar, maxendingright)
</code></pre>

<p>```</p>

<p>根据这个思路，写出<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/pat/advancedlevel/APAT1007.java">代码</a>，一遍AC:)</p>

<h2>总结：</h2>

<ul>
<li>保存状态，避免重复计算：在算法整体框架没有大的优化的情况下，时间和空间的trade-off或许会有奇效。memoization本身就是一种用空间换时间的思想，而DP中用一种方式实现了这种思想。不过不要被DP算法所禁锢。因为，这个trade-off的实现是很多变的，就像这题的第2种算法。</li>
<li>分治：它的重要性不必多说了。同样的，DP中有分治的思想，但分治本身也是非常灵活的。</li>
<li>数学归纳证明，对算法的设计和正确性佐证很有帮助。话说它也类似于分治的思想呢。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PAT Advanced Level (1) easy problems]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/04/04/pat-advanced-level-1-easy-problems/"/>
    <updated>2013-04-04T20:58:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/04/04/pat-advanced-level-1-easy-problems</id>
    <content type="html"><![CDATA[<p><img class="left" src="http://visualcaffeine.com/ws/wp-content/uploads/2012/04/computer_guy.jpg" title="Place Kitten #2" ></p>

<p>今天做的这批题目，总的来说几乎不需要数据结构基础。几个小时刷完。</p>

<blockquote><ul>
<li>1001: 数字的格式转换。第一次做的时候，将正负数分两种情况处理了，其实负数可以拆成正数加上一个负号。太简单的道理，竟然没注意。另外，Java完全可以使用NumberFormat实现格式转换。好简单的说。</li>
</ul>
</blockquote>

<!-- more -->


<blockquote><ul>
<li><p>1002：一元多项式求导问题。有三点需要注意：1.输出中的小数精确的位数；2.浮点数操作过程中需要使用到eps做判定；<em>3.在我的实现中，主循环逻辑中，将判定游标越界的逻辑统一的提出到最外层，让代码更加简洁，利于维护。</em></p></li>
<li><p>1005: 简单的hash。注意Java可以直接实现int转string，string转int。</p></li>
<li><p>1006: 简单的找最大最小。用到了Java中String的split方法划分子串和Integer.parseInt()转String为int。</p></li>
<li><p>1008: 纯水题。</p></li>
<li><p>1009: 一元多项式相乘。基于桶排序的思想，将子项相乘的结果加到数组中去实现。第一次提交时，算错了“桶”的大小。。</p></li>
<li><p>1011: 水题，求组最大值的问题。</p></li>
<li><p>1027: 水题，hash求解。</p></li>
</ul>
</blockquote>

<h2>资料</h2>

<p><a href="http://pat.zju.edu.cn/contests/pat-a-practise">题目列表</a></p>

<p><a href="https://github.com/biaobiaoqi/biaobiaoqiCode/tree/master/src/biaobiaoqi/pat/advancedlevel">我的代码</a></p>

<h2>PS</h2>

<p>除了这几道题，其他的题目似乎都需要树、图、DP的思想。明天开干！</p>

<p>用了那么久eclipse，其实对eclipse的掌握并不好。比如他对（）和“”等的支持方式：</p>

<blockquote><p><strong>只需要输入左单边括号，即可获得一个完整的括号，并定位到括号内输入内容。完成内容输入后，回车即可跳到反括号外，继续输入。同理于调用方法时参数的输入等。</strong></p></blockquote>
]]></content>
  </entry>
  
</feed>
