<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tech | Biaobiaoqi的博客]]></title>
  <link href="http://biaobiaoqi.github.com/blog/categories/tech/atom.xml" rel="self"/>
  <link href="http://biaobiaoqi.github.com/"/>
  <updated>2013-09-01T02:03:00+08:00</updated>
  <id>http://biaobiaoqi.github.com/</id>
  <author>
    <name><![CDATA[Biaobiaoqi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[biaobiaoqi的博客日志]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/09/01/blog-log/"/>
    <updated>2013-09-01T01:40:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/09/01/blog-log</id>
    <content type="html"><![CDATA[<p>鉴于友言的客服不搭理的态度和时而无法正常显示以及管理界面的难以使用，决定将评论系统切换到disqus上。</p>

<p>最近一直在更改博客的定制。就像一个人一样，产品也是由生命的，她的脚印就是她价值的体现。于是我萌生了将她的改变全部记录下来的想法，只恨没有在四个月前刚建起博客时就意识到这一点。</p>

<p>这就是本文的初衷了。</p>

<p>-- 2013/9/1</p>

<h2>历史</h2>

<ul>
<li><p>2013/4 octopress博客在github上成功搭建</p></li>
<li><p>2013/5 拟定了“首页”、“技术”、“生活”、“关于”的顶栏tag结构，增加了友言评论功能，jiathis分享功能，侧边栏的微博秀和豆瓣秀。</p></li>
<li><p>2013/7 侧边栏增加标签云，并增加了“标签云”顶栏tag。取消侧边栏微博秀。</p></li>
<li><p>2013/8 更换博客主题为whitelake。</p></li>
</ul>


<!--more-->


<ul>
<li>2013/9/1 取消友言评论功能，采用disqus评论系统。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[octopress第三方插件：博文同步工具syncPost]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/08/31/octopress-3rd-party-plugin-syncpost/"/>
    <updated>2013-08-31T19:30:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/08/31/octopress-3rd-party-plugin-syncpost</id>
    <content type="html"><![CDATA[<p>为了增加外链等考虑，独立博客往往有将博文同步到其他博客社区的需求。自己人肉黏贴的方式笨拙、重复，对于程序猿而言，着实不可取。</p>

<p>我在github上找到了<a href="https://github.com/huangbowen521/octopress-syncPost">syncPost</a>这个针对octopress的第三方工具，能够通过一些论坛提供的<a href="http://en.wikipedia.org/wiki/MetaWeblog">metaWeblog</a>服务实现octopress最新一篇博文的同步提交。</p>

<p>这大概就是我要找的东西吧。不过，其中有些细节并不是我想要的：</p>

<ul>
<li>1.在本地配置文件存储论坛账户的密码。虽然可以设置为ignore不提交到git代码库中，但这也并不安全。</li>
<li>2.只能同步最新的一篇博客，没有整体的博文搬家功能。</li>
<li>3.先比其他的octopress插件，原来版本的代码结构难于维护，比如有自己单独的配置文件，而不是使用全局的<code>_config.yml</code>(在那个版本中大概是为了不把明文密码提交到版本库中)，比如ruby文件单独在一个<code>_custom</code>文件夹下等</li>
</ul>


<p>基于这些点，我fork了作者的代码，定制成了它<a href="https://github.com/biaobiaoqi/octopress-syncPost">现在的样子</a>。</p>

<!--more-->


<h2>功能</h2>

<p>通过rake的方式实现同步功能：</p>

<ul>
<li>1.同步所有octopress的博文到目标博客。 (<code>rake sync_all_posts</code>)</li>
<li>2.同步最新一篇博文到目标博客。(<code>rake sync_lates_post</code>)</li>
</ul>


<h2>开发</h2>

<p>这个octopress插件的结构很简单：</p>

<ul>
<li>安装<code>nokogiri</code>和 <code>metaweblog</code>两个gem。前者实现对octopress生成的html页面的解析，找到对应的博文。提供了客户端发起MetaWeblog请求的功能。</li>
<li>在全局配置文件<code>_config.yml</code>中配置了目标博客MetaWeblog的服务地址、用户的账号信息。</li>
<li>octopress/plugins/sync_*.rb三个文件则是代码实现。其中sync_post.rb中包含了post类，是主要的逻辑代码所在，sync_all_posts.rb和sync_latest_post.rb则是对前者的调用。</li>
<li>修改了octopress的Rakefile，通过rake的方式实现功能。</li>
</ul>


<h2>下一步</h2>

<p>希望能进一步完善这个插件，现在考虑到的有：</p>

<ul>
<li>增加同步所有博文功能中，对目标博客中已有博文的查重功能。即对于已经同步过去的博客，不再发送请求，或者实现编辑功能的同步功能。由于站点的MetaWeblog服务大多对请求有时限控制，同步过程中可能出现中断，此时部分博文已经同步过去，而部分没有，这种情况下，暂时没有好的解决方式。</li>
<li>测试其他有MetaWeblog服务的博客站点（现在仅测试了cnblog）。</li>
<li>cnblog的博文显示中，似乎不支持octopress的代码块样式。</li>
</ul>


<p>欢迎感兴趣的朋友参与到这个repo中来:)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PAT 1061 - 1064 题解]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/08/31/pat-1061-pat-1064/"/>
    <updated>2013-08-31T13:32:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/08/31/pat-1061-pat-1064</id>
    <content type="html"><![CDATA[<p>这四道题来自13年08月30的PAT测试。</p>

<p>代码量不大，思路也比较直接。不过第一题的处理逻辑不太清晰，需要好好把握。稍有不慎就掉进坑里了（很多人被这道20‘的题坑了一个多小时心慌意乱我会乱说-，-？）。</p>

<p>PAT advanced level 全部源码：<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/tree/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel">请戳</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1061">1061. Dating (20)</a></h2>

<h5>题意</h5>

<p>题意比较模糊，需要仔细对照Sample的数据理清思路。给定四个字符串，每个不超过60个字符，不含空格。要求从中找到符合如下规定的三个字符（或者它们的位置），并转化成一个时间的表达：</p>

<ul>
<li>1.依次比较前两个字符串中每个位置的元素，找到第一个相等的字符，且该字符属于['A', 'G']的字母，注意大小写敏感。转换成一周七天输出。</li>
<li>2.在1中的字符出现之后，继续比较前两个串，找到一个相等的字符，使它属于['0', '9'] || ['A', 'N']，同样，大小写敏感。转换成一天24小时的小时数输出。</li>
<li>3.比较后两个字符串，找到第一个相等的字母（isalpha()），将它在数组中的位置值转换分钟数输出。</li>
</ul>


<p>为了便于理解，给出Sample数据:</p>

<p>```
Sample Input:</p>

<p>3485djDkxh4hhGE
2984akDfkkkkggEdsb
s&amp;hgsfdk
d&amp;Hyscvnm</p>

<p>Sample Output:</p>

<p>THU 14:04</p>

<p>```</p>

<h5>分析</h5>

<p>理清题目的逻辑以后，实现起来是很简单的。</p>

<p>pat1061源码:<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel/APAT1061.cpp">请戳</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1062">1062. Talent and Virtue (25)</a></h2>

<h5>题意</h5>

<p>给定一堆人，每个人有三条记录：id，道德值(v)，才能值(t)。给出两个值L和H，用作对这堆人的分类。按照如下规则输出排序结果：</p>

<!--more-->


<ul>
<li>0.过滤掉v和t都小于L的人</li>
<li>1.v和t都不小于H的人是圣人，属于最高的层级，排序在其他层级之前。</li>
<li>2.v不小于H，而t小于H的人是君子，这个层级排在圣人之后。</li>
<li>3.剩下的人中，v不小于t的人是愚人，层级关系里排第三，排在所有圣人和君子之后。</li>
<li>4.最后剩下的人是小人，是最低的层级。</li>
<li>5.排名时，相同层级的人的排序关系是 1.按照v+t的总分non-increasing排序；2.按照v的分值按non-increasing排序；3.找到id按increasing排序。</li>
</ul>


<h5>分析</h5>

<p>题意梳理清楚以后，定制比较函数用qsort()能很快的实现。</p>

<p>经测试，使用<code>cout</code>，<code>cin</code>会超时，改用'printf() scanf()'轻松过。</p>

<p>pat1062源码:<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel/APAT1062.cpp">请戳</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1063">1063. Set Similarity (25)</a></h2>

<h5>题意</h5>

<p>题目给出了N(&lt;=50)个正整数集合（实际上不是真正意义上的set，有重复数值），每个集合最多存M(&lt;10<sup>4)个元素，其中数值范围是[0,</sup> 10<sup>9]。给出K次查询，每次查询条件为两个集合，要求求出两集合的相似度。</sup></p>

<p>这里集合相似度的定义是 Nc/Nt*100%，其中Nc为两集合的交集元素数量，Nt为两集合的并集的元素数量。</p>

<h5>分析</h5>

<p>思路一：</p>

<p>利用<code>sort()</code>对数组做排序，然后自行遍历去重是一个不错的方式。计算交集、并集的时候，直接用两个游标对数组遍历进行比较操作，复杂度为O(M*K)。这种游标遍历的思想，还是很common sense的处理流程。</p>

<p>思路二：</p>

<p>有不愿意透露姓名的<a href="http://weibo.com/cloudbye">@草原</a>同学提出，使用set做去重是没问题的。</p>

<p>pat1063源码:<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel/APAT1063.cpp">请戳</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1064">1064. Complete Binary Search Tree (30)</a></h2>

<h5>题意</h5>

<p>给定一串数据，要求构建完全二叉搜索树。</p>

<h5>分析</h5>

<p>常规思路是对数据排序，然后递归的构建二叉搜索树（且构建的递归过程要满足完全二叉的树形结构），实现起来稍微有些代码量。</p>

<p>后来<a href="http://weibo.com/redow7">@Redow7</a>给介绍了一种更有趣的方法：</p>

<ul>
<li>0.对数据排序，等待操作。</li>
<li>1.首先构建好完全二叉树。</li>
<li>2.利用二叉搜索树的中序遍历的有序性，在中序遍历的过程中，将排序好的数据插入其中。</li>
</ul>


<p>如此一来，难点就转移到了构建完全二叉树上。</p>

<p>联想到最大堆的数组实现：父节点坐标为n时，左儿子为2<em>n，右儿子为2</em>n+1。对的，数组实现的二叉树就是满足完全二叉树的特点的。构建完全二叉树的步骤直接缩减为定义一个一定长度的数组。</p>

<p>于是，使用数组实现的二叉树做迭代的思路就出来了，30行代码搞定。</p>

<p>pat1064源码:<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel/APAT1064.cpp">请戳</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分布式事务slides]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/08/26/distributed-transaction/"/>
    <updated>2013-08-26T23:49:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/08/26/distributed-transaction</id>
    <content type="html"><![CDATA[<p>最近看了<a href="http://book.douban.com/subject/21624776/">《分布式系统概念与设计 第5版》</a>的分布式事务章节，整理了一份ppt。还有恢复部分没有收录进来，有空再整理啦。</p>

<p>下面是传到deckspeaker上的slides展示:</p>

<script async class="speakerdeck-embed" data-id="aa521420f0a101303be246475d95d052" data-ratio="1.33333333333333" src="http://biaobiaoqi.github.com//speakerdeck.com/assets/embed.js"></script>


<p>下载链接：<a href="https://dl.dropboxusercontent.com/u/64021093/slides/distributed%20transcation.pptx">请戳</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PAT练习题概览]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/08/03/overcome-pat/"/>
    <updated>2013-08-03T22:20:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/08/03/overcome-pat</id>
    <content type="html"><![CDATA[<p>PAT(<a href="http://pat.zju.edu.cn">pat.zju.edu.cn</a>)是一个面向C/C++程序的Online Judge系统。相比ZOJ，HDOJ，POJ等ACM题库，PAT的题目非常基础，对于数据结构、算法的入门是比较有助益的。</p>

<p>本文按照自己的认识，给PAT advanced level做出了分类。由于很多题目实际上兼顾有多种解法和思路，我给每道题打上了tag，来应对分类的独占性局限，供大家参考。</p>

<h2>简单题</h2>

<p>这类题几乎不需要数据结构、算法基础，主要通过简单的逻辑流程和判断实现。</p>

<ul>
<li>1001 A+B</li>
<li>1002 多项式相加</li>
<li>1005 简单hash</li>
<li>1006 选极值</li>
<li>1008 模拟电梯</li>
<li>1009 多项式乘法</li>
<li>1011 选极值</li>
<li>1019 数字/字符处理</li>
<li>1024 数字/字符处理</li>
<li>1027 数字/字符处理，简单hash</li>
<li>1031 数字/字符处理</li>
<li>1035 简单hash<!--more --></li>
<li>1036 选极值</li>
<li>1037 简单模拟</li>
<li>1040 数字/字符处理</li>
<li>1046 数字/字符处理</li>
<li>1050 数字/字符处理</li>
<li>1058 数字/字符处理</li>
<li>1060 数字/字符处理</li>
<li>1061 数字/字符处理，坑题</li>
<li>1063 数字/字符处理，游标</li>
</ul>


<h2>模拟题</h2>

<p>这类题也相对简单，需要使用到一些简单的数据结构或者相对复杂的逻辑流程实现。</p>

<ul>
<li>1022 倒排索引</li>
<li>1023 数字/字符处理</li>
<li>1032 链表</li>
<li>1049 计算数字中的1</li>
<li>1051 模拟栈</li>
<li>1052 链表</li>
<li>1054 dominant color</li>
<li>1056 模拟分组淘汰赛</li>
</ul>


<h4>排队模拟</h4>

<p>下面三道模拟题是针对排队模型处理的：</p>

<ul>
<li>1014 排队问题</li>
<li>1017 排队问题</li>
<li>1026 排队问题</li>
</ul>


<h4>排序模拟</h4>

<p>这几道模拟题侧重在使用排序方法：</p>

<ul>
<li>1012 排序</li>
<li>1016 排序，模拟电话账单计算</li>
<li>1025 排序</li>
<li>1028 排序</li>
<li>1029 归并排序</li>
<li>1038 递归，排序</li>
<li>1062 排序</li>
</ul>


<h4>时间优化</h4>

<p>这几道题需要做好时间优化才能ac。</p>

<ul>
<li>1044 搜索，时间优化</li>
<li>1039 倒排索引，hash，时间优化</li>
<li>1047 倒排索引，hash，时间优化</li>
<li>1055 排序，时间优化</li>
</ul>


<h4>素数判定</h4>

<ul>
<li>1015 素数</li>
<li>1059 素数</li>
</ul>


<h2>图</h2>

<ul>
<li>1003 最短路径</li>
<li>1018 最短路径</li>
<li>1030 最短路径</li>
<li>1034 dfs</li>
</ul>


<h2>搜索</h2>

<ul>
<li>1010 二分搜索，优化剪枝</li>
<li>1013 并查集/dfs</li>
<li>1021 并查集，dfs，图的直径</li>
<li>1054 dfs，优化剪枝</li>
</ul>


<h2>树</h2>

<ul>
<li>1004 dfs，树遍历</li>
<li>1020 二叉树遍历</li>
<li>1043 二叉树遍历</li>
<li>1064 重建完全二叉搜索树</li>
</ul>


<h2>Hash</h2>

<ul>
<li>1041 hash</li>
<li>1042 hash</li>
<li>1048 hash</li>
</ul>


<h2>分治</h2>

<ul>
<li>1007 最大子连续序列</li>
</ul>


<h2>贪心</h2>

<ul>
<li>1033 贪心</li>
</ul>


<h2>动态规划</h2>

<ul>
<li>1045 DP，最长递增子序列</li>
</ul>


<h2>树状数组</h2>

<p>树状数组是一种神奇的数据结构，在1057题中其神奇的效果得到了很好的体现。</p>

<ul>
<li>1057 树状数组，模拟栈，二分搜索</li>
</ul>


<h2>题解</h2>

<p>截止2013-08-03，PAT advanced level的60道题全部题解和代码已经发布在本博客中，链接如下：欢迎讨论大家;)</p>

<ul>
<li><a href="http://biaobiaoqi.me/blog/2013/07/31/pat-1001-1010-solutions/">《PAT 1001-1010 题解》</a></li>
<li><a href="http://biaobiaoqi.me/blog/2013/07/31/pat-1011-1020-solutions/">《PAT 1011-1020 题解》</a></li>
<li><a href="http://biaobiaoqi.me/blog/2013/08/01/pat-1021-1030-solutions/">《PAT 1021-1030 题解》</a></li>
<li><a href="http://biaobiaoqi.me/blog/2013/08/01/pat-1031-1040-solutions/">《PAT 1031-1040 题解》</a></li>
<li><a href="http://biaobiaoqi.me/blog/2013/08/01/pat-1041-1050-solutions/">《PAT 1041-1050 题解》</a></li>
<li><a href="http://biaobiaoqi.me/blog/2013/08/01/pat-1051-1060-solutions/">《PAT 1051-1060 题解》</a></li>
<li><a href="http://biaobiaoqi.me/blog/2013/08/31/pat-1061-pat-1064/">《PAT 1061-1064 题解》</a></li>
</ul>


<p>附博客的PAT专题区链接：<a href="http://biaobiaoqi.me/tags/pat/">请戳</a></p>
]]></content>
  </entry>
  
</feed>
