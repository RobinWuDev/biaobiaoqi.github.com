<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tech | Biaobiaoqi的博客]]></title>
  <link href="http://biaobiaoqi.github.com/blog/categories/tech/atom.xml" rel="self"/>
  <link href="http://biaobiaoqi.github.com/"/>
  <updated>2013-05-06T02:05:17+08:00</updated>
  <id>http://biaobiaoqi.github.com/</id>
  <author>
    <name><![CDATA[Biaobiaoqi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[根据前中后序和层序重建二叉树(PAT1020、PAT1043)]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/04/27/pat1020-pat1043-rebuild-binary-tree/"/>
    <updated>2013-04-27T22:33:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/04/27/pat1020-pat1043-rebuild-binary-tree</id>
    <content type="html"><![CDATA[<h2>背景</h2>

<p><a href="/blog/2013/04/27/travsal-binary-tree/">《二叉树的遍历（递归、非递归）分析》</a>总结了二叉树不同遍历方式的递归和非递归实现，本文则讨论如何针对不同遍历方式的组合重建二叉树。为了简化问题的考虑，假定二叉树中不会出现重复值。列入考虑范围的有前序、中序、后序、层序遍历这四种的组合。前中后序比较常见，而层序则相对特殊一点了。</p>

<p><a href="http://pat.zju.edu.cn/contests/pat-a-practise">PAT</a>的1043和1020题是遍历相关的模板题，正好派上用场。</p>

<!--more-->


<h2>中序+前序</h2>

<h5>算法描述：</h5>

<ul>
<li><p>初始：用前序遍历序列确定根节点，在中序遍历序列中找到该根节点，则左右子树分别为中序中该节点左右的序列。</p></li>
<li><p>迭代：对各个子树分别执行三步操作，1.在前序序列中找子树的根节点；2。在中序序列中找子树的根节点，并划分开根节点的左右子树；3.根据新生成的左右子树，在前序序列中划分开这些节点，从而得到了两颗子树的前序、中序序列。</p></li>
</ul>


<h5>练习：<a href="http://pat.zju.edu.cn/contests/pat-a-practise/1043">PAT1043:Is It a Binary Search Tree</a></h5>

<h5>题意：</h5>

<p>输入一个树的前序遍历序列，判定这个树是否是二叉搜索树或者BST的镜像树，如果是，则用后序序列输出。</p>

<h5>解题思路：</h5>

<ul>
<li><p>1.BST很特殊，实质上BST的所有节点的顺序排列就是中序遍历了。</p></li>
<li><p>2.要检查树是否是BST或者镜像BST，只需按照重建树的思路，在每次重建的过程中做适当检查即可。检查思路是：检查前序遍历序列中，根节点之后的节点排序是否符合BST的二分规则（即前一段都是小于根节点的，后一段都是大于根节点的）。</p></li>
<li><p>3.最后的输出是后序遍历。过程中其实并不用构建整个树，直接在处理过程中，按后序的方式存储节点到队列中即可。</p></li>
</ul>


<p>有了这些考虑，就可以写出代码啦。详细解题代码见链接<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/pat/advancedlevel/APAT1043.java">PAT1043</a></p>

<h2>中序+后序</h2>

<h5>算法描述：</h5>

<ul>
<li><p>初始：用后序遍历序列确定根节点，在中序遍历序列中找到该根节点，则左右子树分别为中序中该节点左右的序列。</p></li>
<li><p>迭代：对各个子树分别执行三步操作，1.在后序序列中找子树的根节点；2。在中序序列中找子树的根节点，并划分开根节点的左右子树；3.根据新生成的左右子树，在后序序列中划分开这些节点，从而得到了两颗子树的后序、中序序列。</p></li>
</ul>


<h5>练习：<a href="http://pat.zju.edu.cn/contests/pat-a-practise/1020">PAT1020:Tree Traversals</a></h5>

<h5>题意：</h5>

<p>输入为一棵二叉树的后序遍历序列和中序遍历序列。求树的前序遍历序列。</p>

<h5>解题思路：</h5>

<ul>
<li><p>1.有了中序和后序，就能重建树。</p></li>
<li><p>2.最后的输出是前序遍历。过程中其实并不用构建整个树。直接在处理过程中，按前序的方式存储节点到队列中即可。</p></li>
</ul>


<p>详细解题代码见链接<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/pat/advancedlevel/APAT1020.java">PAT1020</a></p>

<h2>中序+层序</h2>

<h5>算法描述：</h5>

<ul>
<li><p>初始：用层序遍历确定顶节点，在中序遍历中，利用顶节点划分出左右子树。</p></li>
<li><p>迭代：对各个子树分别执行三步操作，1.在层序序列中，找出子树节点集合中，最靠前的节点，这个节点即为子树的顶节点；2.在中序序列中找1中得到的顶节点，并划分开顶节点的左右子树；</p></li>
<li><p>跟（中序+前序）和（中序+后序）不同之处在于没有迭代的第3步，层序是无法直接划分得到左右子树的节点集合的。但这并不妨碍正常的处理。层序是用来找到子树的顶节点的，而顶节点即是所有子树的节点中，在层序遍历中最靠前的节点。</p></li>
</ul>


<h2><del>前序+后序</del></h2>

<p>这个组合是<strong>无法</strong>重建确定的二叉树的。</p>

<p>对于满二叉树，利用子树节点的排列顺序能区分开左右子树节点集合，构建是没有问题的。但一旦有单个叶子的节点存在，则无法确定叶子是左儿子还是右儿子。因为无论是前序还是后序序列，都无法体现单个儿子情况下，儿子的位置。前序会将左右子树的点置于节点之后，后序则是将左右子树的点置于节点之前。</p>

<ul>
<li>举个简单的反例：</li>
</ul>


<blockquote><p>给出如下的前序序列和后序序列：
preorder: A, B;
postorder: B, A</p>

<p>能构建的二叉树有两种可能，1.A是根节点，B是A左儿子； 2.A是根节点， B是A的右儿子。无法得到一个唯一的结果。</p></blockquote>

<h2><del>前序+层序</del></h2>

<p>这个组合也是无法重建确定的二叉树的。同样于后序+层序的情况。</p>

<p>道理跟（前序+后序）的道理一样，无论是前序、后序，还是层序，都是无法确定单个儿子节点情况下儿子节点的顺序。</p>

<h2>总结</h2>

<ul>
<li>中序遍历配合另外任何一个遍历，能重建二叉树。其他的任意两个序列的组合都不能唯一的确定重建的二叉树。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[二叉树的遍历（递归、非递归）分析]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/04/27/travsal-binary-tree/"/>
    <updated>2013-04-27T21:03:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/04/27/travsal-binary-tree</id>
    <content type="html"><![CDATA[<h2>背景</h2>

<p>二叉树是一种很基本的数据结构。很多地方能看到它的身影，比如大名鼎鼎的霍夫曼编码（好了，别问我再比如了，见识浅薄，真不知道更多了。。。）它的结构很简洁、巧妙。</p>

<p>本文讨论二叉树的常见遍历方式的代码实现（这里贴出的是Java），包括前序(preorder)、中序(inorder)、后序(postorder)、层序(level order)，进一步，考虑递归和非递归的实现方式。递归方法的实现相对简单，但递归的执行方式由于每次都会产生一个新的方法调用栈，如果递归层级较深，会消耗较大的内存，转化为非递归则没那么简单了，往往需要实现一个栈来保存状态信息。</p>

<!--more-->


<p>在此之前，先简单定义节点的数据结构：</p>

<p>二叉树节点最多只有两个儿子，并保存一个节点的值，为了实验的方便，假定它为int。同时，我们直接使用Java的System.out.print方法来输出节点值，以显示遍历结果。</p>

<p>```
public class Node {</p>

<pre><code>    public int value;
    public Node leftNode;
    public Node rightNode;

    public Node(int i) {
        value = i;
    }
}
</code></pre>

<p>```
详细代码参见链接:<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/algorithm/tree/BinarySearchTree.java">BST及其各种便利的详细实现代码</a></p>

<h2>前序遍历</h2>

<ul>
<li>递归实现：递归实现很简单，在每次访问到某个节点时，先输出节点值，然后再依次递归的对左儿子、右儿子调用遍历的方法。代码如下</li>
</ul>


<p>```</p>

<pre><code>public void preOrderTrav(Node n) {
    if (n != null) {
        System.out.print(n.value + " ");
        preOrderTrav(n.leftNode);
        preOrderTrav(n.rightNode);
    }
}
</code></pre>

<p>```</p>

<ul>
<li>非递归调实现：</li>
</ul>


<p>1.第一种实现方式相对容易理解：</p>

<p>初始：维护一个栈，将根节点压入栈中。</p>

<p>循环：每次从栈顶读出一个节点信息，直接将节点值<strong>输出</strong>，同时将儿子节点按从左到右的顺序推到栈顶。</p>

<p>分析：跟递归调用的整体思路一样，不同的是，递归调用时是利用运行时系统所维护的程序调用栈来维护顺序，而这个非递归方法是用过自己维护的栈来保存信息。如此节省了调用栈的空间。</p>

<p>```</p>

<pre><code>public void preOrderTravNoRecur(Node n) {
    Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();
    stack.add(root);
    while (!stack.empty()) {
        Node t = stack.pop();
        System.out.print(t.value + " ");
        if (t.rightNode != null)
            stack.add(t.rightNode);
        if (t.leftNode != null)
            stack.add(t.leftNode);
    }
}
</code></pre>

<p>```</p>

<p>2.第二种实现方式更普遍（中序遍历的非递归使用了同样的思路）：</p>

<p>初始：维护一个栈S和一个节点变量N。节点变量赋值为根节点。</p>

<p>循环：将节点变量N的左儿子循环的<strong>输出</strong>，并推入栈S中，直到没有左儿子；推出栈S的顶节点，节点变量N赋值为栈S顶节点的右节点。</p>

<p>分析：不同于递归调用的思路。栈S用于实现对某节点的左边支递归值的存储，以便回溯；节点变量N则用于遍历某节点的右边枝（这些节点是从栈S顶读出的节点，依次做处理），由于右边枝是最后才会被访问到的，故在处理右边枝的时候，不需要存储右边枝的信息，依次处理即可。</p>

<p>```</p>

<pre><code>public void preOrderTravNoRecurII(Node n) {
    System.out.println("No Recursive: ");
    Stack&lt;Node&gt; s = new Stack&lt;Node&gt;();
    while (n != null | !s.empty()){
        while (n!=null ){
            System.out.print(n.value + " ");
            s.add(n);
            n = n.leftNode;
        }
        n = s.pop();
        n = n.rightNode;
    }
    System.out.println();
}
</code></pre>

<p>```</p>

<h3>中序遍历</h3>

<ul>
<li>递归实现</li>
</ul>


<p>```</p>

<pre><code>public void inorderTrav(Node n) {
    if (n != null) {
        inorderTrav(n.leftNode);
        System.out.print(n.value + " ");
        inorderTrav(n.rightNode);
    }
}
</code></pre>

<p>```</p>

<ul>
<li>非递归实现</li>
</ul>


<p>初始：维护一个栈S和一个节点变量N。节点变量赋值为根节点。</p>

<p>循环：将节点变量N的左儿子循环的<strong>输出</strong>，并推入栈S中，直到没有左儿子；节点变量N赋值为栈S顶节点的右节点。</p>

<p>分析：跟前序遍历的非递归实现方法二很类似。唯一的不同是输出的时机不同：前序遍历在入栈时输出，而中序遍历在出栈时输出。可以跟深刻的理解到，栈在这里是为了回溯而存在的。</p>

<p>```</p>

<pre><code>public void inorderTravNoRecu(Node n) {
    System.out.println("No Recursive: ");
    Stack&lt;Node&gt; s = new Stack&lt;Node&gt;();
    while (n != null | !s.empty()){
        while (n!=null ){
            s.add(n);
            n = n.leftNode;
        }
        n = s.pop();
        System.out.print(n.value + " ");
        n = n.rightNode;
    }
}
</code></pre>

<p>```</p>

<h3>后序遍历</h3>

<ul>
<li>递归实现</li>
</ul>


<p>```
public void preOrderTravNoRecurII(Node n) {</p>

<pre><code>    System.out.println("No Recursive: ");
    Stack&lt;Node&gt; s = new Stack&lt;Node&gt;();
    while (n != null | !s.empty()){
        while (n!=null ){
            System.out.print(n.value + " ");
            s.add(n);
            n = n.leftNode;
        }
        n = s.pop();

        n = n.rightNode;
    }
    System.out.println();
}
</code></pre>

<p>```</p>

<ul>
<li>非递归实现</li>
</ul>


<p>初始：1.维护一个栈S、一个节点变量N和一个标记数组。节点变量赋值为根节点，栈暂时存储便利到的节点，标记数组用于标记栈中的节点是否已经访问过右边节点。2.将根节点的所有左儿子压入栈中。</p>

<p>循环：依次处理栈中节点。如果节点有右儿子，且没有被处理过（通过标记数组判定），则将右子树的根节点及其左儿子全部压入栈中；如果已经处理过或者没有右儿子，则输出并出栈。</p>

<p>分析：与前序和中序的一个大的不同在于需要用标记数组标记节点的右子树是否已经访问过。对每个节点进行处理的时候，都保证已经处理完了左右子树（通过先压入左边儿子为主线，处理栈中的每个节点时，再压入右边儿子来实现）。</p>

<p>```
public void postOrderTravNoRecu(Node n) {</p>

<pre><code>    Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();
    int[] flag = new int[max];

    while (n != null) {
        stack.push(n);
        flag[stack.size()] = 0;
        n = n.leftNode;
    }

    while (!stack.empty()) {
        n = stack.peek();
        while(n.rightNode != null &amp;&amp; flag[stack.size()] == 0) {
            n = n.rightNode;
            flag[stack.size()] = 1;
            while (n != null) {
                stack.push(n);
                flag[stack.size()] = 0;
                n = n.leftNode;
            }
            n = stack.peek();//TODO be careful about this
        }
        n = stack.pop();
        System.out.print(n.value + " ");
    }

}
</code></pre>

<p>```</p>

<h3>层序遍历</h3>

<ul>
<li>无法使用递归方法</li>
</ul>


<p>层序遍历不同于其他的遍历。可以通过反证法证明：</p>

<p>如果能实现对A节点的层序递归，在对A节点处理的过程中，应该递归的对两个儿子B和C分别调用了层序遍历。在这种情况下，我们无法让B和C的同一个层级的儿子在集中的时间中被遍历到，换言之，B的第一层儿子在对B的调用中被遍历，而C的第一层儿子，则在对C的调用中遍历，这是分离开的。不成立，得证。</p>

<ul>
<li>非递归方法：</li>
</ul>


<p>分析：此方法类似于前序遍历的非递归方法的第一种。用一个栈维护信息。</p>

<p>```</p>

<pre><code>public void levelOrderTrav(Node n) {
    System.out.print("Level OrderTrav: ");

    Queue&lt;Node&gt; q = new LinkedList&lt;Node&gt;();
    q.add(n);
    while (q.size() != 0) {
        n = q.poll();
        System.out.print(" " + n.value);
        if (n.leftNode != null) 
            q.add(n.leftNode);
        if (n.rightNode != null)
            q.add(n.rightNode);

    }
}
</code></pre>

<p>```</p>

<h2>总结</h2>

<p>非递归实现的代码相对来说没有递归实现的直观。其核心都是维护了一个栈来保存状态，避免了产生过多方法调用栈浪费内存空间。</p>

<p>本文中针对二叉树的几种遍历方式，描述了递归和非递归的解决方案。普遍意义的递归转非递归的方法和思想，将在另外一篇博文中介绍;)。欢迎交流。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PDW中的Split Querying Process]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/04/25/split-querying-process-in-polybase/"/>
    <updated>2013-04-25T22:59:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/04/25/split-querying-process-in-polybase</id>
    <content type="html"><![CDATA[<p>最近看了关于SQL Server的分布式处理方面的论文，觉得它提出的Polybase跟之前看过的HadoopDB有些神似，这里做个小总结（抽空再把HadoopDB的总结贴出来）。</p>

<p>不算翻译，只是挑出自己认为是重点的部分。详细情况，还请论文查阅原文，引用中有写明出处。文章末尾有我总结的slides，可以辅助查阅。</p>

<p>由于缺乏实践经验，很多东西未必能理解其本质。如有其他观点，还请多指教。</p>

<p>当下的计划就是开始自己搭环境，实践起来!~</p>

<h2>背景</h2>

<p>商业应用中，越来越多的需要将结构化数据和非结构化数据存储、处理混合起来。
目前，已经有很多公司、产品致力于这部分的研究，微软发的这篇论文，也正是基于PDW V2的这一新功能提出的新的解决方案。</p>

<!--more-->


<h3>Polybase简介：</h3>

<p>是SQL Server PDW V2的一个新功能：通过使用SQL来管理和查询hadoop集群中的数据。
它同时能处理结构化和非结构化的数据，特点是结合了HDFS的外部表，使用基于开销的查询优化器来做分裂查询处理。</p>

<h2>相关研究</h2>

<ul>
<li><p>sqoop：用于在hadoop和结构化数据9比如关系型数据库之间传输数据。</p></li>
<li><p>teradata&amp; Asterdata&amp; Greenplum&amp; Vertica：通过外部表（external table）实现基于SQL的对hadoop中所存数据的操作。</p></li>
<li><p>Orable：基本机制也是建立外部表；另外还开发了用于加载hadoop的大数据到Oracle自家数据库的工具OLH(Oracle loader for Hadoop)。</p></li>
<li><p>IBM、Netezza:使用mapreduce方法获取分布式环境下各个节点的数据执行处理。</p></li>
<li><p>Hadapt: (HadoopDB)：HadoopDB是来自耶鲁大学的创意，并商业化为Hadapt项目。这是首个提出使用类SQL语言、集合Hadoop系统实现对RDBMS的操作的想法。实现相对简单，源代码3千多行，在Hadoop中对其中的几个模块做了二次开发。</p></li>
</ul>


<h2>PDW</h2>

<p>Polybase是PDW V2的一个新feature，那么，首先，让我们来看一下所谓的PDW是什么。</p>

<p>PDW是一个基于SQL Server的shared-nothing的并行数据库系统。</p>

<p>PDW（Parallel Data Warehouse）架构图：</p>

<p><img src="http://dl.dropboxusercontent.com/u/64021093/pdw/Image0.png"></p>

<h3>PDW系统中的组件：</h3>

<h5>节点</h5>

<ul>
<li>control node：</li>
</ul>


<p>类似于Hadoop中的master节点。运行着PDW Engine，负责：查询语法分析，优化，生成分布式执行计划DSQL，控制计划实施</p>

<ul>
<li>compute node：</li>
</ul>


<p>类似于Hadoop中的slave节点。数据存储和查询执行</p>

<h4>DMS</h4>

<p>Data Moving Service，起功能有：</p>

<ul>
<li><p>1.repartition rows of a table among SQL Server instances on PDW compute nodes</p></li>
<li><p>2.针对ODBC的类型转换。</p></li>
</ul>


<h2>Polybase</h2>

<h3>Polybase使用场景</h3>

<p>如图</p>

<p><img src="http://dl.dropboxusercontent.com/u/64021093/pdw/Image1.png"></p>

<p>（a）中PDW与Hadoop一起完成了数据处理任务，并输出结果；</p>

<p>（b）中处理数据后，结果直接存储到HDFS中</p>

<p>充分利用SQL Server PDW的性能优势，特别是它的基于开销的并行查询优化器和执行引擎。</p>

<h3>Polybase的环境需求</h3>

<ul>
<li>1.PDW与Hadoop集群可以重叠，也可以分离。</li>
<li>2.windows 和 linux部署的hadoop集群都支持。</li>
<li>3.支持所有标准的HDFS文件格式，包括文本、序列化文件、RCFiles。只要定义好对应的Inputformat和outputFormat，所有定制文件格式也支持。</li>
</ul>


<h3>核心组件</h3>

<ul>
<li>1.外部表：用于在PDW中实现对数据的操作语义。</li>
<li>2.HDFS Bridge：DMS中的组件，用于实现PDW节点域Hadoop的通信。</li>
<li>3.基于开销的查询优化器：将常规SQL查询语句转化为DSQL（分布式SQL查询语句），并结合集群状况（比如Hadoop和PDW集群规模，运行状况等），合理选择优化方式。</li>
</ul>


<h3>1.外部表</h3>

<p>PDW需要了解到Hadoop集群中数据的模型。于是就有了这个外部表。
实例如下：</p>

<p>创建集群：</p>

<p>```
CREATE HADOOP_CLUSTER GSL_CLUSTER</p>

<pre><code>  WITH (namenode=‘hadoop-head’,namenode_port=9000,

  jobtracker=‘hadoop-head’,jobtracker_port=9010);
</code></pre>

<p>```</p>

<p>创建文件格式：</p>

<p>```
CREATE HADOOP_FILEFORMAT TEXT_FORMAT</p>

<p>  WITH (INPUT_FORMAT=‘polybase.TextInputFormat’,</p>

<p>  OUTPUT_FORMAT = ‘polybase.TextOutputFormat’,</p>

<p>  ROW_DELIMITER = '\n', COLUMN_DELIMITER = ‘|’);</p>

<p>```</p>

<p>根据集群和文件信息，创建外部表
```
CREATE EXTERNAL TABLE hdfsCustomer</p>

<p>  ( c_custkey       bigint not null,</p>

<pre><code>c_name          varchar(25) not null,

 .......
)
</code></pre>

<p>WITH (LOCATION='/tpch1gb/customer.tbl',</p>

<p>FORMAT_OPTIONS (EXTERNAL_CLUSTER = GSL_CLUSTER,</p>

<p>EXTERNAL_FILEFORMAT = TEXT_FORMAT));
```</p>

<h3>2.HDFS Bridge</h3>

<p>结构如图：
<img src="http://dl.dropboxusercontent.com/u/64021093/pdw/Image2.png"></p>

<p>HDFS shuffle阶段：通过DMS从hadoop读取数据的阶段。
涉及到hdfs中的数据处理时，处理过程如下：</p>

<ul>
<li><p>1.跟namenode通信，获得hdfs中文件的信息</p></li>
<li><p>2.hdfs中文件信息 +  DMS实例个数 -> 每个DMS的输入文件（offset、长度） #力求负载均衡</p></li>
<li><p>3.将DMS的输入文件信息传递给各个DMS，DMS通过 openRecordReader（）方法构建RecordReader实例，直接与对应的datanode通信，获取数据，并转换为ODBC格式（有时候类型转换提前到mapreduce中以利用hadoop集群的计算能力）。读取过程中，使用了buffer机制提高效率。有时候数据会被提前到从HDFS中读出时执行，而不是到DMS中执行。这是为了充分利用hadoop集群的计算能力，节约CPU秘籍的DMS shuffle的计算。</p></li>
</ul>


<p>写入hadoop的过程与此类似。</p>

<h3>3.查询优化</h3>

<ul>
<li><p>1.PDW Parser(在PDW Engine的进程中完成)。</p></li>
<li><p>2.SQL Server Query Optimizer(在control node的SQL Server的进程中完成)：使用bottom-up的方式进行查询优化，并在合理的位置插入数据迁移的操作符（用于分布式环境的数据迁移指令），:生成查询计划，存储在Memo数据结构（http://www.benjaminnevarez.com/2012/04/inside-the-query-optimizer-memo-structure/）中 。</p></li>
<li><p>3.XML geneator(在control node的SQL Server的进程中完成)。接收Memo，并转换格式，往下传递。</p></li>
<li><p>4.Query Optimizer(在PDW Engine的进程中完成)：根据Memo生成DSQL。</p></li>
<li><p>5.基于开销的查询优化：判定是否将SQL语句推送到Hadoop中执行。</p>

<p>  考虑外部表的样本数据的直方图、集群的规模等因素...选择最优优化方案。</p></li>
</ul>


<h5>样本数据处理:</h5>

<p>定义对应外部表列的详细样本数据：</p>

<p><code>
CREATE STATISTICS hdfsCustomerStats ON
hdfsCustomer (c_custkey);
</code></p>

<p>对样本数据的处理的方式如下：</p>

<ul>
<li>1.通过DMS或者map job读取sample数据，</li>
<li>2.分发到不同的comute节点的暂存表。</li>
<li>3.每个节点分别计算直方图。</li>
<li>4.汇总直方图，存储到control node数据库的catalog中</li>
</ul>


<p>缺点是在此过程中没有利用好hadoop集群的计算能力。</p>

<h3>语义兼容</h3>

<p>涉及到Java和SQL以及之间的转换。包括这三个方面：</p>

<ul>
<li>数据类型的语义.</li>
<li>表达式的语义</li>
<li>异常处理机制</li>
</ul>


<p>例如："a+b"，其中a，b都为null，SQL结果为NULL，而Java则会抛出NullException。</p>

<p>处理原则是：能转化的类型则做好转化包装；不能转换的则标记为无法实现，仅限PDW实现。</p>

<h3>举例：</h3>

<p><code>
   SELECT count (*) from Customer
  WHERE acctbal &lt; 0
  GROUP BY nationkey
</code></p>

<p>如图所示为处理过程</p>

<p><img src="http://dl.dropboxusercontent.com/u/64021093/pdw/Image4.png"></p>

<p><img src="http://dl.dropboxusercontent.com/u/64021093/pdw/Image5.png"></p>

<p><img src="http://dl.dropboxusercontent.com/u/64021093/pdw/Image6.png"></p>

<h3>Polybase的MapReduce Join实现</h3>

<p>使用distributed hash join实现（只有equi-join能被在mapreduce中完成）</p>

<p>小表作为build side ，并被物化（materialized）到HDFS，大表作为probe side。</p>

<p>在Hadoop的Map任务中：读取物化好的build side到内存，构成hash table。</p>

<p>probe side经过hash后对比hash表，做正确的链接。</p>

<p>为了让build side置于内存中，需要计算build side的大小、每个task拥有的内存大小，task中执行其他操作需要的内存空间。
当然，build side也可能被复制多分，以提高效率。</p>

<p><a href="http://dl.dropboxusercontent.com/u/64021093/pdw/Split%20Query%20Processing%20in%20Polybase.pptx">本文演示slides下载链接，点击获取</a></p>

<h2>引用</h2>

<ul>
<li>Split Query Processing in Polybase(SIGMOD’13， June 22-27,2013,New York,USA.) Microsoft Corporation</li>
<li>Polybase:  What, Why, How(ppt) Microsoft Corporation</li>
<li>Query Optimization in Microsoft SQL Server PDW(SIGMOD'12, May 20-24,2012,Scottsdale,Arizona,USA) Microsoft Corporation</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[winsock出错引起的断网]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/04/23/winsock-kills-internet/"/>
    <updated>2013-04-23T22:24:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/04/23/winsock-kills-internet</id>
    <content type="html"><![CDATA[<h3>背景</h3>

<p>实验室有二十来台PC机，30+的服务器集群，网络拓扑比较复杂。简单地说，有网关连着校网，校网无法直接访问学校外的网络，只能通过拨vpn来实现外网访问。而校网最近也不稳定，时常断网。</p>

<p>今天，实验室的一台电脑今天突然出无法上网了，而其他人则在正常上网。症状很奇怪：</p>

<ul>
<li>浏览器只能上google，其他任何网站都上不去。</li>
<li>QQ、ftp等各种需要连网的软件也都无法正常连网。</li>
<li>一切的发生，只是在PC使用者认为正常的操作中发生：上网，连网下围棋，聊QQ，然后…</li>
</ul>


<!--more-->


<p>没有经验的我做出了如下一系列的<em>排查</em>：</p>

<h3>1st：</h3>

<p>为了排除网络环境的因素，我尝试对比了连vpn和不连vpn的情况.</p>

<p>症状没有丝毫改变。</p>

<h3>2nd：</h3>

<p>我尝试着ping了许多网站，检查是否是dns污染。</p>

<p>结果包括学校内部网络和外部网络，都能ping通。</p>

<p>这意味着网络层是没有问题的。那只能是传输层或者更上层的问题了。但奇怪的是，google是能连接上的，大概不会是驱动的问题吧？ =.=，对windows环境的不熟悉，让我无所适从。</p>

<h3>3rd:</h3>

<p>看到了运行着的360安全卫士 =_=!，对它没好感，删单个进程还杀不死，会有其他进程重新将他开启！果断删除。同时，重启，碰碰运气。windows的问题印象里总是各种奇葩。</p>

<p>以失败告终。</p>

<h3>Final:</h3>

<p>最终还是zfz童鞋从网上搜得了解决方法：
打开cmd，输入如下指令，然后重启即可。
```</p>

<blockquote><p>netsh winsock reset
```</p></blockquote>

<p>原来是windows的socket接口出了问题，通过重置来解决。</p>

<p>每每想到windows的不可控性，不禁唏嘘，这次又长见识了。</p>

<h6>参考资料：</h6>

<ul>
<li><a href="http://www.zoublog.com/technology/can-ping-dns-resolution-can-not-open-page-solution.html">《能Ping通，能DNS解析，不能打开网页(登陆QQ等)的解决办法》</a></li>
<li><a href="http://en.wikipedia.org/wiki/Winsock">winsock</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SSH原理和使用]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/04/19/use-ssh/"/>
    <updated>2013-04-19T21:44:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/04/19/use-ssh</id>
    <content type="html"><![CDATA[<p>在linux上工作，ssh是必须要了解的技术方法。它可以建立起多台主机之间的安全的加密传输，以进行远程的访问、操控、传输数据。</p>

<h2>ssh是什么</h2>

<p>SSH為Secure Shell的縮寫。為建立在应用层和传输层基础上的安全协议。</p>

<p>传统的网络服务程序，如FTP、POP和Telnet其本质上都是不安全的；因为它们在网络上用明文传送数据、用户帐号和用户口令，很容易受到中间人（man-in-the-middle）攻击方式的攻击。就是存在另一个人或者一台机器冒充真正的服务器接收用户传给服务器的数据，然后再冒充用户把数据传给真正的服务器。
而SSH是目前较可靠，專为远程登录会话和其他网络服务提供安全性的协议。利用SSH协议可以有效防止远程管理过程中的信息泄露问题。透過SSH可以對所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗。
SSH之另一項優點為其传输的数据是经过压缩的，所以可以加快传输的速度。SSH有很多功能，它既可以代替Telnet，又可以为FTP、POP、甚至为PPP提供一个安全的「通道」。
了解这么多就好了，其实ssh连接也就是可以理解成经过加密的远程访问啦。</p>

<!--more-->


<p>---（来自中文维基）</p>

<h2>ssh连接的验证、加密方式</h2>

<p>ssh连接是CS模型（客户端-服务器），客户端发出连接申请，服务器对客户端进行验证，再考虑是否接受连接申请。</p>

<p>ssh的安全加密方式的理论基础是非对称加密体系。而非对称加密中，常见的一种就是RSA加密算法。在使用ssh，务必先弄清楚非对称加密和rsa的算法流程。详情参见<a href="http://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95">RSA加密算法</a>。</p>

<p>ssh有两种级别的安全验证：账户口令验证、rsa加密验证。详细参数，可以在sshd_config配置文件中设置(Ubuntu是/etc/ssh/sshd_config，mac下是/etc/sshd_config)</p>

<h3>账号口令验证</h3>

<p>直接输入所要登陆的用户的口令是默认的方式。不需要修改配置文件。</p>

<p>如果直接从客户端将用户密码传输到服务器，那么密码信息很容易被中间人截获，从而实现重放攻击。ssh的实现方式是：</p>

<ul>
<li>1.客户端向ssh服务器发出请求，服务器将自己的公钥返回给客户端；</li>
<li>2.客户端用服务器的公钥加密自己的登录密码，再将信息发送给服务器；</li>
<li>3.服务器接收到客户端传送的密码，用自己的私钥解码，如果结果正确，则同意登录，建立起连接。</li>
</ul>


<p>这种方式还是有漏洞的，中间人可以假扮成服务器，骗取客户端的密码。</p>

<h3>RSA加密验证</h3>

<p>rsa加密验证方式，充分利用了非对称加密体系的优势，不需要在网络传输密码，完全杜绝了中间人攻击的可能。步骤如下：</p>

<h5>准备工作</h5>

<ul>
<li>-1.客户端先使用 ssh-keygen 命令，生成私钥和公钥。按照默认配置，私钥会被保存在~/.ssh/id_rsa中，公钥则在~/.ssh/id_rsa.pub中。(一般别修改这里的文件)</li>
<li>0.客户端通过安全的方式将公钥发送给服务器。在服务器端，将客户端发的公钥写入到~/.ssh/authorized_keys文件末尾。</li>
</ul>


<h5>建立连接</h5>

<ul>
<li>1.客户端发出申请。服务器产生session密钥对，返回通过对应客户端的公钥加密后的session公钥。</li>
<li>2.客户端用自己的密钥解密信息，得到session公钥。</li>
<li>3.之后的数据交互，都通过对方方公钥加密，对方收到信息后，用其私钥解密，实现安全加密过程。</li>
</ul>


<h2>免密码的RSA加密方式实施过程</h2>

<ul>
<li>1.安装ssh</li>
</ul>


<p>mac下自带的有，ubuntu下直接sudo apt-get install ssh。</p>

<ul>
<li>2.在客户端生成私钥公钥</li>
</ul>


<p>使用ssh-keygen命令生成密钥对。遇到提示都直接回车（其中passphrase是保护rsa密钥的另一套加密方式）。</p>

<p><code>
$ ssh-keygen   
Generating public/private rsa key pair.  
Enter file in which to save the key (/Users/biaobiaoqi/.ssh/id_rsa): /Users/biaobiaoqi/.ssh/id_rsa  
Enter passphrase (empty for no passphrase):   
Enter same passphrase again:   
Your identification has been saved in /Users/biaobiaoqi/.ssh/id_rsa.  
Your public key has been saved in /Users/biaobiaoqi/.ssh/id_rsa.pub.  
The key fingerprint is:  
b7:c2:5c:3f:83:5e:5e:93:a4:42:db:51:d8:ac:07:66 biaobiaoqi@biaobiaoqi.local  
The key's randomart image is:  
+--[ RSA 2048]----+  
|                 |  
|             +   |  
|            E +  |  
|           o +   |  
|        S + o o  |  
|       o + * = . |  
|        + = B +  |  
|         o + + . |  
|          . .    |  
+-----------------+  
</code></p>

<p>结果是在~/.ssh/下生成了 id_rsa（私钥）和id_rsa.pub（公钥）</p>

<ul>
<li>3.将客户端的公钥id_rsa.pub传递给服务器</li>
</ul>


<p>传送id_rsa.pub到服务器上，并将其内容写入到~/.ssh/authorized_keys文件尾。</p>

<p>可以物理的用U盘转运（似乎更安全），也可以使用scp指令（这个时候就需要运用到口令验证的ssh方式)</p>

<p><code>
$scp ~/.ssh/id_rsa.pub user@host:~/.ssh/tmp_id_rsa.pub
$ssh user@host "cat ~./ssh/tmp_id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys"
</code></p>

<p>在执行scp传输的过程中，如果是第一次ssh连接到服务器，客户端会提示是否信任这个主机，比如：
<code>
$scp ~/.ssh/id_rsa.pub user@host:~/.ssh/tmp_id_rsa.pub
The authenticity of host XXX can't be established.
ECDSA key fingerprint is xxxxxxxxxxxxxxxxxxxxxx.
Are you sure you want to continue connecting (yes/no)?
</code>
原因是，客户端不确定所连接的host是否是真正的host。一般情况，直接输入yes，继续就好了。这里有较详细的解释：<a href="http://stackoverflow.com/questions/3663895/ssh-the-authenticity-of-host-hostname-cant-be-established">点击连接</a></p>

<p>然后就可以免密码、更安全的登录啦
<code>
 ssh xxxx@hostAddress
</code></p>

<p>在ssh登录服务器时，如果出现如下问题：<em>Agent admitted failure to sign using the key</em>则需要手工将客户端私钥加入到ssh管理体系中。使用 ssh-add 指令。（具体机理还不太清楚）
<code>
$ssh-add   ~/.ssh/id_rsa
</code></p>

<h2>and one more thing;)</h2>

<h4>ssh+firefox+autoproy</h4>

<p>看看wall外面的世界，是多么美好的事情。ssh能帮我们做到，只要有一台在wall外的主机做代理。
具体方式参见博文：<a href="http://reverland.bitbucket.org/ssh_climbe.html">ssh+firefox-autoproxy</a></p>

<h4>SCP命令加密赋值数据</h4>

<p>```</p>

<h1>将本地文件复制到远程主机上</h1>

<p>$scp ~./tmp user@rehost:~/tmp</p>

<h1>见远程主机上的文件复制到本地</h1>

<p>$scp user@rehost:~/tmp ~./tmp</p>

<h1>复制的是目录，需要迭代，添加-r参数</h1>

<p>$scp -r user@rehost:~/tmpDir ~./tmpDir
```</p>

<h4>SSH的配置</h4>

<p>具体参数细节参见博文：<a href="http://www.ibm.com/developerworks/cn/aix/library/au-sshsecurity/">SSH 安全性和配置入门</a>
<a href="http://blog.licess.org/sshd_config/">sshd_config配置 详解</a></p>

<h2>推荐阅读：</h2>

<ul>
<li><a href="http://blog.lizhigang.net/archives/249">《linux ssh 使用深度解析（key登录详解）》</a></li>
<li><a href="http://wiki.tuna.tsinghua.edu.cn/SshKeyHowto">《使用 RSA 密钥对进行 SSH 登录验证》</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html">《SSH原理与运用（一）：远程登录》</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html">《SSH原理与运用（二）：远程操作与端口转发》</a></li>
<li><a href="http://reverland.bitbucket.org/ssh_climbe.html">ssh+firefox-autoproxy</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/aix/library/au-sshsecurity/">SSH 安全性和配置入门</a></li>
<li><a href="http://blog.licess.org/sshd_config/">sshd_config配置 详解</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
