<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: pat | Biaobiaoqi的博客]]></title>
  <link href="http://biaobiaoqi.github.com/tags/pat/atom.xml" rel="self"/>
  <link href="http://biaobiaoqi.github.com/"/>
  <updated>2013-08-02T20:29:10+08:00</updated>
  <id>http://biaobiaoqi.github.com/</id>
  <author>
    <name><![CDATA[Biaobiaoqi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PAT 1041-1050 题解]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/08/01/pat-1041-1050-solutions/"/>
    <updated>2013-08-01T01:43:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/08/01/pat-1041-1050-solutions</id>
    <content type="html"><![CDATA[<p>浏览全部代码：<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/tree/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel">请戳</a></p>

<p>本文谨代表个人思路，欢迎讨论;)</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1041">1041. Be Unique (20)</a></h2>

<h5>题意</h5>

<p>给出N (&lt;=105)个数（数值范围为 [1, 10<sup>4]），找到其中不重复的第一个数字。比如给出`5</sup> 31 5 88 67 88 17<code>，答案是</code>31`。</p>

<h5>分析</h5>

<p>简单模拟题，开一个大数组<code>int a[10001];</code>，以读入的数为下标，记录count:<code>a[index] ++;</code>。结果输出第一个存储为1的下标:<code>if (a[index] == 1)</code>。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1042">1042. Shuffling Machine (20)</a></h2>

<h5>题意</h5>

<p>背景是洗牌机的洗牌过程。过程是给定洗牌的每张牌的位置替换序列，由原来的次序算出最后的牌的平排列。</p>

<p>比如原有的次序为<code>S3, H5, C1, D13, J2</code>，
给定的洗牌顺序为<code>4, 2, 5 ,3 ,1</code>，那么一次洗牌的结果为：<code>J2, H5, D13, S3, C1</code>。
如果需要两次洗牌，则结果为<code>C1, H5, S3, J2, D13</code>。</p>

<p>输入为对一整副牌（54张）的洗牌策略，以及洗牌次数N，要求计算出最后的洗牌结果。</p>

<h5>分析</h5>

<p>简单hash题。</p>

<!--more-->


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1043">1043. Is It a Binary Search Tree (25)</a></h2>

<h5>题意</h5>

<p>二叉搜索树的定义就不重复了，题目新定义了一个镜像二叉搜索树，就是将一颗二叉搜索树所有节点的左右子树交换后的二叉树。</p>

<p>输入是一个二叉树的前序排列，要求判定是否是一个二叉搜索树或者镜像二叉搜索树。如果是，输出该树后序遍历的序列。</p>

<h5>分析</h5>

<p>解题思路：</p>

<ul>
<li>1.BST 很特殊，实质上 BST 的所有节点的顺序排列就是中序遍历了。</li>
<li>2.要检查树是否是 BST 或者镜像 BST，只需按照重建树的思路，在每次重建的过程中做适当检查即可。检查思路是：检查前序遍历序列中，根节点之后的节点排序是否符合 BST 的二分规则（即前一段都是小于根节点的，后一段都是大于根节点的）。</li>
<li>3.最后的输出是后序遍历。过程中其实并不用构建整个树，直接在处理过程中，按后序的方式存储节点到队列中即可。</li>
</ul>


<p>更多相关分析，参见博文<a href="../../../../2013/04/27/pat1020-pat1043-rebuild-binary-tree/">《根据前中后序和层序重建二叉树》</a>。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1044">1044. Shopping in Mars (25)</a></h2>

<h5>题意</h5>

<p>火星人购物使用钻石链，每颗钻石都有一定的价值。付款是，要求从钻石链上找到所有刚好能匹配到商品价值的连续的钻石子链，如果没有，
则找到超过商品价值的最小的钻石子链。</p>

<p>比如钻石链为<code>3 2 1 5 4 6 8 7</code>，商品价值为<code>15</code>，则候选的方案有：第4到第6颗的子链<code>5 4 6</code>，第7到第8颗：<code>8 7</code>。</p>

<p>输入为一个钻石链以及商品的价值，要求找到所有满足条件的分割方案，按起始点从小到大排序输出。</p>

<h5>分析</h5>

<p>由于时间限制有些严格，需要做足够的优化：</p>

<ul>
<li>1.为了便于计算某个区间的累加值，在存储钻石串时，可以在<code>index</code>位置存储包括当前钻石在内的之前所有钻石价值的累加和。</li>
<li>2.使用两层循环遍历所有可能，在遍历以位置i为其实坐标的子串时，不应该将结束位置初始化为i，而是应该是以<code>i-1</code>为起始位置的搜索过程中的break时的
结束位置的下标减1.</li>
</ul>


<p>其中第2条的证明如下：</p>

<p>算法中首先计算以<code>i</code>为起始位置的子串的累加值。假定计算到<code>j</code>满足累加值等于或者刚好大于商品价值<code>m</code>。之后，结束以<code>i</code>位置开始的子串的探寻，进入下一阶段以i+1为起始位置的搜索。
由于<code>[i, j]</code>的累加和刚好等于<code>m</code>，则<code>[i, j - 1]</code>的累加和肯定小于<code>m</code>，那么<code>[i + 1, j - 1]</code>的累加和也肯定小于<code>m</code>。</p>

<p>综上述，在以<code>i+1</code>为起始位置的搜索中，可以初始化结束位置为上一次搜索结束的位置减一，即<code>j - 1</code>.</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1045">1045. Favorite Color Stripe (30)</a></h2>

<h5>题意</h5>

<p>Eva对彩色条有特殊的癖好，对于一条五颜六色的彩带，她会减掉其中一些颜色块，让整个彩带的颜色顺序匹配到自己的一个颜色喜好顺序上。</p>

<p>举例来说，她喜欢的颜色顺序为{2 3 1 5 6}，给定的彩带的颜色顺序为{2 2 4 1 5 5 6 3 1 1 5 6}，那么经过她的剪辑，留下的彩带的可能选项有：{2 2 1 1 1 5 6}
{2 2 1 5 5 5 6}，{2 2 1 5 5 6 6}和{2 2 3 1 1 5 6}。</p>

<p>我们的任务是找到其中最长的剪辑可能。</p>

<h5>分析</h5>

<p>这是经典的最长递增子序列问题(LIS)，递增在这里体现为子序列的颜色顺序要遵照Eva的对颜色的喜好顺序。使用动态规划解决。</p>

<ul>
<li>1.剔除不在Eva喜欢颜色列表中的颜色。</li>
<li>2.DP的状态： 用<code>length[max]</code>数组存储状态，<code>length[i]</code>表示到彩带的第i个位置为止，包含该颜色的符合Eva喜好顺序的子串长度的最长值。记得在每次</li>
<li>3.DP的子问题：<code>length[i]</code>等于在其之前的所有<code>lengths[j]</code>跟<code>i</code>位置颜色组合后的最长子串值。</li>
</ul>


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1046">1046. Shortest Distance (20)</a></h2>

<h5>题意</h5>

<p>给定在圆环上的几个点的相对位置，要求计算不同点之间的距离。</p>

<h5>分析</h5>

<p>简单模拟。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1047">1047. Student List for Course (25)</a></h2>

<h5>题意</h5>

<p>根据每名学生填报的课程，按顺序输出每门课程的学生名单。其中学生总量为N(&lt;=40000)，课程总量为K(&lt;=2500)。学生姓名为3个大写英文字符加一个数字。</p>

<h5>分析</h5>

<p>倒排索引的模拟。可以针对学生姓名做hash方式的优化。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1048">1048. Find Coins (25)</a></h2>

<h5>题意</h5>

<p>给定一系列硬币，以及一个商品的价格。要求从硬币中找到两个硬币让他们的组合等于商品的价格。如果有多个，输出有用最小单个值的硬币组合。</p>

<h5>分析</h5>

<p>首先，硬币中币值不小于商品价格的可以过滤掉。遍历过程中，使用hash标记的方法，设定一个<code>coins[MAXVALUE]</code>（其中MAXVALUE为商品价格的最大值）记录已有的币值种类，
在遍历的过程中，一边将读入的硬币增加到<code>coins[]</code>中，一边计算满足条件的最小币值。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1049">1049. Counting Ones (30)</a></h2>

<h5>题意</h5>

<p>给定一个正整数N(&lt;=2<sup>30)，要求计算所有小于N的正整数的各个位置上，1出现的次数之和。</sup></p>

<h5>分析</h5>

<p>比较有思维难度的一题，核心在于找规律。10ms的时间限制表明了不能用常规的循环遍历来解决。需要从简单的case找规律，逐步扩大到常规的情况。</p>

<p>详情参见《编程之美》P132页《1的数目》。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1050">1050. String Subtraction (20)</a></h2>

<h5>题意</h5>

<p>给定两个字符串，S1和S2,要求将S2中的字符从S1串中剔除。</p>

<h5>分析</h5>

<p>用Hash的方式标记需要剔除的字符。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PAT 1031-1040 题解]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/08/01/pat-1031-1040-solutions/"/>
    <updated>2013-08-01T01:43:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/08/01/pat-1031-1040-solutions</id>
    <content type="html"><![CDATA[<p>早期部分代码用Java实现。由于PAT虽然支持各种语言，但只有C/C++标程来限定时间，许多题目用Java读入数据就已经超时，后来转投C/C++。浏览全部代码：<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/tree/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel">请戳</a></p>

<p>本文谨代表个人思路，欢迎讨论;)</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1031">1031. Hello World for U (20)</a></h2>

<h5>题意</h5>

<p>将给定的字符串打印出U型。</p>

<p>比如给定<code>helloworld</code>，打印出</p>

<p>```</p>

<p>h  d
e  l
l  r
lowo</p>

<p>```
设定左边的字符个数为n1,底边字符个数为n2,右边字符个数为n3。需要满足 n1 = n3 = max
{k|k &lt;= n2 for all 3 &lt;= n2 &lt;= N} with n1 + n2 + n3 -3 = N.</p>

<h5>分析</h5>

<p>简单模拟题。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1032">1032. Sharing (25)</a></h2>

<h5>题意</h5>

<p>为了节省存储空间，单词使用链表实现。比如对于<code>loading</code>和<code>being</code>两个单词，有如下存储结构：</p>

<p>```
word1 : -> [l] -> [o] -> [a] -> [d]</p>

<pre><code>                                \
                                  [i] -&gt; [n] -&gt; [g] -&gt; null
                                /
</code></pre>

<p>word2 : -> [b] -> [e] -------------</p>

<p>```
输入中，指定了两个单词的首字符的地址，并给出了N (&lt;= 10<sup>5)个节点，每个节点包含：物理地址（5位的正整数），实际存储的字符以及指向的下一个节点的地址。NULL的地址是-1.</sup>
要求找到两单词的的公共后缀开始的地址，如果没有，则输出-1.</p>

<h5>分析</h5>

<p>既然是单词，它的长度应该是有限的，也就是链表不会出现环这种情况（实际上这里的处理方式对于有环无环都适用）。对第一个单词链表做遍历，对爬过的节点做好标记。第二个单词链表也同样做标记，一旦遇到已经标记过的节点，则该节点就是结果。</p>

<p>需要注意一点：直接使用map做节点的存储最后一个case会超时。而鉴于5位正整数的数据量，可以直接使用数组，用空间换时间。</p>

<!--more-->


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1033">1033. To Fill or Not to Fill (25)</a></h2>

<h5>题意</h5>

<p>高速路从A地到B地，路途有许多加油站，每个加油站的油价不一样，要求计算一个最优方案，使得以最便宜的开销跑完全程。</p>

<h5>分析</h5>

<p>用贪心算法，理清贪心算法的策略：</p>

<ul>
<li>1.从A加油站出发，在能行走的最大范围内，如果有比A站汽油更便宜的B站，则保证在A站点的加油量刚好满足能到达B站点；如果没有比A站汽油更便宜的站，则在A加满车油行走到【从A能走出的范围内】油价【最便宜】的站上，再行计算。</li>
<li>2.从A加油站出发，在能行走的最大范围内，如果没有其他站点，则A.dist + 一次最大的行走距离 为impossible情况下的最大站点。</li>
</ul>


<p> 注意有个陷阱：如果没有距离为0的加油站，则无法行驶。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1034">1034. Head of a Gang (30)</a></h2>

<h5>题意</h5>

<p>『gang』翻译过来是『一伙人』。gang的定义是一群人，至少有3个人，这群人中每个人之间都通过通话相连，且整个群体的通话时长超过一个阈值。整个gang的团体中，拥有的电话时长最长的人就是头目了。</p>

<p>题目给定了gang的阈值K，以及N个通话记录，每条记录包括主叫人、被叫人以及通话时间。要求计算出有几个gang，并按照gang的头目的字母顺序排序输出头目和其中成员数量。</p>

<h5>分析</h5>

<p>本题使用dfs求解比较方便。dfs能简单的实现状态值的记录，比如当前的gang的成员数量和权重，如果使用并查集，则相对复杂。</p>

<p>需要注意的坑点：如果建立邻接表时，每个通话记录都在两人头上计算了时间积累的，那么在判定gang的权重值是否低于阈值的时候，需要对阈值乘以2。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1035">1035. Password (20)</a></h2>

<h5>题意</h5>

<p>给定多个字符串，按要求替换其中的某些特殊字符，并按原顺序输出。如果字符串中没有需要修改的字符，则不舒服该字符串。</p>

<h5>分析</h5>

<p>简单的hash实现。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1036">1036. Boys vs Girls (25)</a></h2>

<h5>题意</h5>

<p>输入是一批学生的成绩，要求找出其中男生最低的成绩和女生最高的成绩，求其间的差值。如果无法计算，则输出NA.</p>

<h5>分析</h5>

<p>简单模拟题。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1037">1037. Magic Coupon (25)</a></h2>

<h5>题意</h5>

<p>背景是火星上的神奇的购物券购物策略：每张购物券上有一个整数，可正可负，商店里商品的标价也是一个整数，可正可负的。如果用正值购物券购买正值商品，则可获利两者之积；如果以负值购物券购买负值商品，也可获利两者之积；但其他情况，则会亏损。比如用面值为<code>2</code>的购物券购买面值为<code>3</code>的商品，获利<code>6</code>，用面值为<code>-5</code>的购物券购买面值为<code>-9</code>的商品，获利<code>45</code>，但如果用面值为<code>2</code>的购物券购买面值为<code>-3</code>的商品，则亏损<code>6</code>，</p>

<p>给定一组数量为NC购物券面值和一组数量为NP的商品面值，1&lt;= NC , NP &lt;= 10<sup>5，要求计算能获利的最大值。</sup></p>

<h5>分析</h5>

<p>同号相乘可获利，异号相乘会亏损。要使获利最大，使用贪心思想计算。实际上，不需要用完购物券或者买完商品，所以只需要将同号的数值乘积算出即可，没有更复杂的情况。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1038">1038. Recover the Smallest Number (30)</a></h2>

<h5>题意</h5>

<p>给定N(&lt;= 10000)个不超过8位的非负整数，要求将其按某个顺序拼接为一个数，使其值最小。</p>

<h5>分析</h5>

<p>容易简单的以为使用字典序排列拼接，实际上有一个特殊的拼接情况需要考虑。</p>

<p>比如数据<code>32 321 3214</code>，这是按字典序排列的，但实际上这并不是最小的拼接方式，最小的拼接方式是：<code>321 3214 32</code>。</p>

<p>比较这个实例，不难找到最小拼接的排序规律：</p>

<ul>
<li>1.两个字符串做比较时，如果其中一个字符串(a)是另一个字符串(ab)的前缀串，则需要将较长字符串(ab)除去前缀串的部分(b)与较短字符串(a)继续递归比较。比如，321和32，需要拿1和32做比较。又比如323和32比较，第一次拿3和32比较，第二次拿3和2按字典序比较。</li>
<li>2.其他情况按字典序比较。</li>
</ul>


<p>另外需要注意的一个坑是：如果没有数据，则输出0。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1039">1039. Course List for Student (25)</a></h2>

<h5>题意</h5>

<p>给出K(&lt;=2500)门课程，每门课程有Ni(&lt;=200)名学生，学生编号为四位字符串，前三位为小写英文字母，后一位是数字。另给出N个需要查询的学生编号。</p>

<p>要求列出对应查询编号学生的课程。如果有多个课程，需要按升序输出。</p>

<h5>分析</h5>

<p>这个题是个倒排索引的实现。不过在时间上卡的比较严。</p>

<p>使用最简单的思路：map&lt;string, vector<int> students倒排索引，在没有输出排序的课程列表时最后一个case已经超时；优化：将学生姓名的hash为int，减免了string的匹配过程，还是超时（map本身用红黑树实现，效率并不是特别高，还需要对每组数据进行排序），只能改变使用map的方式。</p>

<p>最终AC的解法是：</p>

<ul>
<li>构建一个从学生编号字符串到int值的hash函数，在读入学生编号后，hash到int值做处理。</li>
<li>不适用map结构，根据学生姓名的限制，设定一个<code>vector&lt;int&gt; st[26*26*26*10]</code>的数据结构，读入时直接倒排索引插入。</li>
</ul>


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1040">1040. Longest Symmetric String (25)</a></h2>

<h5>题意</h5>

<p>给定一个字符串，要求输出最长的连续对称子串的长度。比如给定字符串为<code>Is PAT&amp;TAP symmetric?</code>，其中最长对称子串为<code>s PAT&amp;TAP s</code>，所以输出结果11.</p>

<h5>分析</h5>

<p>这个题就是典型的Java实现timeout，而Cpp实现轻松过的类型。需要注意两点：</p>

<ul>
<li>1.有两种对称情况，一种形如<code>aba</code>，一种形如<code>abba</code>。</li>
<li>2.循环遍历的过程，以index为对称中心向两边扩散比较编码实现简单也更高效。</li>
</ul>


<p>另外，C读入一整行数据到char数组的方法可以用<code>gets(s);</code>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PAT 1021-1030 题解]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/08/01/pat-1021-1030-solutions/"/>
    <updated>2013-08-01T01:43:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/08/01/pat-1021-1030-solutions</id>
    <content type="html"><![CDATA[<p>早期部分代码用Java实现。由于PAT虽然支持各种语言，但只有C/C++标程来限定时间，许多题目用Java读入数据就已经超时，后来转投C/C++。浏览全部代码：<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/tree/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel">请戳</a></p>

<p>本文谨代表个人思路，欢迎讨论;)</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1021">1021. Deepest Root (25)</a></h2>

<h5>题意</h5>

<p>无环连通图也可以视为一棵树，选定图中任意一点作为根，如果这时候整个树的深度最大，则称其为deepest root。
给定一个图，按升序输出所有deepest root。如果给定的图有多个连通分量，则输出连通分量的数量。</p>

<h5>分析</h5>

<p>算法实现的步骤如下：</p>

<ul>
<li>1.使用并查集判断图是否为连通的。</li>
<li>2.任意选取一点，做dfs搜索，选取其中一个最远距离的点A，再做一次dfs，找到的所有距离最远的点以及点A都是deepest root。</li>
</ul>


<p>判定图是否连通使用union-find set即可。更关键的点在于找到deepest root。实际上，使用两次dfs就可以实现。
证明之前，先介绍两个概念，一个是直径，树的deepest root到最远叶子的路径我们暂称直径，而deepest root和最远叶子节点则成为端点。
注明关键在于以下两点：</p>

<ul>
<li><p>从任意一个点dfs得到的最远点都是直径的端点。证明如下：</p>

<p>  任意选一点A，做dfs查找距离A最远的点，因为是dfs，所以肯定会经过某直径上的点B，从B出发最远的点是直径上的端点C。
  那么，这个端点C为何一定是A的最远居里点呢？可以反证证明，如果有一个点D，A->D不经过直径，且length(A->D) > length(A->C)，
  那么，从C所在直径上构造出经过D的比原直径更长的直径，得证。</p></li>
<li><p>所有的树的直径都交于一点（或者公用段路径上的几点）。
于是，从B点dfs出发的所有最长距离的点即为deepest root。证明如下：</p>

<p>  如果两条直径不相交，而树上任意两点肯定连通，则从两直径上，可以选取两点连通以组成更长的直径；如果三条直径相较于不同的两点，也可以根据相交截断的长度组合出更长的直径。</p></li>
</ul>


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1022">1022. Digital Library (30)</a></h2>

<h5>题意</h5>

<p>给定N (&lt;=10000) 本书的信息，包括7位ID，最多80字符的书名，最多80字符的作者名，
多个最多10字符的关键词，最多80字符的出版商和属于[1000, 3000]的出版时间。
另给出M (&lt;=1000) 的查询请求，按照查询格式分为：</p>

<ul>
<li>1: 书名</li>
<li>2: 作者</li>
<li>3: 关键词</li>
<li>4: 出版商</li>
<li>5: 年份</li>
</ul>


<p>输出查询结果。如果有多个结果，按照书的ID的升序排列。</p>

<h5>分析</h5>

<p>简单模拟题。在使用Map结构来构建倒排索引的过程中，可以讨巧的避免根据不同查询类型使用两层map，
直接通过在key中增加查询标记来实现。另外C++的priority_queue支持对常规数据类型的最小堆实现：<code>priority_queue&lt;string, vector&lt;string&gt;, greater&lt;string&gt;&gt;</code>，方便了结果输出。</p>

<!--more-->


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1023">1023. Have Fun with Numbers (20)</a></h2>

<h5>题意</h5>

<p>给出一个20位的正整数，要求计算其乘以2的值，并判定结果的数值是否是原数字所有位数打乱的结果。结果输出Yes或No，以及乘以2以后的数字。</p>

<h5>分析</h5>

<p>判重使用Hash思想。过程如下：</p>

<ul>
<li>1.原数字按字符串读入，并在一个int hash[10]的hash数组中标记每个数值出现的次数，比如如果出现了四次1，则hash[1]=4。</li>
<li>2.模拟实现乘以2的简单乘法过程，没计算出一位的值，在hash[]中对应位置上减一。</li>
<li>3.最后通过判定hash是否全为1和最后结果是否有进位来做判定。</li>
</ul>


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1024">1024. Palindromic Number (25)</a></h2>

<h5>题意</h5>

<p>非回文数可以通过将它与它的倒转数相加，并不断迭代这一过程获得回文数的结果。比如67经过两次处理就得到了484：
<code>67 + 76 = 143, and 143 + 341 = 484.</code></p>

<p>给定一个数和迭代的次数，判断能否在迭代次数内获得回文结果。</p>

<h5>分析</h5>

<p>简单模拟题，处理数字，做逻辑判断。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1025">1025. PAT Ranking (25)</a></h2>

<h5>题意</h5>

<p>以PAT考试为背景，给所有人做排名。给定的数据包括N(&lt;=100)为赛区的数目，每个赛区的人数以及每个人的分数。
按照总排名、分区号、注册号的优先级排名。</p>

<h5>分析</h5>

<p>简单模拟题，使用qsort()排序，注意相同分数的人应该拥有相同的排名。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1026">1026. Table Tennis (30)</a></h2>

<h5>题意</h5>

<p>乒乓球俱乐部有K张乒乓球桌，其中有M张是VIP桌。有很多人到俱乐部打球，如果桌子都满了，多余的人只能排队等待。</p>

<p>有一个特殊的VIP制度：如果有空的VIP桌，那么等待队列中的第一对VIP会员可以使用这张卓，
如果等待队列中没有VIP会员，那么一般会员也可以使用VIP桌。当轮到VIP上的时候，没有VIP桌子，那么VIP用户也可以使用一般的桌子。</p>

<p>另外，每张桌服务一对会员的时间最大限制在两个小时。</p>

<p>给定了乒乓球桌的数量M(编号为1-M)，其中VIP卓的数量K，并指定是那几张桌子。给出来乒乓球俱乐部的N对会员的信息，每对会员有一个达到时间，
是否是VIP的标记以及打球的时间。要求计算出每对会员的等待时间，以及每张桌服务过的次数。</p>

<h5>分析</h5>

<p>排队模拟题。有两种思路：</p>

<ul>
<li>1.主体循环处理人。将乒乓球桌和人都当做资源，乒乓球桌对应记录了available的时间，每次取出available最早的时间，从等待队列中选
则最早的会员使用乒乓球桌。其中vip处理逻辑为：如果available并列最早的桌子中有vip桌，则看等待队列中有没有vip会员，
如果有则直接处理他，否则按照正常逻辑处理。每次将某会员安置到一个乒乓球桌上，则可以输出该会员的等待时间的结果信息，并将该乒乓球桌的
服务人数增加一。</li>
<li>2.主体循环是时间。这样需要模拟同一时刻所有的乒乓球桌以及等待队列，相对比较复杂。</li>
</ul>


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1027">1027. Colors in Mars (20)</a></h2>

<h5>题意</h5>

<p>给定三个十进制数，要求格式化输出其13进制表达。</p>

<h5>分析</h5>

<p>简单的数字处理和hash实现。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1028">1028. List Sorting (25)</a></h2>

<h5>题意</h5>

<p>模拟Excel中按列排序。N (&lt;=100000) 为数据条数，每条数据由三列组成：ID，姓名，成绩。C可以等于1,2,3，分别对应到按三列中的哪一列排序。
输出排序结果。</p>

<h5>分析</h5>

<p>简单排序题。两种思路：</p>

<ul>
<li>1.简单的直接使用qsort()实现。</li>
<li>2.自己手写排序算法，比如二叉搜索树实现。</li>
</ul>


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1029">1029. Median (25)</a></h2>

<h5>题意</h5>

<p>给定两个已排序的整数序列，求出两组数的集合里中间大小的数。</p>

<h5>分析</h5>

<p>使用归并排序思路实现。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1030">1030. Travel Plan (30)</a></h2>

<h5>题意</h5>

<p>给定加权图，每条边有两种权值：一是路径长度，二是开销。要求求出给点两点间的最短路径，如果路径长度一样，则要求比较选择开销最小的路径。</p>

<h5>分析</h5>

<p>使用Dijkstra算法的变形，增加一个权重的判定，可以轻松解决。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PAT 1011-1020 题解]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/07/31/pat-1011-1020-solutions/"/>
    <updated>2013-07-31T23:41:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/07/31/pat-1011-1020-solutions</id>
    <content type="html"><![CDATA[<p>早期部分代码用Java实现。由于PAT虽然支持各种语言，但只有C/C++标程来限定时间，许多题目用Java读入数据就已经超时，后来转投C/C++。浏览全部代码：<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/tree/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel">请戳</a></p>

<p>本文谨代表个人思路，欢迎讨论;)</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1011">1011. World Cup Betting (20)</a></h2>

<h5>题意</h5>

<p>给定一个3*3的矩阵，找到每行的最大值，格式化输出一个运算结果。</p>

<h5>分析</h5>

<p>非常简单的模拟题。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1012">1012. The Best Rank (25)</a></h2>

<h5>题意</h5>

<p>给定学生的学号和三个科目的分数，查询输出对应学生单门科目排名和总分排名中最高的那个排名。</p>

<h5>分析</h5>

<p>C里stdlib.h中的qsort()和C++里algorithm中的sort()函数都能实现快排，应对编程题中的排序一般比自己手写的要快。
分别为三个单科和总分做排序，并将rank值记录到map结构中去，便于之后的查找。</p>

<p>需要注意并列排名的情况。比如<code>1 2 2 4</code>，由于并列第2的都两人，那之后的那个人就是第4而不是第3了。</p>

<p>另外，由于有多个需要分别排序、排名的项，抽象出公共逻辑到一个函数里比较必要，否则代码分散难于debug和维护。
这里稍微特殊点的用法是使用了<a href="http://blog.csdn.net/dyx1024/article/details/7562786">函数指针</a>做参数。</p>

<!--more-->


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1013">1013. Battle Over Cities (25)</a></h2>

<h5>题意</h5>

<p>给定一张图和指定几个点。针对给出的每个点，要求计算在图中除掉连接该点的路径的情况下，保证整个图连通需要添加几条边。</p>

<h5>分析</h5>

<p>计算保证整个图连通需要几个点，亦即求出图中有几个连通分量。两种思路：</p>

<ul>
<li>1.并查集</li>
<li>2.DFS</li>
</ul>


<p>针对每个点，执行算法的过程中，需要注意去除掉改点对应的所有通路。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1014">1014. Waiting in Line (30)</a></h2>

<h5>题意</h5>

<p>这道题是排队模拟题。银行有N个窗口，每个窗口允许排队M个人，如果N个窗口占满了排队的人，更多的人需要在黄线外等待。
每个人都会选择尽可能人少的窗口排队，如果有多个窗口等待队列一样长，则选择编号小的窗口。
前N个用户设定在8:00开始接受服务。给定了K个用户所需要接受服务的时间长度，要求在这个排队模型下，每个人的完成处理的时间点。</p>

<h5>分析</h5>

<p>相对另外几个队列模拟题，这个题是很简单的。没有达到时间的差异，只需要不断的从等待队列中取出人员即可。
当然，由于黄线内等待的每个窗口都有M人，所以必须单独的模拟每个窗口。
可以使用queue模拟每个窗口，循环遍历下次离开窗口的人，继而从等待队列中补上。
需要注意结束条件，如果17:00以后还没有开始接受服务，则不用再等待。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1015">1015. Reversible Primes (20)</a></h2>

<h5>题意</h5>

<p>Reversible Primes是指在某个进制下，一个数本身和它翻转过来形成的新数都是素数。
题中给出多组数据，以负数结尾程序。每组数据包含一个数以及一个进制数。判定该数是否是Reversible Primes.</p>

<h5>分析</h5>

<p>两个功能点实现：判定素数和特定进制下的数据倒转。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1016">1016. Phone Bills (25)</a></h2>

<h5>题意</h5>

<p>给出一天中每个不同的小时内的电话付费标准，给出一份分为打出和挂断两种记录的通话记录，包括记录发生的时刻和用户名字，
要求整理出当月有效用户的账单，输出格式中需要输出所有的通话记录，包括开始时刻和结束时刻，每次通话的话费以及总计的话费。</p>

<h5>分析</h5>

<p>模拟题。首先对输入的通话记录按照先姓名后时间做qsort()排序，然后遍历排序后的记录，找到合适的匹配对，计算每次通话的时间，并进行统计和输出。</p>

<p>实现的难点主要有两个：</p>

<ul>
<li>1.在排序后的记录中，找到合适的配对。如果某人的通话记录为<code>1.on;2.on;3.off;</code>，则其中<code>1.on</code>将被抛弃，匹配到<code>2.on;3.off;</code>。
题中仅仅保证了所有记录中至少有一对有效记录，但并没有保证每个人都有有效通话记录，所以还需要做好过滤，
如果某人没有有效通话记录，则不输出。整体的控制流程需要谨慎。</li>
<li>2.由于不同时刻的话费不一样，计算一次有效通话的话费比较复杂。可以采用的方式是用起始时刻分阶段追赶结束时刻。追赶的过程分阶段，也就能计算好不同阶段的开销，
先将起始时间调整到跟结束时间为同一天，细节是先让分钟达到0，再让小时迭代到0，天进位，一直迭代到跟结束时间同天；再让起始时刻的小时数追平
结束时刻；最后让分钟追平。以此计算出最终话费。</li>
</ul>


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1017">1017. Queueing at Bank (25)</a></h2>

<h5>题意</h5>

<p>银行有K个窗口，所有到达银行的人都应该在黄线外等待，直到有窗口空余。
每个窗口对单个客人最多服务时间为1小时。N个用户的到达时间和需要处理的时间给出。
8:00到17:00接受服务，逾期不服务，也不计入统计数据。要求格式化输出用户的平均等待时间。</p>

<h5>分析</h5>

<p>又一道排队模拟题。相比PAT1014，此题更复杂在于用户的到达时间是不确定的。
首先使用qsort()按照到达时间对所有人排序。由于每个窗口同时只有一个人在处理，所以窗口之间没有差异，可以用priority_queue建立一个队列，
模拟所有K个窗口。
优先队列将结束时间最早的人放到队列的顶端，每次循环处理一个人的结束。然后步入一个黄线外等待的人。如果那个时刻，下一个人还没有达到，则可以将该人开始执行的时间记录为他的到达时间，并加入队列中。
还有一点需要注意的：HH:MM:SS的时间格式，可以转换为累积秒数的时间，方便计算比较。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1018">1018. Public Bike Management (30)</a></h2>

<h5>题意</h5>

<p>以杭州的公用自行车站点管理为背景。每个站点是一个节点，每个节点上最多停放Cmax辆自行车，Cmax/2为节点的最佳状态。不同节点间距离不同，整个构成了一张带权无向图。要求从起始点（公用自行车管理中心）出发，去目的地维护目的地节点的车辆状态，如果车辆低于Cmax/2，则给它添加车辆到Cmax/2辆，如果多于Cmax/2，则去除掉几辆车。同时，在去往目的地的过程中，也需要调整所有沿途站点的车辆（这里题目没有交代清楚，实际测试是只能在去往目的地的途中调整，回来的途上不可调整）。求到给定目的地的最短路径，如果有多条最短路径，则按照1.从管理中心送出的车辆越少越好；2.拿回到管理中心的车越少越好的优先级找到结果。</p>

<h5>分析</h5>

<p>题目的大体框架是有权最短路径问题。步骤如下：</p>

<ul>
<li>1.使用Dijkstra找到最短路径，其中注意记录每个节点在最短路径中的【所有】前驱节点；</li>
<li>2.使用DFS的方法，得到所有的最短路径。</li>
<li>3.计算每条最短路径的带出和带回的车辆数量。</li>
</ul>


<p>其中DFS时，归纳所有答案的过程比较通用，需要掌握。</p>

<p>另外值得注意的是，类比到PAT1003，该题采用了直接对每个节点增加状态记录的方式，直接得到最优解，而不是先找到最短路径，然后计算比较。本题是无法用这种方法实现的，需要送出和带回的自行车数量无法直接在Dij算法中每个节点的计算中体现，并不是前面的节点带回和送出的车辆越少，后面的节点就一定能得到更优解。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1019">1019. General Palindromic Number (20)</a></h2>

<h5>题意</h5>

<p>给定一个十进制数和一个进制，要求计算出在给定进制下的表达并判定是否为回文。</p>

<h5>分析</h5>

<p>简单的数字处理。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1020">1020. Tree Traversals (25)</a></h2>

<h5>题意</h5>

<p>根据二叉树的后序遍历和中序遍历，求层序遍历。</p>

<h5>分析</h5>

<p>具体实现方式：</p>

<ul>
<li>初始：用后序遍历序列确定根节点，在中序遍历序列中找到该根节点，则左右子树分别为中序中该节点左右的序列。</li>
<li>迭代：对各个子树分别执行三步操作，1.在后序序列中找子树的根节点；2。在中序序列中找子树的根节点，并划分开根节点的左右子树；3.根据新生成的左右子树，在后序序列中划分开这些节点，从而得到了两颗子树的后序、中序序列。</li>
</ul>


<p>有一个结论：中序遍历配合另外任何一个遍历，能重建二叉树。其他的任意两个序列的组合都不能唯一的确定重建的二叉树。具体分析参见博文<a href="../../../../2013/04/27/pat1020-pat1043-rebuild-binary-tree/">《根据前中后序和层序重建二叉树(PAT1020、PAT1043)》</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PAT 1001-1010 题解]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/07/31/pat-1001-1010-solutions/"/>
    <updated>2013-07-31T02:03:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/07/31/pat-1001-1010-solutions</id>
    <content type="html"><![CDATA[<p>早期部分代码用Java实现。由于PAT虽然支持各种语言，但只有C/C++标程来限定时间，许多题目用Java读入数据就已经超时，后来转投C/C++。浏览全部代码：<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/tree/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel">请戳</a></p>

<p>本文谨代表个人思路，欢迎讨论;)</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1001">1001. A+B Format (20)</a></h2>

<h5>题意</h5>

<p>格式化输出两数之和。</p>

<h5>分析</h5>

<p>理清输出逻辑即可。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1002">1002. A+B for Polynomials (25)</a></h2>

<h5>题意</h5>

<p>给定两多项式，相加并格式化输出结果。</p>

<h5>分析</h5>

<p>两种思路</p>

<ul>
<li>1.采用链表的处理方式；</li>
<li>2.预设好int[1005]的数组，用下标表示次方，数组中元素值表示对应系数。</li>
</ul>


<p>第一种方法某种程度上看能节省空间，实现上需要注意操作链表时，循环时的越界问题；
方法二用空间换取时间，且实现上更不容易出错。同时，由于浮点数本身精确位数不够，在判定两浮点数相加是否为0时，
需要对结果值取绝对值后，与1e-6做对比。</p>

<!--more-->


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1003">1003. Emergency (25)</a></h2>

<h5>题意</h5>

<p>求两个城市之间的加权最短路径。在有多个最短路径记录的情况下，选择路径中所有节点的权重值之和最小的。</p>

<h5>分析</h5>

<p>Dijkstra算法的变型实现。两种思路：</p>

<ul>
<li>1.计算最短路时，在每个节点上用链表preList记下所有最短路径的前节点。
完成计算后，对preList做dfs获得每条最短路径的权重值之和，比较后得到结果；</li>
<li>2.计算最短路径时，在节点上，除了记录最短路径中前一个节点preNode之外，还对应的记录当前的最短路径上所有节点的权重值之和，
这就不用在Dij完成之后再做dfs了，过程中已经找到了最优解。</li>
</ul>


<p>相比之下，方法2明显更简洁。当然，虽然方法2的思路很通用，还需要确定，这一加权的判定条件是能够迭代处理的。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1004">1004. Counting Leaves (30)</a></h2>

<h5>题意</h5>

<p>计算给定的树各个层级叶子节点的个数</p>

<h5>分析</h5>

<p>先构建树，鉴于题目的空间限制不严格，可以使用邻接矩阵的方式定义树结构。然后使用dfs遍历树的节点，并记录每层的叶子节点数量。
可以看到，时间空间的trade-off不仅仅是性能上的提升，也会影响带代码实现的复杂程度。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1005">1005. Spell It Right (20)</a></h2>

<h5>题意</h5>

<p>计算一个数（&lt;=10<sup>100）的各个位数之和，并用英语按位输出。比如15输出为one</sup> five.</p>

<h5>分析</h5>

<p>简单题，输出的实现上实际上就用到了Hash思想。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1006">1006. Sign In and Sign Out (25)</a></h2>

<h5>题意</h5>

<p>每个人来到实验室和离开实验室的时间都有记录。找到其中最早来实验室和最晚离开实验室的时间。</p>

<h5>分析</h5>

<p>逻辑上很简单的一个题，遍历所有数据，找到其中最大和最小的值即可。稍微要处理的就是时间。
由于input中给出的是HH:MM:SS的格式，在比较时需要将其换算为int值。实际上，使用C语言读入更方便，<code>scanf("%d:%d:%d", &amp;h, &amp;m, &amp;s);</code>
然后计算出<code>time = 3600*h + 60*m + s</code>，时间比较就没有问题了。在最终的输出时再做对应的转换即可。
而在Java语言中，使用到了String的split方法划分子串和Integer.parseInt()转String为int。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1007">1007. Maximum Subsequence Sum (25)</a></h2>

<h5>题意</h5>

<p>给出一组由正负整数组成的序列，求出拥有最大和的连续子序列。</p>

<h5>分析</h5>

<p>最暴力的算法是两个循环的O(n<sup>2)；进一步要使用分治的思想，可以得到O(n*logn)；更好的方法可以达到O(n)，也可以将它看做分治思想。关键在于数学归纳的证明，编程实现非常简单：假定[0,</sup> n-1]的最大连续子串已经求出了，要求[0,n]的最大连续子串。</p>

<ul>
<li>1.如果[0, n-1]中最大子串不包含最右的数字，则判定<code>原最大子串的和</code>与<code>包含最右点的最大子串 + a[n]的和</code>的大小。取大的那个作为[0, n]的最大子串，并保持一个<code>包含最右点的最大子串</code>。</li>
<li>2.如果[0, n-1]中最大子串包含最右的数字，则[0, n]的最大子串为原最大子串+a[n]。</li>
</ul>


<p>实际上，算法的核心是维持了两个量的记录，即当前的<code>最大子串</code>，以及当前<code>包含最右点的最大子串</code>。</p>

<p>更多讨论参见博文<a href="../../../../2013/04/05/maximum-subsequence-sum/">《分治、时间空间的权衡:最大合的连续字串问题 (PAT 1007)
》</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1008">1008. Elevator (20)</a></h2>

<h5>题意</h5>

<p>给出电梯的行进路径，上下的速度和每层停留时间，计算总时间。</p>

<h5>分析</h5>

<p>简单的模拟题。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1009">1009. Product of Polynomials (25)</a></h2>

<h5>题意</h5>

<p>求两个多项式的乘积。</p>

<h5>分析</h5>

<p>参见PAT1002，使用数组存储虽然空间占用稍大，但比链表实现要便捷很多。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1010">1010. Radix (25)</a></h2>

<h5>题意</h5>

<p>给定两个数，其中单个位置上的数值范围可以为[0-z]。指定其中一个数的进制，试确定是否存在可能的进制让两数的实际值相等。</p>

<h5>分析</h5>

<p>此题没有交代清楚input中radix的取值范围以及对一位数有多重可能radix的情况如何输出，坑比较大。下面是需要注意的点。</p>

<ul>
<li>1.input中两个数字可以是10位数，虽然没有告诉radix的范围，但在<code>9*10^10 10 1 200</code>这个示例中，可以看到结果的radix也可以是很大的。从这个角度看，代码中将radix和两个数值都设定为longlong是合适的选择。</li>
<li>2.在计算另一个数的radix时，简单的遍历[2, 10<sup>18]会超时。单调的区间很自然想到使用二分查找。</sup></li>
<li>3.二分查找的上下界确定能减少耗时：下界选数字的所有位上的最大值+1；上界容易想当然的认为就是题中给定了radix的数的值。实际上，示例<code>11 b 1 10</code>就是一个反例，原因在于这个假设忽略了一位数的可能性，解决方案是在取给定radix的数值和下界中较大的那个数。</li>
<li>4.在二分查找时，不可直接计算出某个radix下数的值，因为可能会longlong溢出。于是需要用特定的compare函数，在累加的过程中判定是否大于另一个数。算是一种剪枝。</li>
<li>5.还有一个条件：当两个数都是1时，输出2.当两个数相等且不为1时，输出题中给出的radix。（这是从其他人的结题报告中看到的，完全不理解=。=）</li>
</ul>


<p>注意好这些方面，应该能ac了。保重。</p>
]]></content>
  </entry>
  
</feed>
