<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: algorithm | Biaobiaoqi的博客]]></title>
  <link href="http://biaobiaoqi.github.com/tags/algorithm/atom.xml" rel="self"/>
  <link href="http://biaobiaoqi.github.com/"/>
  <updated>2013-07-31T03:32:30+08:00</updated>
  <id>http://biaobiaoqi.github.com/</id>
  <author>
    <name><![CDATA[Biaobiaoqi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PAT 1001-1010 题解]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/07/31/pat-1001-1010-solutions/"/>
    <updated>2013-07-31T02:03:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/07/31/pat-1001-1010-solutions</id>
    <content type="html"><![CDATA[<p>全部代码实现：<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/tree/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel">请戳</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1001">PAT1001</a></h2>

<p>题意：格式化输出两数之和。</p>

<p>分析：理清输出逻辑即可。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1002">PAT1002</a></h2>

<p>题意：给定两多项式，相加并格式化输出结果。</p>

<p>分析：两种思路</p>

<ul>
<li>1.采用链表的处理方式；</li>
<li>2.预设好int[1005]的数组，用下标表示次方，数组中元素值表示对应系数。</li>
</ul>


<p>第一种方法某种程度上看能节省空间，实现上需要注意操作链表时，循环时的越界问题；
方法二用空间换取时间，且实现上更不容易出错。同时，由于浮点数本身精确位数不够，在判定两浮点数相加是否为0时，
需要对结果值取绝对值后，与1e-6做对比。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1003">PAT1003</a></h2>

<p>题意：求两个城市之间的加权最短路径。在有多个最短路径记录的情况下，选择路径中所有节点的权重值之和最小的。</p>

<p>分析：Dijkstra算法的变型实现。两种思路：</p>

<ul>
<li>1.计算最短路时，在每个节点上用链表preList记下所有最短路径的前节点。
完成计算后，对preList做dfs获得每条最短路径的权重值之和，比较后得到结果；</li>
<li>2.计算最短路径时，在节点上，除了记录最短路径中前一个节点preNode之外，还对应的记录当前的最短路径上所有节点的权重值之和，
这就不用在Dij完成之后再做dfs了，过程中已经找到了最优解。</li>
</ul>


<p>相比之下，方法2明显更简洁。当然，虽然方法2的思路很通用，还需要确定，这一加权的判定条件是能够迭代处理的。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1004">PAT1004</a></h2>

<p>题意：计算给定的树各个层级叶子节点的个数</p>

<p>分析：先构建树，鉴于题目的空间限制不严格，可以使用邻接矩阵的方式定义树结构。然后使用dfs遍历树的节点，并记录每层的叶子节点数量。
可以看到，时间空间的trade-off不仅仅是性能上的提升，也会影响带代码实现的复杂程度。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1005">PAT1005</a></h2>

<p>题意：计算一个数（&lt;=10<sup>100）的各个位数之和，并用英语按位输出。比如15输出为one</sup> five.</p>

<p>分析：简单题，输出的实现上实际上就用到了Hash思想。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1006">PAT1006</a></h2>

<p>题意：每个人来到实验室和离开实验室的时间都有记录。找到其中最早来实验室和最晚离开实验室的时间。</p>

<p>分析：逻辑上很简单的一个题，遍历所有数据，找到其中最大和最小的值即可。稍微要处理的就是时间。
由于input中给出的是HH:MM:SS的格式，在比较时需要将其换算为int值。实际上，使用C语言读入更方便，<code>scanf("%d:%d:%d", &amp;h, &amp;m, &amp;s);</code>
然后计算出<code>time = 3600*h + 60*m + s</code>，时间比较就没有问题了。在最终的输出时再做对应的转换即可。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1007">PAT1007</a></h2>

<p>题意：给出一组由正负整数组成的序列，求出拥有最大和的连续子序列。</p>

<p>分析：最暴力的算法是两个循环的O(n<sup>2)；进一步要使用分治的思想，可以得到O(n*logn)；更好的方法可以达到O(n)，也可以将它看做分治思想。关键在于数学归纳的证明，编程实现非常简单：假定[0,</sup> n-1]的最大连续子串已经求出了，要求[0,n]的最大连续子串。</p>

<ul>
<li>1.如果[0, n-1]中最大子串不包含最右的数字，则判定<code>原最大子串的和</code>与<code>包含最右点的最大子串 + a[n]的和</code>的大小。取大的那个作为[0, n]的最大子串，并保持一个<code>包含最右点的最大子串</code>。</li>
<li>2.如果[0, n-1]中最大子串包含最右的数字，则[0, n]的最大子串为原最大子串+a[n]。</li>
</ul>


<p>实际上，算法的核心是维持了两个量的记录，即当前的<code>最大子串</code>，以及当前<code>包含最右点的最大子串</code>。</p>

<!--more-->


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1008">PAT1008</a></h2>

<p>题意：给出电梯的行进路径，上下的速度和每层停留时间，计算总时间。</p>

<p>分析：简单的模拟题。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1009">PAT1009</a></h2>

<p>题意：求两个多项式的乘积。</p>

<p>分析：参见PAT1002，使用数组存储虽然空间占用稍大，但比链表实现要便捷很多。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1010">PAT1010</a></h2>

<p>题意：给定两个数，其中单个位置上的数值范围可以为[0-z]。指定其中一个数的进制，试确定是否存在可能的进制让两数的实际值相等。</p>

<p>分析：此题没有交代清楚input中radix的取值范围以及对一位数有多重可能radix的情况如何输出，坑比较大。下面是需要注意的点。</p>

<ul>
<li>1.input中两个数字可以是10位数，虽然没有告诉radix的范围，但在<code>9*10^10 10 1 200</code>这个示例中，可以看到结果的radix也可以是很大的。从这个角度看，代码中将radix和两个数值都设定为longlong是合适的选择。</li>
<li>2.在计算另一个数的radix时，简单的遍历[2, 10<sup>18]会超时。单调的区间很自然想到使用二分查找。</sup></li>
<li>3.二分查找的上下界确定能减少耗时：下界选数字的所有位上的最大值+1；上界容易想当然的认为就是题中给定了radix的数的值。实际上，示例<code>11 b 1 10</code>就是一个反例，原因在于这个假设忽略了一位数的可能性，解决方案是在取给定radix的数值和下界中较大的那个数。</li>
<li>4.在二分查找时，不可直接计算出某个radix下数的值，因为可能会longlong溢出。于是需要用特定的compare函数，在累加的过程中判定是否大于另一个数。算是一种剪枝。</li>
<li>5.还有一个条件：当两个数都是1时，输出2.当两个数相等且不为1时，输出题中给出的radix。（这是从其他人的结题报告中看到的，完全不理解=。=）</li>
</ul>


<p>注意好这些方面，应该能ac了。保重。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[出栈序列的可能性判定（PAT1051）]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/07/16/verify-pop-sequence-for-stack/"/>
    <updated>2013-07-16T01:32:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/07/16/verify-pop-sequence-for-stack</id>
    <content type="html"><![CDATA[<h2>问题说明</h2>

<p><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1051">PAT1051</a>：给定stack的容量，给定数据的入栈顺序：从1开始的正整数序列，在允许随机的出栈操作的情况下，要求判断某出栈序列是否可能。</p>

<p>比如，告知stack容量为5，入栈序列的最大值为7。有两个序列需要判断合理性：</p>

<ul>
<li><code>1 2 3 4 5 6 7</code>： 这个序列是可能的，只需每次入栈时都做出栈操作。</li>
<li><code>3 2 1 7 5 6 4</code>： 这个序列是不可能的，其中前半部分<code>3 2 1</code>是合法的，先将<code>1 2 3</code>顺序入栈，然后三次执行出栈操作。而之后的<code>7 5 6</code>则是不可能的。</li>
</ul>


<p>要完成判定过程，常规思路是直接使用的stack数据结构模拟出栈序列做操作，然后判定是否会触犯条件。但考虑到PAT1051中时间限制只有10ms，虽然常规方法是线性的，似乎也无法保障（事实证明是错误的，用常规方法也能在PAT上AC），我想到从序列本身的特性入手，找规律，于是有了一种效率更高的判定逻辑。</p>

<h2>常规思路</h2>

<p>直接使用出栈序列指导stack模拟操作。判定条件有两条：</p>

<ul>
<li>1.栈中数据量不超过栈的容量。</li>
<li>2.出栈只能从栈顶取，不应该出现从固定的堆栈中取出其他数据的情况。</li>
</ul>


<p>算法描述如下：</p>

<p>用游标记录当前已知压栈的最大数据cur。如果新的读入数据tmp（即出栈序列中的某数据）大于cur，则将cur到tmp之间的数据顺序压入栈中，更新cur并执行检查1；如果新的读入数据tmp小于cur，则一定是直接出栈获得的，执行检查2。</p>

<p>如果能顺利完成就是合理的，如果操作过程违背了一些规则，则判定为不合理。C++实现代码如下：</p>

<p>``` cpp</p>

<h1>include&lt;stdio.h></h1>

<h1>include<stack></h1>

<p>using namespace::std;
int m, n, k, tmp, cur;
bool flag;
stack<int> s;
int main()
{</p>

<pre><code>scanf("%d %d %d", &amp;m, &amp;n, &amp;k);
while(k --) {
    flag = true;
    cur = 1;
    s.push(1);
    for (int i = 0; i != n; ++ i) {
        scanf("%d", &amp;tmp);
        if (tmp &gt; cur) {
            for (int j = cur + 1; j &lt;= tmp; ++ j)
                s.push(j);
            if (s.size() &gt; m) flag = false;
            cur = tmp;
        }else {
            if (s.top() != tmp)
                flag = false;
        }
        s.pop();
    }

    if (flag) printf("YES\n");
    else printf("NO\n");
}
</code></pre>

<p>}</p>

<p>```</p>

<h2>更高效的判定逻辑</h2>

<p>实际上，在PAT1051的环境下，由于入栈序列数据由小到大排列非常特殊，要通过出栈序列判定可能性是存在简便思路的。</p>

<p>对比分析题中Sample给出的序列，结合上面提到的两条冲突条件入手分析：</p>

<ul>
<li><p>1.栈中数据量不超过栈的容量：</p>

<p>  只有在入栈时，才会需要考虑栈中数据是否超量。出栈序列中的每个数，都以为着在出栈操作之前，它刚入栈，那么当它入栈的时候能否判定是否超过栈容量呢？可以的，（当前的出栈数值 - 已经执行过的出栈操作数量）就是当前栈中元素的数量。</p></li>
</ul>


<!--more-->


<ul>
<li><p>2.出栈只能从栈顶取，不应该出现从固定的堆栈中取出其他数据的情况。</p>

<p>  根据观察分析发现，当某数据m出栈之后，比m小的数据如果在m之后出栈的，它们所组成的序列本身需要保持从大到小的顺序排列。距离如<code>3 2 1 7 5 6 4</code>这个序列，在<code>7</code>之后有<code>5 6 4</code>这个子序列，它们都大于<code>7</code>，但却没有保持一个递减的顺序，不合法。</p></li>
</ul>


<p>C++实现代码如下：</p>

<p>``` cpp</p>

<h1>include&lt;stdio.h></h1>

<p>int m, n, k;
int max, min, tmp;
bool flag;
int main()
{</p>

<pre><code>scanf("%d %d %d", &amp;m, &amp;n, &amp;k);
while(k --) {
    flag = true;
    max = 0;
    min = 1001;

    for (int i = 0; i != n; ++ i) {
        scanf("%d", &amp;tmp);
        if (tmp &gt; max) {
            if (tmp - i &gt; m) flag = false;
            else max = min= tmp;
        } else {
            if ( tmp &gt; min) flag = false;
            else min = tmp;
        }
    }

    if (flag) printf("YES\n");
    else printf("NO\n");
}
</code></pre>

<p>}
```</p>

<h2>总结</h2>

<p>在我的理解之中，经典的算法、数据结构是在面对编程问题的解决过程中所抽象出的通用模型。而生活是多变的，并不像考试卷一样简单的套用数学题所能解决，很多情况下，编程问题也是如此。那么除了这些经典的方法外，认真分析条件，并进行针对性的优化甚至重新设计就非常重要了。这里仅仅是一个小实践。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[KMP算法实现]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/05/25/kmp-algorithm/"/>
    <updated>2013-05-25T21:22:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/05/25/kmp-algorithm</id>
    <content type="html"><![CDATA[<p>本文描述了单模式的字符串匹配的经典算法KMP算法的实现。首先对字符串匹配算法做简单的介绍，然后是KMP算法的实现描述，最后推荐两道简单的ACM模板题做练手用。</p>

<h2>字符串匹配算法</h2>

<p>字符串匹配(String Matchiing)也称字符串搜索(String Searching)是字符串算法中重要的一种，是指从一个大字符串或文本中找到模式串出现的位置。一个基本的字符串匹配算法分类如下：</p>

<ul>
<li>单模式匹配：即每次算法执行只需匹配出一个模式串。</li>
<li>有限集合的多模式匹配：即算法需要同时找出多个模式串的匹配结果，而这个模式串集合是有限的。</li>
<li>无限集合的多模式匹配：如正则表达式的匹配。</li>
</ul>


<p>单模式匹配最容易理解，构造也非常简单。一个最朴素的思路就是从文本的第一个字符顺次比较模式串，不匹配则重新从下一个字符开始匹配，直到文本末尾。Java实现代码如下：</p>

<p>``` java</p>

<pre><code>public static boolean bruteforce(String str1, String str2) {
     for (int i = 0, j = 0; i!= str1.length(); ) {
           if (str1.charAt(i) == str2.charAt(j)) {
                j ++;
                i ++;
                if (j == str2.length()) return true;
           }else {         
                i = i - j + 1;
                j = 0;                        
           }
      }
      return false;
 }
</code></pre>

<p>```</p>

<p>但是这种算法，有明显的效率黑洞。因为每次匹配失败后，都会回到原来的匹配起点的下一个字符开始匹配，这些步骤很多情况下，并不是必要的。</p>

<p>实际上这些字符很有可能已经被读入了一次。理论上，如果我们能对所有被读入过的字符有足够的了解，那就能判定是否能避免再次读入一遍做匹配运算了。经典的KMP算法正是基于这点思考，对原有的蛮力算法做出了优化。</p>

<h2>KMP算法</h2>

<p>网络上关于KMP算法的描述很多，其中个人觉得阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">《字符串匹配的KMP算法》</a>对KMP的描述最为简明和清晰。图例展示的算法流程更容易让人接受和理解。这里仅记录我所认为重点的知识点。</p>

<h5>算法的思想</h5>

<p>相比蛮力算法，KMP算法预先计算出了一个哈希表，用来指导在匹配过程中匹配失败后尝试下次匹配的起始位置，以此避免重复的读入和匹配过程。这个哈希表被叫做“部分匹配值表(<strong>Particial match table</strong>)”，它的设计是算法精妙之处。</p>

<h5>部分匹配值表</h5>

<p>要理解部分匹配值表，就得先了解字符串的前缀(prefix)和后缀(postfix)。</p>

<ul>
<li>前缀:除字符串最后一个字符以外的所有头部串的组合。</li>
<li>后缀：除字符串第一个字符以外的所有尾部串的组合。</li>
<li>部分匹配值：一个字符串的前缀和后缀中最长共有元素的长度。</li>
</ul>


<p>举例说明：字符串<code>ABCAB</code></p>

<ul>
<li>前缀：{A， AB， ABC， ABCA}</li>
<li>后缀：{BCAB， CAB， AB， B}</li>
<li>部分匹配值：2 （AB）</li>
</ul>


<p>而所谓的部分匹配值表，则为模式串的所有前缀以及其本身的部分匹配值。</p>

<p>举例如下：还是针对字符串<code>ABCAB</code>，它的部分匹配值表为：</p>

<p><code>
A B C A B
0 0 0 1 2
</code></p>

<p>这代表着：字符串<code>A B C A B</code> 中，子串<code>A B C</code>的部分匹配值为0，而子串<code>A B C A</code>的部分匹配值为1，诸如此理。</p>

<h5>算法实现</h5>

<p>``` java</p>

<pre><code>public static int[] next;

public static boolean kmp(String str, String dest) {
    // i stands for index of str string, j stands for index in dest string.
    // At the beginning of each loop process, j is the new position of dest
    // taht should be compared.
    for (int i = 0, j = 0; i &lt; str.length(); i++) {
        while (j &gt; 0 &amp;&amp; str.charAt(i) != dest.charAt(j))
            // This loop is to get a matching character recursively. Another
            // stop condition is when particial match value meets end.
            j = next[j - 1];// As i in str and j in dest is comparing,
                            // recomputing of j should be in the former
                            // character substring, which is next[j-1]

        if (str.charAt(i) == dest.charAt(j))
            j++;

        if (j == dest.length())
            return true;
    }

    return false;
}

public static int[] kmpNext(String str) {
    int[] next = new int[str.length()];
    next[0] = 0;
    // i stands for index of string, j is temporary for particail match
    // values computing, at the beginning of each loop process, j is the
    // particial match value of former character .
    for (int i = 1, j = 0; i &lt; str.length(); ++i) {
        while (j &gt; 0 &amp;&amp; str.charAt(i) != str.charAt(j))
            // This loop is to get a matching character recursively. Another
            // stop condition is when particial match value meets end.
            j = next[j - 1];// j will be recomputed in the recursion. Take
                            // care that next[j-1] is the particial match
                            // value of the first j characters substirng.

        if (str.charAt(i) == str.charAt(j)) // If not in this case, j must
                                            // meets end, equals to zero.
            ++j;

        next[i] = j;
    }
    return next;
}
</code></pre>

<p>```</p>

<p>理解算法实现时，有几点特别需要注意：</p>

<ul>
<li>在生成部分匹配值数组的kmpNext()方法中，第一层循环内，<code>i</code>是字符串的索引，而<code>j</code>则在每次循环开始时代表了<code>i</code>所指定字符之前的子串的部分匹配值。</li>
<li>kmpNext()方法的内层while()循环，是为了迭代得到让<code>i</code>指定字符匹配到的情况。有另外一种实现方案：不有用这一层循环，而是直接使用一层循环，在大循环内部做j值变更的判定即可。</li>
<li>kmpNext()方法的while()循环中，需要特别注意是<code>next[j -1]</code>，部分匹配值j对应到的是字符串中的第<code>j-1</code>个字符。</li>
<li>kmp()的循环代码和kmpNext()部分匹配值表生成的循环代码很类似。两者使用了相同方式，在字符匹配失败后迭代获取新的可匹配情况，且都是利用了next数组。</li>
</ul>


<h2>其他</h2>

<p>KMP算法虽然能达到O(M+N)的算法复杂度，但在实际使用中，KMP算法的性能并不如<a href="http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html">BM</a>算法强。</p>

<h2>模板题</h2>

<h4>基础模板题</h4>

<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2203">HDOJ的2203题</a>是一个能检验算法正确性的模板题。Java实现的答案代码<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/practice/hdoj/HDOJ2203.java">请戳这里</a>。</p>

<h4>延伸模板题</h4>

<p><a href="http://poj.org/problem?id=2406">POJ的2406题</a>，对考察点做了巧妙的变形，对更深入的理解KMP中的部分匹配表（即next数组）很有帮助。Java实现的答案代码<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/practice/poj/POJ2406.java">请戳这里</a>。</p>

<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1867">HDOJ的1867题</a>也属于kmp的变形。要求对kmp利用next数组进行比较的过程有清晰的认识。Java实现的答案代码<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/practice/hdoj/HDOJ1867.java">请戳这里</a>。</p>

<h3>其他参考资料：</h3>

<ul>
<li><p><a href="http://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm">wiki:Knuth–Morris–Pratt Algorithm</a></p></li>
<li><p><a href="http://en.wikipedia.org/wiki/String_searching_algorithm">wiki:String Searching Algorithm</a></p></li>
<li><p><a href="http://www.cppblog.com/converse/archive/2006/07/05/9447.html">《KMP算法的实现》</a></p></li>
<li><p><a href="http://wangcong.org/blog/archives/2090">《Linux 内核中的 KMP 实现》</a></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[根据前中后序和层序重建二叉树(PAT1020、PAT1043)]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/04/27/pat1020-pat1043-rebuild-binary-tree/"/>
    <updated>2013-04-27T22:33:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/04/27/pat1020-pat1043-rebuild-binary-tree</id>
    <content type="html"><![CDATA[<h2>背景</h2>

<p><a href="/blog/2013/04/27/travsal-binary-tree/">《二叉树的遍历（递归、非递归）分析》</a>总结了二叉树不同遍历方式的递归和非递归实现，本文则讨论如何针对不同遍历方式的组合重建二叉树。为了简化问题的考虑，假定二叉树中不会出现重复值。列入考虑范围的有前序、中序、后序、层序遍历这四种的组合。前中后序比较常见，而层序则相对特殊一点了。</p>

<p><a href="http://pat.zju.edu.cn/contests/pat-a-practise">PAT</a>的1043和1020题是遍历相关的模板题，正好派上用场。</p>

<!--more-->


<h2>中序+前序</h2>

<h5>算法描述：</h5>

<ul>
<li><p>初始：用前序遍历序列确定根节点，在中序遍历序列中找到该根节点，则左右子树分别为中序中该节点左右的序列。</p></li>
<li><p>迭代：对各个子树分别执行三步操作，1.在前序序列中找子树的根节点；2。在中序序列中找子树的根节点，并划分开根节点的左右子树；3.根据新生成的左右子树，在前序序列中划分开这些节点，从而得到了两颗子树的前序、中序序列。</p></li>
</ul>


<h5>练习：<a href="http://pat.zju.edu.cn/contests/pat-a-practise/1043">PAT1043:Is It a Binary Search Tree</a></h5>

<h5>题意：</h5>

<p>输入一个树的前序遍历序列，判定这个树是否是二叉搜索树或者BST的镜像树，如果是，则用后序序列输出。</p>

<h5>解题思路：</h5>

<ul>
<li><p>1.BST很特殊，实质上BST的所有节点的顺序排列就是中序遍历了。</p></li>
<li><p>2.要检查树是否是BST或者镜像BST，只需按照重建树的思路，在每次重建的过程中做适当检查即可。检查思路是：检查前序遍历序列中，根节点之后的节点排序是否符合BST的二分规则（即前一段都是小于根节点的，后一段都是大于根节点的）。</p></li>
<li><p>3.最后的输出是后序遍历。过程中其实并不用构建整个树，直接在处理过程中，按后序的方式存储节点到队列中即可。</p></li>
</ul>


<p>有了这些考虑，就可以写出代码啦。详细解题代码见链接<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/pat/advancedlevel/APAT1043.java">PAT1043</a></p>

<h2>中序+后序</h2>

<h5>算法描述：</h5>

<ul>
<li><p>初始：用后序遍历序列确定根节点，在中序遍历序列中找到该根节点，则左右子树分别为中序中该节点左右的序列。</p></li>
<li><p>迭代：对各个子树分别执行三步操作，1.在后序序列中找子树的根节点；2。在中序序列中找子树的根节点，并划分开根节点的左右子树；3.根据新生成的左右子树，在后序序列中划分开这些节点，从而得到了两颗子树的后序、中序序列。</p></li>
</ul>


<h5>练习：<a href="http://pat.zju.edu.cn/contests/pat-a-practise/1020">PAT1020:Tree Traversals</a></h5>

<h5>题意：</h5>

<p>输入为一棵二叉树的后序遍历序列和中序遍历序列。求树的前序遍历序列。</p>

<h5>解题思路：</h5>

<ul>
<li><p>1.有了中序和后序，就能重建树。</p></li>
<li><p>2.最后的输出是前序遍历。过程中其实并不用构建整个树。直接在处理过程中，按前序的方式存储节点到队列中即可。</p></li>
</ul>


<p>详细解题代码见链接<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/pat/advancedlevel/APAT1020.java">PAT1020</a></p>

<h2>中序+层序</h2>

<h5>算法描述：</h5>

<ul>
<li><p>初始：用层序遍历确定顶节点，在中序遍历中，利用顶节点划分出左右子树。</p></li>
<li><p>迭代：对各个子树分别执行三步操作，1.在层序序列中，找出子树节点集合中，最靠前的节点，这个节点即为子树的顶节点；2.在中序序列中找1中得到的顶节点，并划分开顶节点的左右子树；</p></li>
<li><p>跟（中序+前序）和（中序+后序）不同之处在于没有迭代的第3步，层序是无法直接划分得到左右子树的节点集合的。但这并不妨碍正常的处理。层序是用来找到子树的顶节点的，而顶节点即是所有子树的节点中，在层序遍历中最靠前的节点。</p></li>
</ul>


<h2><del>前序+后序</del></h2>

<p>这个组合是<strong>无法</strong>重建确定的二叉树的。</p>

<p>对于满二叉树，利用子树节点的排列顺序能区分开左右子树节点集合，构建是没有问题的。但一旦有单个叶子的节点存在，则无法确定叶子是左儿子还是右儿子。因为无论是前序还是后序序列，都无法体现单个儿子情况下，儿子的位置。前序会将左右子树的点置于节点之后，后序则是将左右子树的点置于节点之前。</p>

<ul>
<li>举个简单的反例：</li>
</ul>


<blockquote><p>给出如下的前序序列和后序序列：
preorder: A, B;
postorder: B, A</p>

<p>能构建的二叉树有两种可能，1.A是根节点，B是A左儿子； 2.A是根节点， B是A的右儿子。无法得到一个唯一的结果。</p></blockquote>

<h2><del>前序+层序</del></h2>

<p>这个组合也是无法重建确定的二叉树的。同样于后序+层序的情况。</p>

<p>道理跟（前序+后序）的道理一样，无论是前序、后序，还是层序，都是无法确定单个儿子节点情况下儿子节点的顺序。</p>

<h2>总结</h2>

<ul>
<li>中序遍历配合另外任何一个遍历，能重建二叉树。其他的任意两个序列的组合都不能唯一的确定重建的二叉树。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[二叉树的遍历（递归、非递归）分析]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/04/27/travsal-binary-tree/"/>
    <updated>2013-04-27T21:03:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/04/27/travsal-binary-tree</id>
    <content type="html"><![CDATA[<h2>背景</h2>

<p>二叉树是一种很基本的数据结构。很多地方能看到它的身影，比如大名鼎鼎的霍夫曼编码（好了，别问我再比如了，见识浅薄，真不知道更多了。。。）它的结构很简洁、巧妙。</p>

<p>本文讨论二叉树的常见遍历方式的代码实现（这里贴出的是Java），包括前序(preorder)、中序(inorder)、后序(postorder)、层序(level order)，进一步，考虑递归和非递归的实现方式。递归方法的实现相对简单，但递归的执行方式由于每次都会产生一个新的方法调用栈，如果递归层级较深，会消耗较大的内存，转化为非递归则没那么简单了，往往需要实现一个栈来保存状态信息。</p>

<!--more-->


<p>在此之前，先简单定义节点的数据结构：</p>

<p>二叉树节点最多只有两个儿子，并保存一个节点的值，为了实验的方便，假定它为int。同时，我们直接使用Java的System.out.print方法来输出节点值，以显示遍历结果。</p>

<p>```
public class Node {</p>

<pre><code>    public int value;
    public Node leftNode;
    public Node rightNode;

    public Node(int i) {
        value = i;
    }
}
</code></pre>

<p>```
详细代码参见链接:<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/algorithm/tree/BinarySearchTree.java">BST及其各种便利的详细实现代码</a></p>

<h2>前序遍历</h2>

<ul>
<li>递归实现：递归实现很简单，在每次访问到某个节点时，先输出节点值，然后再依次递归的对左儿子、右儿子调用遍历的方法。代码如下</li>
</ul>


<p>```</p>

<pre><code>public void preOrderTrav(Node n) {
    if (n != null) {
        System.out.print(n.value + " ");
        preOrderTrav(n.leftNode);
        preOrderTrav(n.rightNode);
    }
}
</code></pre>

<p>```</p>

<ul>
<li>非递归调实现：</li>
</ul>


<p>1.第一种实现方式相对容易理解：</p>

<p>初始：维护一个栈，将根节点压入栈中。</p>

<p>循环：每次从栈顶读出一个节点信息，直接将节点值<strong>输出</strong>，同时将儿子节点按从左到右的顺序推到栈顶。</p>

<p>分析：跟递归调用的整体思路一样，不同的是，递归调用时是利用运行时系统所维护的程序调用栈来维护顺序，而这个非递归方法是用过自己维护的栈来保存信息。如此节省了调用栈的空间。</p>

<p>```</p>

<pre><code>public void preOrderTravNoRecur(Node n) {
    Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();
    stack.add(root);
    while (!stack.empty()) {
        Node t = stack.pop();
        System.out.print(t.value + " ");
        if (t.rightNode != null)
            stack.add(t.rightNode);
        if (t.leftNode != null)
            stack.add(t.leftNode);
    }
}
</code></pre>

<p>```</p>

<p>2.第二种实现方式更普遍（中序遍历的非递归使用了同样的思路）：</p>

<p>初始：维护一个栈S和一个节点变量N。节点变量赋值为根节点。</p>

<p>循环：将节点变量N的左儿子循环的<strong>输出</strong>，并推入栈S中，直到没有左儿子；推出栈S的顶节点，节点变量N赋值为栈S顶节点的右节点。</p>

<p>分析：不同于递归调用的思路。栈S用于实现对某节点的左边支递归值的存储，以便回溯；节点变量N则用于遍历某节点的右边枝（这些节点是从栈S顶读出的节点，依次做处理），由于右边枝是最后才会被访问到的，故在处理右边枝的时候，不需要存储右边枝的信息，依次处理即可。</p>

<p>```</p>

<pre><code>public void preOrderTravNoRecurII(Node n) {
    System.out.println("No Recursive: ");
    Stack&lt;Node&gt; s = new Stack&lt;Node&gt;();
    while (n != null | !s.empty()){
        while (n!=null ){
            System.out.print(n.value + " ");
            s.add(n);
            n = n.leftNode;
        }
        n = s.pop();
        n = n.rightNode;
    }
    System.out.println();
}
</code></pre>

<p>```</p>

<h3>中序遍历</h3>

<ul>
<li>递归实现</li>
</ul>


<p>```</p>

<pre><code>public void inorderTrav(Node n) {
    if (n != null) {
        inorderTrav(n.leftNode);
        System.out.print(n.value + " ");
        inorderTrav(n.rightNode);
    }
}
</code></pre>

<p>```</p>

<ul>
<li>非递归实现</li>
</ul>


<p>初始：维护一个栈S和一个节点变量N。节点变量赋值为根节点。</p>

<p>循环：将节点变量N的左儿子循环的<strong>输出</strong>，并推入栈S中，直到没有左儿子；节点变量N赋值为栈S顶节点的右节点。</p>

<p>分析：跟前序遍历的非递归实现方法二很类似。唯一的不同是输出的时机不同：前序遍历在入栈时输出，而中序遍历在出栈时输出。可以跟深刻的理解到，栈在这里是为了回溯而存在的。</p>

<p>```</p>

<pre><code>public void inorderTravNoRecu(Node n) {
    System.out.println("No Recursive: ");
    Stack&lt;Node&gt; s = new Stack&lt;Node&gt;();
    while (n != null | !s.empty()){
        while (n!=null ){
            s.add(n);
            n = n.leftNode;
        }
        n = s.pop();
        System.out.print(n.value + " ");
        n = n.rightNode;
    }
}
</code></pre>

<p>```</p>

<h3>后序遍历</h3>

<ul>
<li>递归实现</li>
</ul>


<p>```
public void preOrderTravNoRecurII(Node n) {</p>

<pre><code>    System.out.println("No Recursive: ");
    Stack&lt;Node&gt; s = new Stack&lt;Node&gt;();
    while (n != null | !s.empty()){
        while (n!=null ){
            System.out.print(n.value + " ");
            s.add(n);
            n = n.leftNode;
        }
        n = s.pop();

        n = n.rightNode;
    }
    System.out.println();
}
</code></pre>

<p>```</p>

<ul>
<li>非递归实现</li>
</ul>


<p>初始：1.维护一个栈S、一个节点变量N和一个标记数组。节点变量赋值为根节点，栈暂时存储便利到的节点，标记数组用于标记栈中的节点是否已经访问过右边节点。2.将根节点的所有左儿子压入栈中。</p>

<p>循环：依次处理栈中节点。如果节点有右儿子，且没有被处理过（通过标记数组判定），则将右子树的根节点及其左儿子全部压入栈中；如果已经处理过或者没有右儿子，则输出并出栈。</p>

<p>分析：与前序和中序的一个大的不同在于需要用标记数组标记节点的右子树是否已经访问过。对每个节点进行处理的时候，都保证已经处理完了左右子树（通过先压入左边儿子为主线，处理栈中的每个节点时，再压入右边儿子来实现）。</p>

<p>```
public void postOrderTravNoRecu(Node n) {</p>

<pre><code>    Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();
    int[] flag = new int[max];

    while (n != null) {
        stack.push(n);
        flag[stack.size()] = 0;
        n = n.leftNode;
    }

    while (!stack.empty()) {
        n = stack.peek();
        while(n.rightNode != null &amp;&amp; flag[stack.size()] == 0) {
            n = n.rightNode;
            flag[stack.size()] = 1;
            while (n != null) {
                stack.push(n);
                flag[stack.size()] = 0;
                n = n.leftNode;
            }
            n = stack.peek();//TODO be careful about this
        }
        n = stack.pop();
        System.out.print(n.value + " ");
    }

}
</code></pre>

<p>```</p>

<h3>层序遍历</h3>

<ul>
<li>无法使用递归方法</li>
</ul>


<p>层序遍历不同于其他的遍历。可以通过反证法证明：</p>

<p>如果能实现对A节点的层序递归，在对A节点处理的过程中，应该递归的对两个儿子B和C分别调用了层序遍历。在这种情况下，我们无法让B和C的同一个层级的儿子在集中的时间中被遍历到，换言之，B的第一层儿子在对B的调用中被遍历，而C的第一层儿子，则在对C的调用中遍历，这是分离开的。不成立，得证。</p>

<ul>
<li>非递归方法：</li>
</ul>


<p>分析：此方法类似于前序遍历的非递归方法的第一种。用一个栈维护信息。</p>

<p>```</p>

<pre><code>public void levelOrderTrav(Node n) {
    System.out.print("Level OrderTrav: ");

    Queue&lt;Node&gt; q = new LinkedList&lt;Node&gt;();
    q.add(n);
    while (q.size() != 0) {
        n = q.poll();
        System.out.print(" " + n.value);
        if (n.leftNode != null) 
            q.add(n.leftNode);
        if (n.rightNode != null)
            q.add(n.rightNode);

    }
}
</code></pre>

<p>```</p>

<h2>总结</h2>

<p>非递归实现的代码相对来说没有递归实现的直观。其核心都是维护了一个栈来保存状态，避免了产生过多方法调用栈浪费内存空间。</p>

<p>本文中针对二叉树的几种遍历方式，描述了递归和非递归的解决方案。普遍意义的递归转非递归的方法和思想，将在另外一篇博文中介绍;)。欢迎交流。</p>
]]></content>
  </entry>
  
</feed>
