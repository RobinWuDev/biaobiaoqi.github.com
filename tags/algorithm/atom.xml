<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: algorithm | Biaobiaoqi的博客]]></title>
  <link href="http://biaobiaoqi.github.com/tags/algorithm/atom.xml" rel="self"/>
  <link href="http://biaobiaoqi.github.com/"/>
  <updated>2013-08-01T01:21:59+08:00</updated>
  <id>http://biaobiaoqi.github.com/</id>
  <author>
    <name><![CDATA[Biaobiaoqi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PAT 1011-1020 题解]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/07/31/pat-1011-1020-solutions/"/>
    <updated>2013-07-31T23:41:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/07/31/pat-1011-1020-solutions</id>
    <content type="html"><![CDATA[<p>早期部分代码用Java实现。由于PAT虽然支持各种语言，但只有C/C++标程来限定时间，许多题目用Java读入数据就已经超时，后来转投C/C++。浏览全部代码：<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/tree/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel">请戳</a></p>

<p>本文谨代表个人思路，欢迎讨论;)</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/10111">PAT1011</a></h2>

<h5>题意</h5>

<p>给定一个3*3的矩阵，找到每行的最大值，格式化输出一个运算结果。</p>

<h5>分析</h5>

<p>非常简单的模拟题。</p>

<!--more-->


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/10012">PAT1012</a></h2>

<h5>题意</h5>

<p>给定学生的学号和三个科目的分数，查询输出对应学生单门科目排名和总分排名中最高的那个排名。</p>

<h5>分析</h5>

<p>C里stdlib.h中的qsort()和C++里algorithm中的sort()函数都能实现快排，应对编程题中的排序一般比自己手写的要快。
分别为三个单科和总分做排序，并将rank值记录到map结构中去，便于之后的查找。</p>

<p>需要注意并列排名的情况。比如<code>1 2 2 4</code>，由于并列第2的都两人，那之后的那个人就是第4而不是第3了。</p>

<p>另外，由于有多个需要分别排序、排名的项，抽象出公共逻辑到一个函数里比较必要，否则代码分散难于debug和维护。
这里稍微特殊点的用法是使用了<a href="http://blog.csdn.net/dyx1024/article/details/7562786">函数指针</a>做参数。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1013">PAT1013</a></h2>

<h5>题意</h5>

<p>给定一张图和指定几个点。针对给出的每个点，要求计算在图中除掉连接该点的路径的情况下，保证整个图连通需要添加几条边。</p>

<h5>分析</h5>

<p>计算保证整个图连通需要几个点，亦即求出图中有几个连通分量。两种思路：</p>

<ul>
<li>1.并查集</li>
<li>2.DFS</li>
</ul>


<p>针对每个点，执行算法的过程中，需要注意去除掉改点对应的所有通路。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1014">PAT1014</a></h2>

<h5>题意</h5>

<p>这道题是排队模拟题。银行有N个窗口，每个窗口允许排队M个人，如果N个窗口占满了排队的人，更多的人需要在黄线外等待。
每个人都会选择尽可能人少的窗口排队，如果有多个窗口等待队列一样长，则选择编号小的窗口。
前N个用户设定在8:00开始接受服务。给定了K个用户所需要接受服务的时间长度，要求在这个排队模型下，每个人的完成处理的时间点。</p>

<h5>分析</h5>

<p>相对另外几个队列模拟题，这个题是很简单的。没有达到时间的差异，只需要不断的从等待队列中取出人员即可。
当然，由于黄线内等待的每个窗口都有M人，所以必须单独的模拟每个窗口。
可以使用queue模拟每个窗口，循环遍历下次离开窗口的人，继而从等待队列中补上。
需要注意结束条件，如果17:00以后还没有开始接受服务，则不用再等待。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1015">PAT1015</a></h2>

<h5>题意</h5>

<p>Reversible Primes是指在某个进制下，一个数本身和它翻转过来形成的新数都是素数。
题中给出多组数据，以负数结尾程序。每组数据包含一个数以及一个进制数。判定该数是否是Reversible Primes.</p>

<h5>分析</h5>

<p>两个功能点实现：判定素数和特定进制下的数据倒转。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1016">PAT1016</a></h2>

<h5>题意</h5>

<p>给出一天中每个不同的小时内的电话付费标准，给出一份分为打出和挂断两种记录的通话记录，包括记录发生的时刻和用户名字，
要求整理出当月有效用户的账单，输出格式中需要输出所有的通话记录，包括开始时刻和结束时刻，每次通话的话费以及总计的话费。</p>

<h5>分析</h5>

<p>模拟题。首先对输入的通话记录按照先姓名后时间做qsort()排序，然后遍历排序后的记录，找到合适的匹配对，计算每次通话的时间，并进行统计和输出。</p>

<p>实现的难点主要有两个：</p>

<ul>
<li>1.在排序后的记录中，找到合适的配对。如果某人的通话记录为<code>1.on;2.on;3.off;</code>，则其中<code>1.on</code>将被抛弃，匹配到<code>2.on;3.off;</code>。
题中仅仅保证了所有记录中至少有一对有效记录，但并没有保证每个人都有有效通话记录，所以还需要做好过滤，
如果某人没有有效通话记录，则不输出。整体的控制流程需要谨慎。</li>
<li>2.由于不同时刻的话费不一样，计算一次有效通话的话费比较复杂。可以采用的方式是用起始时刻分阶段追赶结束时刻。追赶的过程分阶段，也就能计算好不同阶段的开销，
先将起始时间调整到跟结束时间为同一天，细节是先让分钟达到0，再让小时迭代到0，天进位，一直迭代到跟结束时间同天；再让起始时刻的小时数追平
结束时刻；最后让分钟追平。以此计算出最终话费。</li>
</ul>


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1017">PAT1017</a></h2>

<h5>题意</h5>

<p>银行有K个窗口，所有到达银行的人都应该在黄线外等待，直到有窗口空余。
每个窗口对单个客人最多服务时间为1小时。N个用户的到达时间和需要处理的时间给出。
8:00到17:00接受服务，逾期不服务，也不计入统计数据。要求格式化输出用户的平均等待时间。</p>

<h5>分析</h5>

<p>又一道排队模拟题。相比PAT1014，此题更复杂在于用户的到达时间是不确定的。
首先使用qsort()按照到达时间对所有人排序。由于每个窗口同时只有一个人在处理，所以窗口之间没有差异，可以用priority_queue建立一个队列，
模拟所有K个窗口。
优先队列将结束时间最早的人放到队列的顶端，每次循环处理一个人的结束。然后步入一个黄线外等待的人。如果那个时刻，下一个人还没有达到，则可以将该人开始执行的时间记录为他的到达时间，并加入队列中。
还有一点需要注意的：HH:MM:SS的时间格式，可以转换为累积秒数的时间，方便计算比较。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1018">PAT10108</a></h2>

<h5>题意</h5>

<p>以杭州的公用自行车站点管理为背景。每个站点是一个节点，每个节点上最多停放Cmax辆自行车，Cmax/2为节点的最佳状态。不同节点间距离不同，整个构成了一张带权无向图。要求从起始点（公用自行车管理中心）出发，去目的地维护目的地节点的车辆状态，如果车辆低于Cmax/2，则给它添加车辆到Cmax/2辆，如果多于Cmax/2，则去除掉几辆车。同时，在去往目的地的过程中，也需要调整所有沿途站点的车辆（这里题目没有交代清楚，实际测试是只能在去往目的地的途中调整，回来的途上不可调整）。求到给定目的地的最短路径，如果有多条最短路径，则按照1.从管理中心送出的车辆越少越好；2.拿回到管理中心的车越少越好的优先级找到结果。</p>

<h5>分析</h5>

<p>题目的大体框架是有权最短路径问题。步骤如下：</p>

<ul>
<li>1.使用Dijkstra找到最短路径，其中注意记录每个节点在最短路径中的【所有】前驱节点；</li>
<li>2.使用DFS的方法，得到所有的最短路径。</li>
<li>3.计算每条最短路径的带出和带回的车辆数量。</li>
</ul>


<p>其中DFS时，归纳所有答案的过程比较通用，需要掌握。</p>

<p>另外值得注意的是，类比到PAT1003，该题采用了直接对每个节点增加状态记录的方式，直接得到最优解，而不是先找到最短路径，然后计算比较。本题是无法用这种方法实现的，需要送出和带回的自行车数量无法直接在Dij算法中每个节点的计算中体现，并不是前面的节点带回和送出的车辆越少，后面的节点就一定能得到更优解。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1019">PAT1019</a></h2>

<h5>题意</h5>

<p>给定一个十进制数和一个进制，要求计算出在给定进制下的表达并判定是否为回文。</p>

<h5>分析</h5>

<p>简单的数字处理。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1020">PAT1020</a></h2>

<h5>题意</h5>

<p>根据二叉树的后序遍历和中序遍历，求层序遍历。</p>

<h5>分析</h5>

<p>具体实现方式：</p>

<ul>
<li>初始：用后序遍历序列确定根节点，在中序遍历序列中找到该根节点，则左右子树分别为中序中该节点左右的序列。</li>
<li>迭代：对各个子树分别执行三步操作，1.在后序序列中找子树的根节点；2。在中序序列中找子树的根节点，并划分开根节点的左右子树；3.根据新生成的左右子树，在后序序列中划分开这些节点，从而得到了两颗子树的后序、中序序列。</li>
</ul>


<p>有一个结论：中序遍历配合另外任何一个遍历，能重建二叉树。其他的任意两个序列的组合都不能唯一的确定重建的二叉树。具体分析参见博文<a href="../../../../2013/04/27/pat1020-pat1043-rebuild-binary-tree/">《根据前中后序和层序重建二叉树(PAT1020、PAT1043)》</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PAT 1001-1010 题解]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/07/31/pat-1001-1010-solutions/"/>
    <updated>2013-07-31T02:03:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/07/31/pat-1001-1010-solutions</id>
    <content type="html"><![CDATA[<p>早期部分代码用Java实现。由于PAT虽然支持各种语言，但只有C/C++标程来限定时间，许多题目用Java读入数据就已经超时，后来转投C/C++。浏览全部代码：<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/tree/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel">请戳</a></p>

<p>本文谨代表个人思路，欢迎讨论;)</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1001">PAT1001</a></h2>

<h5>题意</h5>

<p>格式化输出两数之和。</p>

<h5>分析</h5>

<p>理清输出逻辑即可。</p>

<!--more-->


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1002">PAT1002</a></h2>

<h5>题意</h5>

<p>给定两多项式，相加并格式化输出结果。</p>

<h5>分析</h5>

<p>两种思路</p>

<ul>
<li>1.采用链表的处理方式；</li>
<li>2.预设好int[1005]的数组，用下标表示次方，数组中元素值表示对应系数。</li>
</ul>


<p>第一种方法某种程度上看能节省空间，实现上需要注意操作链表时，循环时的越界问题；
方法二用空间换取时间，且实现上更不容易出错。同时，由于浮点数本身精确位数不够，在判定两浮点数相加是否为0时，
需要对结果值取绝对值后，与1e-6做对比。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1003">PAT1003</a></h2>

<h5>题意</h5>

<p>求两个城市之间的加权最短路径。在有多个最短路径记录的情况下，选择路径中所有节点的权重值之和最小的。</p>

<h5>分析</h5>

<p>Dijkstra算法的变型实现。两种思路：</p>

<ul>
<li>1.计算最短路时，在每个节点上用链表preList记下所有最短路径的前节点。
完成计算后，对preList做dfs获得每条最短路径的权重值之和，比较后得到结果；</li>
<li>2.计算最短路径时，在节点上，除了记录最短路径中前一个节点preNode之外，还对应的记录当前的最短路径上所有节点的权重值之和，
这就不用在Dij完成之后再做dfs了，过程中已经找到了最优解。</li>
</ul>


<p>相比之下，方法2明显更简洁。当然，虽然方法2的思路很通用，还需要确定，这一加权的判定条件是能够迭代处理的。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1004">PAT1004</a></h2>

<h5>题意</h5>

<p>计算给定的树各个层级叶子节点的个数</p>

<h5>分析</h5>

<p>先构建树，鉴于题目的空间限制不严格，可以使用邻接矩阵的方式定义树结构。然后使用dfs遍历树的节点，并记录每层的叶子节点数量。
可以看到，时间空间的trade-off不仅仅是性能上的提升，也会影响带代码实现的复杂程度。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1005">PAT1005</a></h2>

<h5>题意</h5>

<p>计算一个数（&lt;=10<sup>100）的各个位数之和，并用英语按位输出。比如15输出为one</sup> five.</p>

<h5>分析</h5>

<p>简单题，输出的实现上实际上就用到了Hash思想。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1006">PAT1006</a></h2>

<h5>题意</h5>

<p>每个人来到实验室和离开实验室的时间都有记录。找到其中最早来实验室和最晚离开实验室的时间。</p>

<h5>分析</h5>

<p>逻辑上很简单的一个题，遍历所有数据，找到其中最大和最小的值即可。稍微要处理的就是时间。
由于input中给出的是HH:MM:SS的格式，在比较时需要将其换算为int值。实际上，使用C语言读入更方便，<code>scanf("%d:%d:%d", &amp;h, &amp;m, &amp;s);</code>
然后计算出<code>time = 3600*h + 60*m + s</code>，时间比较就没有问题了。在最终的输出时再做对应的转换即可。
而在Java语言中，使用到了String的split方法划分子串和Integer.parseInt()转String为int。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1007">PAT1007</a></h2>

<h5>题意</h5>

<p>给出一组由正负整数组成的序列，求出拥有最大和的连续子序列。</p>

<h5>分析</h5>

<p>最暴力的算法是两个循环的O(n<sup>2)；进一步要使用分治的思想，可以得到O(n*logn)；更好的方法可以达到O(n)，也可以将它看做分治思想。关键在于数学归纳的证明，编程实现非常简单：假定[0,</sup> n-1]的最大连续子串已经求出了，要求[0,n]的最大连续子串。</p>

<ul>
<li>1.如果[0, n-1]中最大子串不包含最右的数字，则判定<code>原最大子串的和</code>与<code>包含最右点的最大子串 + a[n]的和</code>的大小。取大的那个作为[0, n]的最大子串，并保持一个<code>包含最右点的最大子串</code>。</li>
<li>2.如果[0, n-1]中最大子串包含最右的数字，则[0, n]的最大子串为原最大子串+a[n]。</li>
</ul>


<p>实际上，算法的核心是维持了两个量的记录，即当前的<code>最大子串</code>，以及当前<code>包含最右点的最大子串</code>。</p>

<p>更多讨论参见博文<a href="../../../../2013/04/05/maximum-subsequence-sum/">《分治、时间空间的权衡:最大合的连续字串问题 (PAT 1007)
》</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1008">PAT1008</a></h2>

<h5>题意</h5>

<p>给出电梯的行进路径，上下的速度和每层停留时间，计算总时间。</p>

<h5>分析</h5>

<p>简单的模拟题。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1009">PAT1009</a></h2>

<h5>题意</h5>

<p>求两个多项式的乘积。</p>

<h5>分析</h5>

<p>参见PAT1002，使用数组存储虽然空间占用稍大，但比链表实现要便捷很多。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1010">PAT1010</a></h2>

<h5>题意</h5>

<p>给定两个数，其中单个位置上的数值范围可以为[0-z]。指定其中一个数的进制，试确定是否存在可能的进制让两数的实际值相等。</p>

<h5>分析</h5>

<p>此题没有交代清楚input中radix的取值范围以及对一位数有多重可能radix的情况如何输出，坑比较大。下面是需要注意的点。</p>

<ul>
<li>1.input中两个数字可以是10位数，虽然没有告诉radix的范围，但在<code>9*10^10 10 1 200</code>这个示例中，可以看到结果的radix也可以是很大的。从这个角度看，代码中将radix和两个数值都设定为longlong是合适的选择。</li>
<li>2.在计算另一个数的radix时，简单的遍历[2, 10<sup>18]会超时。单调的区间很自然想到使用二分查找。</sup></li>
<li>3.二分查找的上下界确定能减少耗时：下界选数字的所有位上的最大值+1；上界容易想当然的认为就是题中给定了radix的数的值。实际上，示例<code>11 b 1 10</code>就是一个反例，原因在于这个假设忽略了一位数的可能性，解决方案是在取给定radix的数值和下界中较大的那个数。</li>
<li>4.在二分查找时，不可直接计算出某个radix下数的值，因为可能会longlong溢出。于是需要用特定的compare函数，在累加的过程中判定是否大于另一个数。算是一种剪枝。</li>
<li>5.还有一个条件：当两个数都是1时，输出2.当两个数相等且不为1时，输出题中给出的radix。（这是从其他人的结题报告中看到的，完全不理解=。=）</li>
</ul>


<p>注意好这些方面，应该能ac了。保重。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[出栈序列的可能性判定（PAT1051）]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/07/16/verify-pop-sequence-for-stack/"/>
    <updated>2013-07-16T01:32:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/07/16/verify-pop-sequence-for-stack</id>
    <content type="html"><![CDATA[<h2>问题说明</h2>

<p><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1051">PAT1051</a>：给定stack的容量，给定数据的入栈顺序：从1开始的正整数序列，在允许随机的出栈操作的情况下，要求判断某出栈序列是否可能。</p>

<p>比如，告知stack容量为5，入栈序列的最大值为7。有两个序列需要判断合理性：</p>

<ul>
<li><code>1 2 3 4 5 6 7</code>： 这个序列是可能的，只需每次入栈时都做出栈操作。</li>
<li><code>3 2 1 7 5 6 4</code>： 这个序列是不可能的，其中前半部分<code>3 2 1</code>是合法的，先将<code>1 2 3</code>顺序入栈，然后三次执行出栈操作。而之后的<code>7 5 6</code>则是不可能的。</li>
</ul>


<p>要完成判定过程，常规思路是直接使用的stack数据结构模拟出栈序列做操作，然后判定是否会触犯条件。但考虑到PAT1051中时间限制只有10ms，虽然常规方法是线性的，似乎也无法保障（事实证明是错误的，用常规方法也能在PAT上AC），我想到从序列本身的特性入手，找规律，于是有了一种效率更高的判定逻辑。</p>

<h2>常规思路</h2>

<p>直接使用出栈序列指导stack模拟操作。判定条件有两条：</p>

<ul>
<li>1.栈中数据量不超过栈的容量。</li>
<li>2.出栈只能从栈顶取，不应该出现从固定的堆栈中取出其他数据的情况。</li>
</ul>


<p>算法描述如下：</p>

<p>用游标记录当前已知压栈的最大数据cur。如果新的读入数据tmp（即出栈序列中的某数据）大于cur，则将cur到tmp之间的数据顺序压入栈中，更新cur并执行检查1；如果新的读入数据tmp小于cur，则一定是直接出栈获得的，执行检查2。</p>

<p>如果能顺利完成就是合理的，如果操作过程违背了一些规则，则判定为不合理。C++实现代码如下：</p>

<p>``` cpp</p>

<h1>include&lt;stdio.h></h1>

<h1>include<stack></h1>

<p>using namespace::std;
int m, n, k, tmp, cur;
bool flag;
stack<int> s;
int main()
{</p>

<pre><code>scanf("%d %d %d", &amp;m, &amp;n, &amp;k);
while(k --) {
    flag = true;
    cur = 1;
    s.push(1);
    for (int i = 0; i != n; ++ i) {
        scanf("%d", &amp;tmp);
        if (tmp &gt; cur) {
            for (int j = cur + 1; j &lt;= tmp; ++ j)
                s.push(j);
            if (s.size() &gt; m) flag = false;
            cur = tmp;
        }else {
            if (s.top() != tmp)
                flag = false;
        }
        s.pop();
    }

    if (flag) printf("YES\n");
    else printf("NO\n");
}
</code></pre>

<p>}</p>

<p>```</p>

<h2>更高效的判定逻辑</h2>

<p>实际上，在PAT1051的环境下，由于入栈序列数据由小到大排列非常特殊，要通过出栈序列判定可能性是存在简便思路的。</p>

<p>对比分析题中Sample给出的序列，结合上面提到的两条冲突条件入手分析：</p>

<ul>
<li><p>1.栈中数据量不超过栈的容量：</p>

<p>  只有在入栈时，才会需要考虑栈中数据是否超量。出栈序列中的每个数，都以为着在出栈操作之前，它刚入栈，那么当它入栈的时候能否判定是否超过栈容量呢？可以的，（当前的出栈数值 - 已经执行过的出栈操作数量）就是当前栈中元素的数量。</p></li>
</ul>


<!--more-->


<ul>
<li><p>2.出栈只能从栈顶取，不应该出现从固定的堆栈中取出其他数据的情况。</p>

<p>  根据观察分析发现，当某数据m出栈之后，比m小的数据如果在m之后出栈的，它们所组成的序列本身需要保持从大到小的顺序排列。距离如<code>3 2 1 7 5 6 4</code>这个序列，在<code>7</code>之后有<code>5 6 4</code>这个子序列，它们都大于<code>7</code>，但却没有保持一个递减的顺序，不合法。</p></li>
</ul>


<p>C++实现代码如下：</p>

<p>``` cpp</p>

<h1>include&lt;stdio.h></h1>

<p>int m, n, k;
int max, min, tmp;
bool flag;
int main()
{</p>

<pre><code>scanf("%d %d %d", &amp;m, &amp;n, &amp;k);
while(k --) {
    flag = true;
    max = 0;
    min = 1001;

    for (int i = 0; i != n; ++ i) {
        scanf("%d", &amp;tmp);
        if (tmp &gt; max) {
            if (tmp - i &gt; m) flag = false;
            else max = min= tmp;
        } else {
            if ( tmp &gt; min) flag = false;
            else min = tmp;
        }
    }

    if (flag) printf("YES\n");
    else printf("NO\n");
}
</code></pre>

<p>}
```</p>

<h2>总结</h2>

<p>在我的理解之中，经典的算法、数据结构是在面对编程问题的解决过程中所抽象出的通用模型。而生活是多变的，并不像考试卷一样简单的套用数学题所能解决，很多情况下，编程问题也是如此。那么除了这些经典的方法外，认真分析条件，并进行针对性的优化甚至重新设计就非常重要了。这里仅仅是一个小实践。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[KMP算法实现]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/05/25/kmp-algorithm/"/>
    <updated>2013-05-25T21:22:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/05/25/kmp-algorithm</id>
    <content type="html"><![CDATA[<p>本文描述了单模式的字符串匹配的经典算法KMP算法的实现。首先对字符串匹配算法做简单的介绍，然后是KMP算法的实现描述，最后推荐两道简单的ACM模板题做练手用。</p>

<h2>字符串匹配算法</h2>

<p>字符串匹配(String Matchiing)也称字符串搜索(String Searching)是字符串算法中重要的一种，是指从一个大字符串或文本中找到模式串出现的位置。一个基本的字符串匹配算法分类如下：</p>

<ul>
<li>单模式匹配：即每次算法执行只需匹配出一个模式串。</li>
<li>有限集合的多模式匹配：即算法需要同时找出多个模式串的匹配结果，而这个模式串集合是有限的。</li>
<li>无限集合的多模式匹配：如正则表达式的匹配。</li>
</ul>


<p>单模式匹配最容易理解，构造也非常简单。一个最朴素的思路就是从文本的第一个字符顺次比较模式串，不匹配则重新从下一个字符开始匹配，直到文本末尾。Java实现代码如下：</p>

<p>``` java</p>

<pre><code>public static boolean bruteforce(String str1, String str2) {
     for (int i = 0, j = 0; i!= str1.length(); ) {
           if (str1.charAt(i) == str2.charAt(j)) {
                j ++;
                i ++;
                if (j == str2.length()) return true;
           }else {         
                i = i - j + 1;
                j = 0;                        
           }
      }
      return false;
 }
</code></pre>

<p>```</p>

<p>但是这种算法，有明显的效率黑洞。因为每次匹配失败后，都会回到原来的匹配起点的下一个字符开始匹配，这些步骤很多情况下，并不是必要的。</p>

<p>实际上这些字符很有可能已经被读入了一次。理论上，如果我们能对所有被读入过的字符有足够的了解，那就能判定是否能避免再次读入一遍做匹配运算了。经典的KMP算法正是基于这点思考，对原有的蛮力算法做出了优化。</p>

<h2>KMP算法</h2>

<p>网络上关于KMP算法的描述很多，其中个人觉得阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">《字符串匹配的KMP算法》</a>对KMP的描述最为简明和清晰。图例展示的算法流程更容易让人接受和理解。这里仅记录我所认为重点的知识点。</p>

<h5>算法的思想</h5>

<p>相比蛮力算法，KMP算法预先计算出了一个哈希表，用来指导在匹配过程中匹配失败后尝试下次匹配的起始位置，以此避免重复的读入和匹配过程。这个哈希表被叫做“部分匹配值表(<strong>Particial match table</strong>)”，它的设计是算法精妙之处。</p>

<h5>部分匹配值表</h5>

<p>要理解部分匹配值表，就得先了解字符串的前缀(prefix)和后缀(postfix)。</p>

<ul>
<li>前缀:除字符串最后一个字符以外的所有头部串的组合。</li>
<li>后缀：除字符串第一个字符以外的所有尾部串的组合。</li>
<li>部分匹配值：一个字符串的前缀和后缀中最长共有元素的长度。</li>
</ul>


<p>举例说明：字符串<code>ABCAB</code></p>

<ul>
<li>前缀：{A， AB， ABC， ABCA}</li>
<li>后缀：{BCAB， CAB， AB， B}</li>
<li>部分匹配值：2 （AB）</li>
</ul>


<p>而所谓的部分匹配值表，则为模式串的所有前缀以及其本身的部分匹配值。</p>

<p>举例如下：还是针对字符串<code>ABCAB</code>，它的部分匹配值表为：</p>

<p><code>
A B C A B
0 0 0 1 2
</code></p>

<p>这代表着：字符串<code>A B C A B</code> 中，子串<code>A B C</code>的部分匹配值为0，而子串<code>A B C A</code>的部分匹配值为1，诸如此理。</p>

<h5>算法实现</h5>

<p>``` java</p>

<pre><code>public static int[] next;

public static boolean kmp(String str, String dest) {
    // i stands for index of str string, j stands for index in dest string.
    // At the beginning of each loop process, j is the new position of dest
    // taht should be compared.
    for (int i = 0, j = 0; i &lt; str.length(); i++) {
        while (j &gt; 0 &amp;&amp; str.charAt(i) != dest.charAt(j))
            // This loop is to get a matching character recursively. Another
            // stop condition is when particial match value meets end.
            j = next[j - 1];// As i in str and j in dest is comparing,
                            // recomputing of j should be in the former
                            // character substring, which is next[j-1]

        if (str.charAt(i) == dest.charAt(j))
            j++;

        if (j == dest.length())
            return true;
    }

    return false;
}

public static int[] kmpNext(String str) {
    int[] next = new int[str.length()];
    next[0] = 0;
    // i stands for index of string, j is temporary for particail match
    // values computing, at the beginning of each loop process, j is the
    // particial match value of former character .
    for (int i = 1, j = 0; i &lt; str.length(); ++i) {
        while (j &gt; 0 &amp;&amp; str.charAt(i) != str.charAt(j))
            // This loop is to get a matching character recursively. Another
            // stop condition is when particial match value meets end.
            j = next[j - 1];// j will be recomputed in the recursion. Take
                            // care that next[j-1] is the particial match
                            // value of the first j characters substirng.

        if (str.charAt(i) == str.charAt(j)) // If not in this case, j must
                                            // meets end, equals to zero.
            ++j;

        next[i] = j;
    }
    return next;
}
</code></pre>

<p>```</p>

<p>理解算法实现时，有几点特别需要注意：</p>

<ul>
<li>在生成部分匹配值数组的kmpNext()方法中，第一层循环内，<code>i</code>是字符串的索引，而<code>j</code>则在每次循环开始时代表了<code>i</code>所指定字符之前的子串的部分匹配值。</li>
<li>kmpNext()方法的内层while()循环，是为了迭代得到让<code>i</code>指定字符匹配到的情况。有另外一种实现方案：不有用这一层循环，而是直接使用一层循环，在大循环内部做j值变更的判定即可。</li>
<li>kmpNext()方法的while()循环中，需要特别注意是<code>next[j -1]</code>，部分匹配值j对应到的是字符串中的第<code>j-1</code>个字符。</li>
<li>kmp()的循环代码和kmpNext()部分匹配值表生成的循环代码很类似。两者使用了相同方式，在字符匹配失败后迭代获取新的可匹配情况，且都是利用了next数组。</li>
</ul>


<h2>其他</h2>

<p>KMP算法虽然能达到O(M+N)的算法复杂度，但在实际使用中，KMP算法的性能并不如<a href="http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html">BM</a>算法强。</p>

<h2>模板题</h2>

<h4>基础模板题</h4>

<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2203">HDOJ的2203题</a>是一个能检验算法正确性的模板题。Java实现的答案代码<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/practice/hdoj/HDOJ2203.java">请戳这里</a>。</p>

<h4>延伸模板题</h4>

<p><a href="http://poj.org/problem?id=2406">POJ的2406题</a>，对考察点做了巧妙的变形，对更深入的理解KMP中的部分匹配表（即next数组）很有帮助。Java实现的答案代码<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/practice/poj/POJ2406.java">请戳这里</a>。</p>

<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1867">HDOJ的1867题</a>也属于kmp的变形。要求对kmp利用next数组进行比较的过程有清晰的认识。Java实现的答案代码<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/practice/hdoj/HDOJ1867.java">请戳这里</a>。</p>

<h3>其他参考资料：</h3>

<ul>
<li><p><a href="http://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm">wiki:Knuth–Morris–Pratt Algorithm</a></p></li>
<li><p><a href="http://en.wikipedia.org/wiki/String_searching_algorithm">wiki:String Searching Algorithm</a></p></li>
<li><p><a href="http://www.cppblog.com/converse/archive/2006/07/05/9447.html">《KMP算法的实现》</a></p></li>
<li><p><a href="http://wangcong.org/blog/archives/2090">《Linux 内核中的 KMP 实现》</a></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[根据前中后序和层序重建二叉树(PAT1020、PAT1043)]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/04/27/pat1020-pat1043-rebuild-binary-tree/"/>
    <updated>2013-04-27T22:33:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/04/27/pat1020-pat1043-rebuild-binary-tree</id>
    <content type="html"><![CDATA[<h2>背景</h2>

<p><a href="/blog/2013/04/27/travsal-binary-tree/">《二叉树的遍历（递归、非递归）分析》</a>总结了二叉树不同遍历方式的递归和非递归实现，本文则讨论如何针对不同遍历方式的组合重建二叉树。为了简化问题的考虑，假定二叉树中不会出现重复值。列入考虑范围的有前序、中序、后序、层序遍历这四种的组合。前中后序比较常见，而层序则相对特殊一点了。</p>

<p><a href="http://pat.zju.edu.cn/contests/pat-a-practise">PAT</a>的1043和1020题是遍历相关的模板题，正好派上用场。</p>

<!--more-->


<h2>中序+前序</h2>

<h5>算法描述：</h5>

<ul>
<li><p>初始：用前序遍历序列确定根节点，在中序遍历序列中找到该根节点，则左右子树分别为中序中该节点左右的序列。</p></li>
<li><p>迭代：对各个子树分别执行三步操作，1.在前序序列中找子树的根节点；2。在中序序列中找子树的根节点，并划分开根节点的左右子树；3.根据新生成的左右子树，在前序序列中划分开这些节点，从而得到了两颗子树的前序、中序序列。</p></li>
</ul>


<h5>练习：<a href="http://pat.zju.edu.cn/contests/pat-a-practise/1043">PAT1043:Is It a Binary Search Tree</a></h5>

<h5>题意：</h5>

<p>输入一个树的前序遍历序列，判定这个树是否是二叉搜索树或者BST的镜像树，如果是，则用后序序列输出。</p>

<h5>解题思路：</h5>

<ul>
<li><p>1.BST很特殊，实质上BST的所有节点的顺序排列就是中序遍历了。</p></li>
<li><p>2.要检查树是否是BST或者镜像BST，只需按照重建树的思路，在每次重建的过程中做适当检查即可。检查思路是：检查前序遍历序列中，根节点之后的节点排序是否符合BST的二分规则（即前一段都是小于根节点的，后一段都是大于根节点的）。</p></li>
<li><p>3.最后的输出是后序遍历。过程中其实并不用构建整个树，直接在处理过程中，按后序的方式存储节点到队列中即可。</p></li>
</ul>


<p>有了这些考虑，就可以写出代码啦。详细解题代码见链接<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/pat/advancedlevel/APAT1043.java">PAT1043</a></p>

<h2>中序+后序</h2>

<h5>算法描述：</h5>

<ul>
<li><p>初始：用后序遍历序列确定根节点，在中序遍历序列中找到该根节点，则左右子树分别为中序中该节点左右的序列。</p></li>
<li><p>迭代：对各个子树分别执行三步操作，1.在后序序列中找子树的根节点；2。在中序序列中找子树的根节点，并划分开根节点的左右子树；3.根据新生成的左右子树，在后序序列中划分开这些节点，从而得到了两颗子树的后序、中序序列。</p></li>
</ul>


<h5>练习：<a href="http://pat.zju.edu.cn/contests/pat-a-practise/1020">PAT1020:Tree Traversals</a></h5>

<h5>题意：</h5>

<p>输入为一棵二叉树的后序遍历序列和中序遍历序列。求树的前序遍历序列。</p>

<h5>解题思路：</h5>

<ul>
<li><p>1.有了中序和后序，就能重建树。</p></li>
<li><p>2.最后的输出是层序遍历。过程中其实并不用构建整个树。直接在处理过程中，按层序的方式存储节点到队列中即可。</p></li>
</ul>


<p>详细解题代码见链接<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/pat/advancedlevel/APAT1020.java">PAT1020</a></p>

<h2>中序+层序</h2>

<h5>算法描述：</h5>

<ul>
<li><p>初始：用层序遍历确定顶节点，在中序遍历中，利用顶节点划分出左右子树。</p></li>
<li><p>迭代：对各个子树分别执行三步操作，1.在层序序列中，找出子树节点集合中，最靠前的节点，这个节点即为子树的顶节点；2.在中序序列中找1中得到的顶节点，并划分开顶节点的左右子树；</p></li>
<li><p>跟（中序+前序）和（中序+后序）不同之处在于没有迭代的第3步，层序是无法直接划分得到左右子树的节点集合的。但这并不妨碍正常的处理。层序是用来找到子树的顶节点的，而顶节点即是所有子树的节点中，在层序遍历中最靠前的节点。</p></li>
</ul>


<h2><del>前序+后序</del></h2>

<p>这个组合是<strong>无法</strong>重建确定的二叉树的。</p>

<p>对于满二叉树，利用子树节点的排列顺序能区分开左右子树节点集合，构建是没有问题的。但一旦有单个叶子的节点存在，则无法确定叶子是左儿子还是右儿子。因为无论是前序还是后序序列，都无法体现单个儿子情况下，儿子的位置。前序会将左右子树的点置于节点之后，后序则是将左右子树的点置于节点之前。</p>

<ul>
<li>举个简单的反例：</li>
</ul>


<blockquote><p>给出如下的前序序列和后序序列：
preorder: A, B;
postorder: B, A</p>

<p>能构建的二叉树有两种可能，1.A是根节点，B是A左儿子； 2.A是根节点， B是A的右儿子。无法得到一个唯一的结果。</p></blockquote>

<h2><del>前序+层序</del></h2>

<p>这个组合也是无法重建确定的二叉树的。同样于后序+层序的情况。</p>

<p>道理跟（前序+后序）的道理一样，无论是前序、后序，还是层序，都是无法确定单个儿子节点情况下儿子节点的顺序。</p>

<h2>总结</h2>

<ul>
<li>中序遍历配合另外任何一个遍历，能重建二叉树。其他的任意两个序列的组合都不能唯一的确定重建的二叉树。</li>
</ul>

]]></content>
  </entry>
  
</feed>
