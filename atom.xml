<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Biaobiaoqi的博客]]></title>
  <link href="http://biaobiaoqi.github.com/atom.xml" rel="self"/>
  <link href="http://biaobiaoqi.github.com/"/>
  <updated>2013-09-02T21:07:42+08:00</updated>
  <id>http://biaobiaoqi.github.com/</id>
  <author>
    <name><![CDATA[Biaobiaoqi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[biaobiaoqi的博客日志]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/09/01/blog-log/"/>
    <updated>2013-09-01T01:40:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/09/01/blog-log</id>
    <content type="html"><![CDATA[<p>鉴于友言的客服不搭理的态度和时而无法正常显示以及管理界面的难以使用，决定将评论系统切换到 disqus 上。</p>

<p>最近一直在更改博客的定制。就像一个人一样，产品也是由生命的，她的脚印就是她价值的体现。于是我萌生了将她的改变全部记录下来的想法，只恨没有在四个月前刚建起博客时就意识到这一点。</p>

<p>这就是本文的初衷了。</p>

<p>&#8211; 2013/9/1</p>

<h2>历史</h2>

<ul>
<li><p>2013/4 octopress 博客在 github 上成功搭建</p></li>
<li><p>2013/5 拟定了“首页”、“技术”、“生活”、“关于”的顶栏 tag 结构，增加了友言评论功能，jiathis 分享功能，侧边栏的微博秀和豆瓣秀。</p></li>
<li><p>2013/7 侧边栏增加标签云，并增加了“标签云”顶栏 tag。取消侧边栏微博秀。</p></li>
<li><p>2013/8 更换博客主题为 whitelake。</p></li>
</ul>


<!--more-->


<ul>
<li>2013/9/1 取消友言评论功能，采用 disqus 评论系统。</li>
</ul>


<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/09/01/blog-log/'>http://biaobiaoqi.github.com/blog/2013/09/01/blog-log/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[octopress第三方插件：博文同步工具syncPost]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/08/31/octopress-3rd-party-plugin-syncpost/"/>
    <updated>2013-08-31T19:30:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/08/31/octopress-3rd-party-plugin-syncpost</id>
    <content type="html"><![CDATA[<p>为了增加外链等考虑，独立博客往往有将博文同步到其他博客社区的需求。自己人肉黏贴的方式笨拙、重复，对于程序猿而言，着实不可取。</p>

<p>我在 github 上找到了 <a href="https://github.com/huangbowen521/octopress-syncPost">syncPost</a> 这个针对 octopress 的第三方工具，能够通过一些论坛提供的 <a href="http://en.wikipedia.org/wiki/MetaWeblog">metaWeblog</a> 服务实现 octopress 最新一篇博文的同步提交。</p>

<p>这大概就是我要找的东西吧。不过，其中有些细节并不是我想要的：</p>

<ul>
<li>1.在本地配置文件存储论坛账户的密码。虽然可以设置为 ignore 不提交到 git 代码库中，但这也并不安全。</li>
<li>2.只能同步最新的一篇博客，没有整体的博文搬家功能。</li>
<li>3.先比其他的 octopress 插件，原来版本的代码结构难于维护，比如有自己单独的配置文件，而不是使用全局的<code>_config.yml</code>(在那个版本中大概是为了不把明文密码提交到版本库中)，比如 ruby 文件单独在一个<code>_custom</code>文件夹下等</li>
</ul>


<p>基于这些点，我 fork 了作者的代码，定制成了它<a href="https://github.com/biaobiaoqi/octopress-syncPost">现在的样子</a>。</p>

<!--more-->


<h2>功能</h2>

<p>通过 rake 的方式实现同步功能：</p>

<ul>
<li>1.同步所有 octopress 的博文到目标博客。 (<code>rake sync_all_posts</code>)</li>
<li>2.同步最新一篇博文到目标博客。(<code>rake sync_lates_post</code>)</li>
</ul>


<h2>开发</h2>

<p>这个 octopress 插件的结构很简单：</p>

<ul>
<li>安装<code>nokogiri</code>和 <code>metaweblog</code>两个 gem。前者实现对 octopress 生成的 html 页面的解析，找到对应的博文。提供了客户端发起 MetaWeblog 请求的功能。</li>
<li>在全局配置文件<code>_config.yml</code>中配置了目标博客 MetaWeblog 的服务地址、用户的账号信息。</li>
<li>octopress/plugins/sync_*.rb 三个文件则是代码实现。其中 sync_post.rb 中包含了 post 类，是主要的逻辑代码所在，sync_all_posts.rb 和 sync_latest_post.rb 则是对前者的调用。</li>
<li>修改了 octopress 的 Rakefile，通过 rake 的方式实现功能。</li>
</ul>


<h2>下一步</h2>

<p>希望能进一步完善这个插件，现在考虑到的有：</p>

<ul>
<li>增加同步所有博文功能中，对目标博客中已有博文的查重功能。即对于已经同步过去的博客，不再发送请求，或者实现编辑功能的同步功能。由于站点的 MetaWeblog 服务大多对请求有时限控制，同步过程中可能出现中断，此时部分博文已经同步过去，而部分没有，这种情况下，暂时没有好的解决方式。</li>
<li>测试其他有 MetaWeblog 服务的博客站点（现在仅测试了 cnblog）。</li>
<li>cnblog 的博文显示中，似乎不支持 octopress 的代码块样式。</li>
</ul>


<p>欢迎感兴趣的朋友参与到这个 repo 中来:)</p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/08/31/octopress-3rd-party-plugin-syncpost/'>http://biaobiaoqi.github.com/blog/2013/08/31/octopress-3rd-party-plugin-syncpost/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PAT 1061 - 1064 题解]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/08/31/pat-1061-pat-1064/"/>
    <updated>2013-08-31T13:32:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/08/31/pat-1061-pat-1064</id>
    <content type="html"><![CDATA[<p>这四道题来自 13 年 08 月 30 的 PAT 测试。</p>

<p>代码量不大，思路也比较直接。不过第一题的处理逻辑不太清晰，需要好好把握。稍有不慎就掉进坑里了（很多人被这道 20‘的题坑了一个多小时心慌意乱我会乱说-，-？）。</p>

<p>PAT advanced level 全部源码：<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/tree/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel">请戳</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1061">1061. Dating (20)</a></h2>

<h5>题意</h5>

<p>题意比较模糊，需要仔细对照 Sample 的数据理清思路。给定四个字符串，每个不超过 60 个字符，不含空格。要求从中找到符合如下规定的三个字符（或者它们的位置），并转化成一个时间的表达：</p>

<ul>
<li>1.依次比较前两个字符串中每个位置的元素，找到第一个相等的字符，且该字符属于[&#8216;A&#8217;, &#8216;G&#8217;]的字母，注意大小写敏感。转换成一周七天输出。</li>
<li>2.在 1 中的字符出现之后，继续比较前两个串，找到一个相等的字符，使它属于[&#8216;0&#8217;, &#8216;9&#8217;] || [&#8216;A&#8217;, &#8216;N&#8217;]，同样，大小写敏感。转换成一天 24 小时的小时数输出。</li>
<li>3.比较后两个字符串，找到第一个相等的字母（isalpha()），将它在数组中的位置值转换分钟数输出。</li>
</ul>


<p>为了便于理解，给出 Sample 数据:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Sample Input:
</span><span class='line'>
</span><span class='line'>3485djDkxh4hhGE 
</span><span class='line'>2984akDfkkkkggEdsb 
</span><span class='line'>s&hgsfdk 
</span><span class='line'>d&Hyscvnm
</span><span class='line'>
</span><span class='line'>Sample Output:
</span><span class='line'>
</span><span class='line'>THU 14:04
</span></code></pre></td></tr></table></div></figure>


<h5>分析</h5>

<p>理清题目的逻辑以后，实现起来是很简单的。</p>

<p>pat1061 源码:<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel/APAT1061.cpp">请戳</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1062">1062. Talent and Virtue (25)</a></h2>

<h5>题意</h5>

<p>给定一堆人，每个人有三条记录：id，道德值(v)，才能值(t)。给出两个值 L 和 H，用作对这堆人的分类。按照如下规则输出排序结果：</p>

<!--more-->


<ul>
<li>0.过滤掉 v 和 t 都小于 L 的人</li>
<li>1.v 和 t 都不小于 H 的人是圣人，属于最高的层级，排序在其他层级之前。</li>
<li>2.v 不小于 H，而 t 小于 H 的人是君子，这个层级排在圣人之后。</li>
<li>3.剩下的人中，v 不小于 t 的人是愚人，层级关系里排第三，排在所有圣人和君子之后。</li>
<li>4.最后剩下的人是小人，是最低的层级。</li>
<li>5.排名时，相同层级的人的排序关系是 1.按照 v+t 的总分 non-increasing 排序；2.按照 v 的分值按 non-increasing 排序；3.找到 id 按 increasing 排序。</li>
</ul>


<h5>分析</h5>

<p>题意梳理清楚以后，定制比较函数用 qsort()能很快的实现。</p>

<p>经测试，使用<code>cout</code>，<code>cin</code>会超时，改用&#8217;printf() scanf()&#8217;轻松过。</p>

<p>pat1062 源码:<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel/APAT1062.cpp">请戳</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1063">1063. Set Similarity (25)</a></h2>

<h5>题意</h5>

<p>题目给出了 N(&lt;=50)个正整数集合（实际上不是真正意义上的 set，有重复数值），每个集合最多存 M(&lt;10<sup>4)个元素，其中数值范围是</sup> [0, 10<sup>9]。给出</sup> K 次查询，每次查询条件为两个集合，要求求出两集合的相似度。</p>

<p>这里集合相似度的定义是 Nc/Nt*100%，其中 Nc 为两集合的交集元素数量，Nt 为两集合的并集的元素数量。</p>

<h5>分析</h5>

<p>思路一：</p>

<p>利用<code>sort()</code>对数组做排序，然后遍历去重。计算交集时，直接用两个游标对数组遍历进行比较操作，并集等于两者的大小之和减去交集的大小。复杂度为 O(M<em>K + N</em>M*logM)。这种游标遍历的思想，还是很 common sense 的处理方式，精妙之处在于循环判断和内部的判断逻辑的分离，让代码清晰明了。</p>

<p>思路二：</p>

<p>有不愿意透露姓名的<a href="http://weibo.com/cloudbye">@草原</a>同学提出，使用 set 做去重是没问题的。</p>

<p>pat1063 源码:<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel/APAT1063.cpp">请戳</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1064">1064. Complete Binary Search Tree (30)</a></h2>

<h5>题意</h5>

<p>给定一串数据，要求构建完全二叉搜索树。</p>

<h5>分析</h5>

<p>常规思路：</p>

<ul>
<li>对数据排序</li>
<li>递归的构建二叉搜索树，递归条件为根据有序数组找到子树顶点，顶点位置需要满足完全二叉树的结构。</li>
<li>最后用 queue 输出层序遍历。</li>
</ul>


<p>实现起来需要注意各种边界条件的判定，坑比较多，且代码量比较大（我的参考代码里写了 70 行）。后来<a href="http://weibo.com/redow7">@Redow7</a> 给介绍了一种更有趣的方法：</p>

<ul>
<li>0.对数据排序，等待操作。</li>
<li>1.首先构建好完全二叉树。</li>
<li>2.利用二叉搜索树的中序遍历的有序性，在中序遍历的过程中，将排序好的数据插入其中。</li>
</ul>


<p>如此一来，难点就转移到了构建完全二叉树上。</p>

<p>联想到最大堆的数组实现：父节点坐标为 n 时，左儿子为 2<em>n，右儿子为 2</em>n+1。对的，数组实现的二叉树就是满足完全二叉树的特点的。构建完全二叉树的步骤直接缩减为定义一个一定长度的数组。</p>

<p>于是，使用数组实现的二叉树做迭代的思路就出来了，30 行搞定。</p>

<p>pat1064 源码:<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel/APAT1064.cpp">请戳</a><p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/08/31/pat-1061-pat-1064/'>http://biaobiaoqi.github.com/blog/2013/08/31/pat-1061-pat-1064/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分布式事务slides]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/08/26/distributed-transaction/"/>
    <updated>2013-08-26T23:49:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/08/26/distributed-transaction</id>
    <content type="html"><![CDATA[<p>最近看了<a href="http://book.douban.com/subject/21624776/">《分布式系统概念与设计 第 5 版》</a>的分布式事务章节，整理了一份 ppt。还有恢复部分没有收录进来，有空再整理啦。</p>

<p>下面是传到 deckspeaker 上的 slides 展示:</p>

<script async class="speakerdeck-embed" data-id="aa521420f0a101303be246475d95d052" data-ratio="1.33333333333333" src="http://biaobiaoqi.github.com//speakerdeck.com/assets/embed.js"></script>


<p>下载链接：<a href="https://dl.dropboxusercontent.com/u/64021093/slides/distributed%20transcation.pptx">请戳</a><p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/08/26/distributed-transaction/'>http://biaobiaoqi.github.com/blog/2013/08/26/distributed-transaction/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PAT练习题概览]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/08/03/overcome-pat/"/>
    <updated>2013-08-03T22:20:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/08/03/overcome-pat</id>
    <content type="html"><![CDATA[<p>PAT(<a href="http://pat.zju.edu.cn">pat.zju.edu.cn</a>)是一个面向 C/C++程序的 Online Judge 系统。相比 ZOJ，HDOJ，POJ 等 ACM 题库，PAT 的题目非常基础，对于数据结构、算法的入门是比较有助益的。</p>

<p>本文按照自己的认识，给 PAT advanced level 做出了分类。由于很多题目实际上兼顾有多种解法和思路，我给每道题打上了 tag，来应对分类的独占性局限，供大家参考。</p>

<h2>简单题</h2>

<p>这类题几乎不需要数据结构、算法基础，主要通过简单的逻辑流程和判断实现。</p>

<ul>
<li>1001 A+B</li>
<li>1002 多项式相加</li>
<li>1005 简单 hash</li>
<li>1006 选极值</li>
<li>1008 模拟电梯</li>
<li>1009 多项式乘法</li>
<li>1011 选极值</li>
<li>1019 数字/字符处理</li>
<li>1024 数字/字符处理</li>
<li>1027 数字/字符处理，简单 hash</li>
<li>1031 数字/字符处理</li>
<li>1035 简单 hash<!--more --></li>
<li>1036 选极值</li>
<li>1037 简单模拟</li>
<li>1040 数字/字符处理</li>
<li>1046 数字/字符处理</li>
<li>1050 数字/字符处理</li>
<li>1058 数字/字符处理</li>
<li>1060 数字/字符处理</li>
<li>1061 数字/字符处理，坑题</li>
<li>1063 数字/字符处理，游标</li>
</ul>


<h2>模拟题</h2>

<p>这类题也相对简单，需要使用到一些简单的数据结构或者相对复杂的逻辑流程实现。</p>

<ul>
<li>1022 倒排索引</li>
<li>1023 数字/字符处理</li>
<li>1032 链表</li>
<li>1049 计算数字中的 1</li>
<li>1051 模拟栈</li>
<li>1052 链表</li>
<li>1054 dominant color</li>
<li>1056 模拟分组淘汰赛</li>
</ul>


<h4>排队模拟</h4>

<p>下面三道模拟题是针对排队模型处理的：</p>

<ul>
<li>1014 排队问题</li>
<li>1017 排队问题</li>
<li>1026 排队问题</li>
</ul>


<h4>排序模拟</h4>

<p>这几道模拟题侧重在使用排序方法：</p>

<ul>
<li>1012 排序</li>
<li>1016 排序，模拟电话账单计算</li>
<li>1025 排序</li>
<li>1028 排序</li>
<li>1029 归并排序</li>
<li>1038 递归，排序</li>
<li>1062 排序</li>
</ul>


<h4>时间优化</h4>

<p>这几道题需要做好时间优化才能 ac。</p>

<ul>
<li>1044 搜索，时间优化</li>
<li>1039 倒排索引，hash，时间优化</li>
<li>1047 倒排索引，hash，时间优化</li>
<li>1055 排序，时间优化</li>
</ul>


<h4>素数判定</h4>

<ul>
<li>1015 素数</li>
<li>1059 素数</li>
</ul>


<h2>图</h2>

<ul>
<li>1003 最短路径</li>
<li>1018 最短路径</li>
<li>1030 最短路径</li>
<li>1034 dfs</li>
</ul>


<h2>搜索</h2>

<ul>
<li>1010 二分搜索，优化剪枝</li>
<li>1013 并查集/dfs</li>
<li>1021 并查集，dfs，图的直径</li>
<li>1054 dfs，优化剪枝</li>
</ul>


<h2>树</h2>

<ul>
<li>1004 dfs，树遍历</li>
<li>1020 二叉树遍历</li>
<li>1043 二叉树遍历</li>
<li>1064 重建完全二叉搜索树</li>
</ul>


<h2>Hash</h2>

<ul>
<li>1041 hash</li>
<li>1042 hash</li>
<li>1048 hash</li>
</ul>


<h2>分治</h2>

<ul>
<li>1007 最大子连续序列</li>
</ul>


<h2>贪心</h2>

<ul>
<li>1033 贪心</li>
</ul>


<h2>动态规划</h2>

<ul>
<li>1045 DP，最长递增子序列</li>
</ul>


<h2>树状数组</h2>

<p>树状数组是一种神奇的数据结构，在 1057 题中其神奇的效果得到了很好的体现。</p>

<ul>
<li>1057 树状数组，模拟栈，二分搜索</li>
</ul>


<h2>题解</h2>

<p>截止 2013-08-03，PAT advanced level 的 60 道题全部题解和代码已经发布在本博客中，链接如下：欢迎讨论大家;)</p>

<ul>
<li><a href="http://biaobiaoqi.me/blog/2013/07/31/pat-1001-1010-solutions/">《PAT 1001-1010 题解》</a></li>
<li><a href="http://biaobiaoqi.me/blog/2013/07/31/pat-1011-1020-solutions/">《PAT 1011-1020 题解》</a></li>
<li><a href="http://biaobiaoqi.me/blog/2013/08/01/pat-1021-1030-solutions/">《PAT 1021-1030 题解》</a></li>
<li><a href="http://biaobiaoqi.me/blog/2013/08/01/pat-1031-1040-solutions/">《PAT 1031-1040 题解》</a></li>
<li><a href="http://biaobiaoqi.me/blog/2013/08/01/pat-1041-1050-solutions/">《PAT 1041-1050 题解》</a></li>
<li><a href="http://biaobiaoqi.me/blog/2013/08/01/pat-1051-1060-solutions/">《PAT 1051-1060 题解》</a></li>
<li><a href="http://biaobiaoqi.me/blog/2013/08/31/pat-1061-pat-1064/">《PAT 1061-1064 题解》</a></li>
</ul>


<p>附博客的 PAT 专题区链接：<a href="http://biaobiaoqi.me/tags/pat/">请戳</a><p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/08/03/overcome-pat/'>http://biaobiaoqi.github.com/blog/2013/08/03/overcome-pat/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PAT 1051-1060 题解]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/08/01/pat-1051-1060-solutions/"/>
    <updated>2013-08-01T01:43:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/08/01/pat-1051-1060-solutions</id>
    <content type="html"><![CDATA[<p>浏览全部代码：<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/tree/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel">请戳</a></p>

<p>本文谨代表个人思路，欢迎讨论;)</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1051">1051. Pop Sequence (25)</a></h2>

<h4>题意</h4>

<p>给定 stack 的容量，给定数据的入栈顺序：从 1 开始的正整数序列，在允许随机的出栈操作的情况下，要求判断某出栈序列是否可能。</p>

<p>比如，告知 stack 容量为 5，入栈序列的最大值为 7。有两个序列需要判断合理性：</p>

<ul>
<li>{1 2 3 4 5 6 7}： 这个序列是可能的，只需每次入栈时都做出栈操作。</li>
<li>{3 2 1 7 5 6 4}： 这个序列是不可能的，其中前半部分 3 2 1 是合法的，先将 1 2 3 顺序入栈，然后三次执行出栈操作。而之后的 7 5 6 则是不可能的。</li>
</ul>


<h4>分析</h4>

<p>两种思路：</p>

<h5>第 1 种思路：</h5>

<p>使用 stl 中的 stack 模拟。判定条件有两条：1.栈中数据量不超过栈的容量；2.出栈只能从栈顶取，不应该出现从固定的堆栈中取出其他数据的情况。</p>

<h5>第 2 种思路：</h5>

<p>由于入栈序列数据由小到大排列非常特殊，要通过出栈序列判定可能性是存在简便思路的。
对比分析题中 Sample 给出的序列，结合上面提到的两条冲突条件入手分析：</p>

<ul>
<li><p>1.栈中数据量不超过栈的容量：</p>

<p>  只有在入栈时，才会需要考虑栈中数据是否超量。出栈序列中的每个数，都以为着在出栈操作之前，它刚入栈，
  那么当它入栈的时候能否判定是否超过栈容量呢？可以的，（当前的出栈数值 - 已经执行过的出栈操作数量）就是当前栈中元素的数量。</p></li>
<li><p>2.出栈只能从栈顶取，不应该出现从固定的堆栈中取出其他数据的情况。</p>

<p>  根据观察分析发现，当某数据 m 出栈之后，比 m 小的数据如果在 m 之后出栈的，它们所组成的序列本身需要保持从大到小的顺序排列。
  距离如 3 2 1 7 5 6 4 这个序列，在 7 之后有 5 6 4 这个子序列，它们都大于 7，但却没有保持一个递减的顺序，不合法。</p></li>
</ul>


<p>更多分析参见博文<a href="../../../../2013/07/16/verify-pop-sequence-for-stack/">《出栈序列的可能性判定》</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1052">1052. Linked List Sorting (25)</a></h2>

<h4>题意</h4>

<p>链表的节点被表示为{地址， 值， 下一个指针地址}，其中如果 NULL 的地址表示为-1，
地址为 5 正数，值的范围为[-10<sup>5,</sup> 10<sup>5]。</sup></p>

<p>给定 N(&lt; 10<sup>5)个节点以及其头指针，要求按照每个节点上值的大小重新排序，并按照链表顺序输出每个节点。</sup></p>

<h4>分析</h4>

<p>将链表中的节点按值做 qsort()排序，然后调整每个值的 next 指针即可。需要注意的有：</p>

<ul>
<li>1.INPUT 中的节点并不保证全是链表中的，先需要过滤掉悬空的节点。</li>
<li>2.head 直接指向-1(NULL)的情况需要特殊处理。</li>
</ul>


<!--more-->


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1053">1053. Path of Equal Weight (30)</a></h2>

<h4>题意</h4>

<p>给定一棵树，有 N( &lt;= 100) 个节点，每个节点有一个权重，另给定一个权重值 S(&lt; 230)。要求找到从根节点出发到叶节点的路径上，所有点权重值和等于 S 的所有情况，并按照逆字典序输出。</p>

<h4>分析</h4>

<p>使用邻接表的方式构建树，dfs 搜索，由于需要逆字典序输出，处理前需要对每个节点的儿子节点邻接表进行排序，合理剪枝即可。</p>

<p>需要注意的是：结果路径要求以叶子节点结束。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1054">1054. The Dominant Color (20)</a></h2>

<h4>题意</h4>

<p>给定一个 M(&lt;= 800)*N(&lt;=600)个像素点，每个像素点的范围为 [0, 2<sup>24]，要求找出其中出现次数超过总数量的一半左右的点，称作</sup> restrict dominant color.</p>

<h4>分析</h4>

<p>由于条件比较特殊，使用一个计数器<code>count</code>，一个寄存器<code>color</code>就可以实现对超过一半数目的选项的挑选。过程如下：</p>

<ul>
<li>1.<code>count</code>初始化为 0，<code>color</code>初始化为-1</li>
<li>2.读入新的颜色值<code>newColor</code>，如果<code>newColor</code>跟寄存器的<code>color</code>一样，则计数器<code>count</code>加一。如果不一样，且<code>count</code>不为 0，则<code>count</code>减一；如果不一样，且<code>coun</code>t 为 0，则寄存器中的<code>color</code>被置为<code>newColor</code>。</li>
<li>3.不断循环 2，直到读入所有颜色值。这时候，寄存器<code>color</code>中存储的就是结果。</li>
</ul>


<p>这个方法的巧妙之处，在于寄存器和计数器保存了状态，用抵消的思想，最终得到了较多数量的状态。思考时，不妨假设所有颜色值只有两个，一个是超过一半数量的 restrict dominant color，另一个则是少于一半数量的颜色，经过累加和寄存的操作，少于一半的颜色肯定会被多余一般的颜色抵消掉，最后剩下多于一半的颜色。另外，大家不妨想一下，本题的最后，计数器中的值就是 restrict dominant color 超过其他颜色的数量么？</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1055">1055. The World&#8217;s Richest (25)</a></h2>

<h4>题意</h4>

<p>福布斯排行榜上，给出了 N(&lt;=10<sup>5)个人的名单，每个名单包含了不超过</sup> 8 个字符的姓名，(0,200]的年龄以及[-10<sup>6,10<sup>6]的财富值。</sup></sup></p>

<p>另外，给出了 K(&lt;=10<sup>3)次查询，以及每次查询要求的结果条数</sup> M(&lt;=100)。每次查询给定一个年龄区间，要求查询出这个区间范围内财富排名前 M 的人的名单。如果财富值相同，按姓名字典序排列。</p>

<h4>分析</h4>

<p>这道题时间限制比较严格。有两种思路：</p>

<h5>第 1 种思路：</h5>

<ul>
<li>1.所有年龄做 qsort()排序；</li>
<li>2.分离到不同年轻的人的数组中，此时每个年龄中，都是排序好的。</li>
<li>3.对于每个查询，从 2 中所得数组里进行归并排序，归并的每次比较过程，使用最大堆实现。</li>
</ul>


<h5>第 2 种思路：</h5>

<ul>
<li>1.所有年龄做排序</li>
<li>2.对排序好的年龄，每个年龄计数减掉 100 名之后的人。</li>
<li>3.然后对待查询轮训过滤即可。</li>
</ul>


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1056">1056. Mice and Rice (25)</a></h2>

<h4>题意</h4>

<p>分组淘汰赛背景。给出 Np(&lt;=1000)个参赛者，限定每场比赛最多有 Ng(&lt;=1000)个参赛者参加，如果一轮比赛中，组队的过程单出几个人，也将他们组成一次比赛。每场比赛决出一名胜者，参加到下一轮的淘汰赛中，而同一轮的负者都拥有相同的排名，如此循环往复，直到决出第一。</p>

<p>输入数据中还规定了必须依据顺序分组，而初始顺序体重已经给出。</p>

<h4>分析</h4>

<p>模拟题。用队列存储剩下的参赛队员，每轮比赛做一次循环，直到队列为空。处理一轮比赛时，负者的 rank 等于该轮比赛场次+1.换分组别的时候，需要仔细。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1057">1057. Stack (30)</a></h2>

<h4>题意</h4>

<p>在 stack 的基础上，增加了一个 PeekMedian 操作定义，要求输出 stack 中所有数据的中间大小的数。</p>

<p>题目给出 N(&lt;=10<sup>5)个对</sup> stack 的顺序操作，要求输出操作结果。其中保证每次操作的值不大于 10<sup>5。</sup></p>

<h4>分析</h4>

<p>使用 stl 中的 stack 模拟常规栈操作，关键问题在于中位数的读取。由于时间限制比较严格，使用诸如优先队列等方式会超时。考虑到每次的操作数都不超过 10<sup>5，想到诸如使用</sup> hash 的方式用空间换时间。但即使是开一个<code>int hash[100001]</code>的 hash 表，也只能记录读入的所有数据的次数，无法提供高效的查询操作。实际上，在 hash 方式的前提下，使用<a href="http://dongxicheng.org/structure/binary_indexed_tree/">树状数组</a>能很好的解决这个问题。 （另有一篇详细介绍树状数组的译文:<a href="http://hawstein.com/posts/binary-indexed-trees.html">请戳</a>）</p>

<p>对<code>int hash[100001]</code>建立树状数组，然后通过二分的方式，就可方便的查询到 hash 数组中那个坐标下的统计值处于中间位置，这个坐标的值也就是中位数了。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1058">1058. A+B in Hogwarts (20)</a></h2>

<h4>题意</h4>

<p>给定的数的结构如下：a.b.c，其中 a 的范围是 [0, 10<sup>7]，b</sup> 的范围是 [0,17)，c 的范围是 [0,29)。给定两个数，要求计算他们的和。</p>

<h4>分析</h4>

<p>简单模拟题，有一个坑：题目交代最高位的区间为 [0, 100000000]，但是没说如果两数相加超过这个值怎么办。需要将最高位的结果区间设定为 20000000 以上才 AC。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1059">1059. Prime Factors (25)</a></h2>

<h4>题意</h4>

<p>给定一个正整数，要求格式化输出它的素因数相乘的形式。</p>

<h4>分析</h4>

<p>由于时间限制，不可以简单的重复判定素数。可以使用 DP 的思想做素数的判定。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1060">1060. Are They Equal (25)</a></h2>

<h4>题意</h4>

<p>科学计数法相关背景。假设机器只能存储 3 个有效数字，那么<code>12300</code>和<code>12358.9</code>在机器侠都表达都为<code>0.123*10^5</code>，他们相等。其中有效数字使用简单截尾方式，不进位。</p>

<p>给定两个不大于 10<sup>100</sup> 的非负整数，以及有效位数 N(&lt;=100)，要求计算在对应的精确位数下，两数的表达是否相等。</p>

<h4>分析</h4>

<p>由于非负整数非常大，不可使用 longlong 甚至精确度不高的 double，当做字符串来处理。</p>

<p>需要注意的一点是对值为 0 的情况的处理。比如 0 在有效位数为 3 下的表达为:<code>0.00*10^0</code><p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/08/01/pat-1051-1060-solutions/'>http://biaobiaoqi.github.com/blog/2013/08/01/pat-1051-1060-solutions/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PAT 1041-1050 题解]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/08/01/pat-1041-1050-solutions/"/>
    <updated>2013-08-01T01:43:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/08/01/pat-1041-1050-solutions</id>
    <content type="html"><![CDATA[<p>浏览全部代码：<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/tree/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel">请戳</a></p>

<p>本文谨代表个人思路，欢迎讨论;)</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1041">1041. Be Unique (20)</a></h2>

<h5>题意</h5>

<p>给出 N (&lt;=105)个数（数值范围为 [1, 10<sup>4]），找到其中不重复的第一个数字。比如给出</sup> <code>5 31 5 88 67 88 17</code> ， 答案是 <code>31</code> 。</p>

<h5>分析</h5>

<p>简单模拟题，开一个大数组<code>int a[10001];</code>，以读入的数为下标，记录 count:<code>a[index] ++;</code>。结果输出第一个存储为 1 的下标:<code>if (a[index] == 1)</code>。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1042">1042. Shuffling Machine (20)</a></h2>

<h5>题意</h5>

<p>背景是洗牌机的洗牌过程。过程是给定洗牌的每张牌的位置替换序列，由原来的次序算出最后的牌的平排列。</p>

<p>比如原有的次序为<code>S3, H5, C1, D13, J2</code>，
给定的洗牌顺序为<code>4, 2, 5 ,3 ,1</code>，那么一次洗牌的结果为：<code>J2, H5, D13, S3, C1</code>。
如果需要两次洗牌，则结果为<code>C1, H5, S3, J2, D13</code>。</p>

<p>输入为对一整副牌（54 张）的洗牌策略，以及洗牌次数 N，要求计算出最后的洗牌结果。</p>

<h5>分析</h5>

<p>简单 hash 题。</p>

<!--more-->


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1043">1043. Is It a Binary Search Tree (25)</a></h2>

<h5>题意</h5>

<p>二叉搜索树的定义就不重复了，题目新定义了一个镜像二叉搜索树，就是将一颗二叉搜索树所有节点的左右子树交换后的二叉树。</p>

<p>输入是一个二叉树的前序排列，要求判定是否是一个二叉搜索树或者镜像二叉搜索树。如果是，输出该树后序遍历的序列。</p>

<h5>分析</h5>

<p>解题思路：</p>

<ul>
<li>1.BST 很特殊，实质上 BST 的所有节点的顺序排列就是中序遍历了。</li>
<li>2.要检查树是否是 BST 或者镜像 BST，只需按照重建树的思路，在每次重建的过程中做适当检查即可。检查思路是：检查前序遍历序列中，根节点之后的节点排序是否符合 BST 的二分规则（即前一段都是小于根节点的，后一段都是大于根节点的）。</li>
<li>3.最后的输出是后序遍历。过程中其实并不用构建整个树，直接在处理过程中，按后序的方式存储节点到队列中即可。</li>
</ul>


<p>更多相关分析，参见博文<a href="../../../../2013/04/27/pat1020-pat1043-rebuild-binary-tree/">《根据前中后序和层序重建二叉树》</a>。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1044">1044. Shopping in Mars (25)</a></h2>

<h5>题意</h5>

<p>火星人购物使用钻石链，每颗钻石都有一定的价值。付款是，要求从钻石链上找到所有刚好能匹配到商品价值的连续的钻石子链，如果没有，
则找到超过商品价值的最小的钻石子链。</p>

<p>比如钻石链为<code>3 2 1 5 4 6 8 7</code>，商品价值为<code>15</code>，则候选的方案有：第 4 到第 6 颗的子链<code>5 4 6</code>，第 7 到第 8 颗：<code>8 7</code>。</p>

<p>输入为一个钻石链以及商品的价值，要求找到所有满足条件的分割方案，按起始点从小到大排序输出。</p>

<h5>分析</h5>

<p>由于时间限制有些严格，需要做足够的优化：</p>

<ul>
<li>1.为了便于计算某个区间的累加值，在存储钻石串时，可以在<code>index</code>位置存储包括当前钻石在内的之前所有钻石价值的累加和。</li>
<li>2.使用两层循环遍历所有可能，在遍历以位置 i 为其实坐标的子串时，不应该将结束位置初始化为 i，而是应该是以<code>i-1</code>为起始位置的搜索过程中的 break 时的
结束位置的下标减 1.</li>
</ul>


<p>其中第 2 条的证明如下：</p>

<p>算法中首先计算以<code>i</code>为起始位置的子串的累加值。假定计算到<code>j</code>满足累加值等于或者刚好大于商品价值<code>m</code>。之后，结束以<code>i</code>位置开始的子串的探寻，进入下一阶段以 i+1 为起始位置的搜索。
由于<code>[i, j]</code>的累加和刚好等于<code>m</code>，则<code>[i, j - 1]</code>的累加和肯定小于<code>m</code>，那么<code>[i + 1, j - 1]</code>的累加和也肯定小于<code>m</code>。</p>

<p>综上述，在以<code>i+1</code>为起始位置的搜索中，可以初始化结束位置为上一次搜索结束的位置减一，即<code>j - 1</code>.</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1045">1045. Favorite Color Stripe (30)</a></h2>

<h5>题意</h5>

<p>Eva 对彩色条有特殊的癖好，对于一条五颜六色的彩带，她会减掉其中一些颜色块，让整个彩带的颜色顺序匹配到自己的一个颜色喜好顺序上。</p>

<p>举例来说，她喜欢的颜色顺序为{2 3 1 5 6}，给定的彩带的颜色顺序为{2 2 4 1 5 5 6 3 1 1 5 6}，那么经过她的剪辑，留下的彩带的可能选项有：{2 2 1 1 1 5 6}
{2 2 1 5 5 5 6}，{2 2 1 5 5 6 6}和{2 2 3 1 1 5 6}。</p>

<p>我们的任务是找到其中最长的剪辑可能。</p>

<h5>分析</h5>

<p>这是经典的最长递增子序列问题(LIS)，递增在这里体现为子序列的颜色顺序要遵照 Eva 的对颜色的喜好顺序。使用动态规划解决。</p>

<ul>
<li>1.剔除不在 Eva 喜欢颜色列表中的颜色。</li>
<li>2.DP 的状态： 用<code>length[max]</code>数组存储状态，<code>length[i]</code>表示到彩带的第 i 个位置为止，包含该颜色的符合 Eva 喜好顺序的子串长度的最长值。记得在每次</li>
<li>3.DP 的子问题：<code>length[i]</code>等于在其之前的所有<code>lengths[j]</code>跟<code>i</code>位置颜色组合后的最长子串值。</li>
</ul>


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1046">1046. Shortest Distance (20)</a></h2>

<h5>题意</h5>

<p>给定在圆环上的几个点的相对位置，要求计算不同点之间的距离。</p>

<h5>分析</h5>

<p>简单模拟。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1047">1047. Student List for Course (25)</a></h2>

<h5>题意</h5>

<p>根据每名学生填报的课程，按顺序输出每门课程的学生名单。其中学生总量为 N(&lt;=40000)，课程总量为 K(&lt;=2500)。学生姓名为 3 个大写英文字符加一个数字。</p>

<h5>分析</h5>

<p>倒排索引的模拟。可以针对学生姓名做 hash 方式的优化。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1048">1048. Find Coins (25)</a></h2>

<h5>题意</h5>

<p>给定一系列硬币，以及一个商品的价格。要求从硬币中找到两个硬币让他们的组合等于商品的价格。如果有多个，输出有用最小单个值的硬币组合。</p>

<h5>分析</h5>

<p>首先，硬币中币值不小于商品价格的可以过滤掉。遍历过程中，使用 hash 标记的方法，设定一个<code>coins[MAXVALUE]</code>（其中 MAXVALUE 为商品价格的最大值）记录已有的币值种类，
在遍历的过程中，一边将读入的硬币增加到<code>coins[]</code>中，一边计算满足条件的最小币值。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1049">1049. Counting Ones (30)</a></h2>

<h5>题意</h5>

<p>给定一个正整数 N(&lt;=2<sup>30)，要求计算所有小于</sup> N 的正整数的各个位置上，1 出现的次数之和。</p>

<h5>分析</h5>

<p>比较有思维难度的一题，核心在于找规律。10ms 的时间限制表明了不能用常规的循环遍历来解决。需要从简单的 case 找规律，逐步扩大到常规的情况。</p>

<p>详情参见《编程之美》P132 页《1 的数目》。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1050">1050. String Subtraction (20)</a></h2>

<h5>题意</h5>

<p>给定两个字符串，S1 和 S2,要求将 S2 中的字符从 S1 串中剔除。</p>

<h5>分析</h5>

<p>用 Hash 的方式标记需要剔除的字符。<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/08/01/pat-1041-1050-solutions/'>http://biaobiaoqi.github.com/blog/2013/08/01/pat-1041-1050-solutions/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PAT 1031-1040 题解]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/08/01/pat-1031-1040-solutions/"/>
    <updated>2013-08-01T01:43:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/08/01/pat-1031-1040-solutions</id>
    <content type="html"><![CDATA[<p>早期部分代码用 Java 实现。由于 PAT 虽然支持各种语言，但只有 C/C++标程来限定时间，许多题目用 Java 读入数据就已经超时，后来转投 C/C++。浏览全部代码：<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/tree/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel">请戳</a></p>

<p>本文谨代表个人思路，欢迎讨论;)</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1031">1031. Hello World for U (20)</a></h2>

<h5>题意</h5>

<p>将给定的字符串打印出 U 型。</p>

<p>比如给定<code>helloworld</code>，打印出</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>h  d
</span><span class='line'>e  l
</span><span class='line'>l  r
</span><span class='line'>lowo
</span></code></pre></td></tr></table></div></figure>


<p>设定左边的字符个数为 n1,底边字符个数为 n2,右边字符个数为 n3。需要满足 n1 = n3 = max
{k|k &lt;= n2 for all 3 &lt;= n2 &lt;= N} with n1 + n2 + n3 -3 = N.</p>

<h5>分析</h5>

<p>简单模拟题。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1032">1032. Sharing (25)</a></h2>

<h5>题意</h5>

<p>为了节省存储空间，单词使用链表实现。比如对于<code>loading</code>和<code>being</code>两个单词，有如下存储结构：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>word1 : -&gt; [l] -&gt; [o] -&gt; [a] -&gt; [d]  
</span><span class='line'>                                  \
</span><span class='line'>                                    [i] -&gt; [n] -&gt; [g] -&gt; null
</span><span class='line'>                                  /
</span><span class='line'>word2 : -&gt; [b] -&gt; [e] -------------
</span></code></pre></td></tr></table></div></figure>


<p>输入中，指定了两个单词的首字符的地址，并给出了 N (&lt;= 10<sup>5)个节点，每个节点包含：物理地址（5</sup> 位的正整数），实际存储的字符以及指向的下一个节点的地址。NULL 的地址是-1.
要求找到两单词的的公共后缀开始的地址，如果没有，则输出-1.</p>

<h5>分析</h5>

<p>既然是单词，它的长度应该是有限的，也就是链表不会出现环这种情况（实际上这里的处理方式对于有环无环都适用）。对第一个单词链表做遍历，对爬过的节点做好标记。第二个单词链表也同样做标记，一旦遇到已经标记过的节点，则该节点就是结果。</p>

<p>需要注意一点：直接使用 map 做节点的存储最后一个 case 会超时。而鉴于 5 位正整数的数据量，可以直接使用数组，用空间换时间。</p>

<!--more-->


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1033">1033. To Fill or Not to Fill (25)</a></h2>

<h5>题意</h5>

<p>高速路从 A 地到 B 地，路途有许多加油站，每个加油站的油价不一样，要求计算一个最优方案，使得以最便宜的开销跑完全程。</p>

<h5>分析</h5>

<p>用贪心算法，理清贪心算法的策略：</p>

<ul>
<li>1.从 A 加油站出发，在能行走的最大范围内，如果有比 A 站汽油更便宜的 B 站，则保证在 A 站点的加油量刚好满足能到达 B 站点；如果没有比 A 站汽油更便宜的站，则在 A 加满车油行走到【从 A 能走出的范围内】油价【最便宜】的站上，再行计算。</li>
<li>2.从 A 加油站出发，在能行走的最大范围内，如果没有其他站点，则 A.dist + 一次最大的行走距离 为 impossible 情况下的最大站点。</li>
</ul>


<p> 注意有个陷阱：如果没有距离为 0 的加油站，则无法行驶。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1034">1034. Head of a Gang (30)</a></h2>

<h5>题意</h5>

<p>『gang』翻译过来是『一伙人』。gang 的定义是一群人，至少有 3 个人，这群人中每个人之间都通过通话相连，且整个群体的通话时长超过一个阈值。整个 gang 的团体中，拥有的电话时长最长的人就是头目了。</p>

<p>题目给定了 gang 的阈值 K，以及 N 个通话记录，每条记录包括主叫人、被叫人以及通话时间。要求计算出有几个 gang，并按照 gang 的头目的字母顺序排序输出头目和其中成员数量。</p>

<h5>分析</h5>

<p>本题使用 dfs 求解比较方便。dfs 能简单的实现状态值的记录，比如当前的 gang 的成员数量和权重，如果使用并查集，则相对复杂。</p>

<p>需要注意的坑点：如果建立邻接表时，每个通话记录都在两人头上计算了时间积累的，那么在判定 gang 的权重值是否低于阈值的时候，需要对阈值乘以 2。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1035">1035. Password (20)</a></h2>

<h5>题意</h5>

<p>给定多个字符串，按要求替换其中的某些特殊字符，并按原顺序输出。如果字符串中没有需要修改的字符，则不舒服该字符串。</p>

<h5>分析</h5>

<p>简单的 hash 实现。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1036">1036. Boys vs Girls (25)</a></h2>

<h5>题意</h5>

<p>输入是一批学生的成绩，要求找出其中男生最低的成绩和女生最高的成绩，求其间的差值。如果无法计算，则输出 NA.</p>

<h5>分析</h5>

<p>简单模拟题。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1037">1037. Magic Coupon (25)</a></h2>

<h5>题意</h5>

<p>背景是火星上的神奇的购物券购物策略：每张购物券上有一个整数，可正可负，商店里商品的标价也是一个整数，可正可负的。如果用正值购物券购买正值商品，则可获利两者之积；如果以负值购物券购买负值商品，也可获利两者之积；但其他情况，则会亏损。比如用面值为<code>2</code>的购物券购买面值为<code>3</code>的商品，获利<code>6</code>，用面值为<code>-5</code>的购物券购买面值为<code>-9</code>的商品，获利<code>45</code>，但如果用面值为<code>2</code>的购物券购买面值为<code>-3</code>的商品，则亏损<code>6</code>，</p>

<p>给定一组数量为 NC 购物券面值和一组数量为 NP 的商品面值，1&lt;= NC , NP &lt;= 10<sup>5，要求计算能获利的最大值。</sup></p>

<h5>分析</h5>

<p>同号相乘可获利，异号相乘会亏损。要使获利最大，使用贪心思想计算。实际上，不需要用完购物券或者买完商品，所以只需要将同号的数值乘积算出即可，没有更复杂的情况。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1038">1038. Recover the Smallest Number (30)</a></h2>

<h5>题意</h5>

<p>给定 N(&lt;= 10000)个不超过 8 位的非负整数，要求将其按某个顺序拼接为一个数，使其值最小。</p>

<h5>分析</h5>

<p>容易简单的以为使用字典序排列拼接，实际上有一个特殊的拼接情况需要考虑。</p>

<p>比如数据<code>32 321 3214</code>，这是按字典序排列的，但实际上这并不是最小的拼接方式，最小的拼接方式是：<code>321 3214 32</code>。</p>

<p>比较这个实例，不难找到最小拼接的排序规律：</p>

<ul>
<li>1.两个字符串做比较时，如果其中一个字符串(a)是另一个字符串(ab)的前缀串，则需要将较长字符串(ab)除去前缀串的部分(b)与较短字符串(a)继续递归比较。比如，321 和 32，需要拿 1 和 32 做比较。又比如 323 和 32 比较，第一次拿 3 和 32 比较，第二次拿 3 和 2 按字典序比较。</li>
<li>2.其他情况按字典序比较。</li>
</ul>


<p>另外需要注意的一个坑是：如果没有数据，则输出 0。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1039">1039. Course List for Student (25)</a></h2>

<h5>题意</h5>

<p>给出 K(&lt;=2500)门课程，每门课程有 Ni(&lt;=200)名学生，学生编号为四位字符串，前三位为小写英文字母，后一位是数字。另给出 N 个需要查询的学生编号。</p>

<p>要求列出对应查询编号学生的课程。如果有多个课程，需要按升序输出。</p>

<h5>分析</h5>

<p>这个题是个倒排索引的实现。不过在时间上卡的比较严。</p>

<p>使用最简单的思路：map&lt;string, vector<int> students 倒排索引，在没有输出排序的课程列表时最后一个 case 已经超时；优化：将学生姓名的 hash 为 int，减免了 string 的匹配过程，还是超时（map 本身用红黑树实现，效率并不是特别高，还需要对每组数据进行排序），只能改变使用 map 的方式。</p>

<p>最终 AC 的解法是：</p>

<ul>
<li>构建一个从学生编号字符串到 int 值的 hash 函数，在读入学生编号后，hash 到 int 值做处理。</li>
<li>不适用 map 结构，根据学生姓名的限制，设定一个<code>vector&lt;int&gt; st[26*26*26*10]</code>的数据结构，读入时直接倒排索引插入。</li>
</ul>


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1040">1040. Longest Symmetric String (25)</a></h2>

<h5>题意</h5>

<p>给定一个字符串，要求输出最长的连续对称子串的长度。比如给定字符串为<code>Is PAT&amp;TAP symmetric?</code>，其中最长对称子串为<code>s PAT&amp;TAP s</code>，所以输出结果 11.</p>

<h5>分析</h5>

<p>这个题就是典型的 Java 实现 timeout，而 Cpp 实现轻松过的类型。需要注意两点：</p>

<ul>
<li>1.有两种对称情况，一种形如<code>aba</code>，一种形如<code>abba</code>。</li>
<li>2.循环遍历的过程，以 index 为对称中心向两边扩散比较编码实现简单也更高效。</li>
</ul>


<p>另外，C 读入一整行数据到 char 数组的方法可以用<code>gets(s);</code>。</p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/08/01/pat-1031-1040-solutions/'>http://biaobiaoqi.github.com/blog/2013/08/01/pat-1031-1040-solutions/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PAT 1021-1030 题解]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/08/01/pat-1021-1030-solutions/"/>
    <updated>2013-08-01T01:43:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/08/01/pat-1021-1030-solutions</id>
    <content type="html"><![CDATA[<p>早期部分代码用 Java 实现。由于 PAT 虽然支持各种语言，但只有 C/C++标程来限定时间，许多题目用 Java 读入数据就已经超时，后来转投 C/C++。浏览全部代码：<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/tree/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel">请戳</a></p>

<p>本文谨代表个人思路，欢迎讨论;)</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1021">1021. Deepest Root (25)</a></h2>

<h5>题意</h5>

<p>无环连通图也可以视为一棵树，选定图中任意一点作为根，如果这时候整个树的深度最大，则称其为 deepest root。
给定一个图，按升序输出所有 deepest root。如果给定的图有多个连通分量，则输出连通分量的数量。</p>

<h5>分析</h5>

<p>算法实现的步骤如下：</p>

<ul>
<li>1.使用并查集判断图是否为连通的。</li>
<li>2.任意选取一点，做 dfs 搜索，选取其中一个最远距离的点 A，再做一次 dfs，找到的所有距离最远的点以及点 A 都是 deepest root。</li>
</ul>


<p>判定图是否连通使用 union-find set 即可。更关键的点在于找到 deepest root。实际上，使用两次 dfs 就可以实现。
证明之前，先介绍两个概念，一个是直径，树的 deepest root 到最远叶子的路径我们暂称直径，而 deepest root 和最远叶子节点则成为端点。
注明关键在于以下两点：</p>

<ul>
<li><p>从任意一个点 dfs 得到的最远点都是直径的端点。证明如下：</p>

<p>  任意选一点 A，做 dfs 查找距离 A 最远的点，因为是 dfs，所以肯定会经过某直径上的点 B，从 B 出发最远的点是直径上的端点 C。
  那么，这个端点 C 为何一定是 A 的最远居里点呢？可以反证证明，如果有一个点 D，A->D 不经过直径，且 length(A->D) > length(A->C)，
  那么，从 C 所在直径上构造出经过 D 的比原直径更长的直径，得证。</p></li>
<li><p>所有的树的直径都交于一点（或者公用段路径上的几点）。
于是，从 B 点 dfs 出发的所有最长距离的点即为 deepest root。证明如下：</p>

<p>  如果两条直径不相交，而树上任意两点肯定连通，则从两直径上，可以选取两点连通以组成更长的直径；如果三条直径相较于不同的两点，也可以根据相交截断的长度组合出更长的直径。</p></li>
</ul>


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1022">1022. Digital Library (30)</a></h2>

<h5>题意</h5>

<p>给定 N (&lt;=10000) 本书的信息，包括 7 位 ID，最多 80 字符的书名，最多 80 字符的作者名，
多个最多 10 字符的关键词，最多 80 字符的出版商和属于 [1000, 3000]的出版时间。
另给出 M (&lt;=1000) 的查询请求，按照查询格式分为：</p>

<ul>
<li>1: 书名</li>
<li>2: 作者</li>
<li>3: 关键词</li>
<li>4: 出版商</li>
<li>5: 年份</li>
</ul>


<p>输出查询结果。如果有多个结果，按照书的 ID 的升序排列。</p>

<h5>分析</h5>

<p>简单模拟题。在使用 Map 结构来构建倒排索引的过程中，可以讨巧的避免根据不同查询类型使用两层 map，
直接通过在 key 中增加查询标记来实现。另外 C++的 priority_queue 支持对常规数据类型的最小堆实现：<code>priority_queue&lt;string, vector&lt;string&gt;, greater&lt;string&gt;&gt;</code>，方便了结果输出。</p>

<!--more-->


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1023">1023. Have Fun with Numbers (20)</a></h2>

<h5>题意</h5>

<p>给出一个 20 位的正整数，要求计算其乘以 2 的值，并判定结果的数值是否是原数字所有位数打乱的结果。结果输出 Yes 或 No，以及乘以 2 以后的数字。</p>

<h5>分析</h5>

<p>判重使用 Hash 思想。过程如下：</p>

<ul>
<li>1.原数字按字符串读入，并在一个 int hash[10]的 hash 数组中标记每个数值出现的次数，比如如果出现了四次 1，则 hash[1]=4。</li>
<li>2.模拟实现乘以 2 的简单乘法过程，没计算出一位的值，在 hash[]中对应位置上减一。</li>
<li>3.最后通过判定 hash 是否全为 1 和最后结果是否有进位来做判定。</li>
</ul>


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1024">1024. Palindromic Number (25)</a></h2>

<h5>题意</h5>

<p>非回文数可以通过将它与它的倒转数相加，并不断迭代这一过程获得回文数的结果。比如 67 经过两次处理就得到了 484：
<code>67 + 76 = 143, and 143 + 341 = 484.</code></p>

<p>给定一个数和迭代的次数，判断能否在迭代次数内获得回文结果。</p>

<h5>分析</h5>

<p>简单模拟题，处理数字，做逻辑判断。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1025">1025. PAT Ranking (25)</a></h2>

<h5>题意</h5>

<p>以 PAT 考试为背景，给所有人做排名。给定的数据包括 N(&lt;=100)为赛区的数目，每个赛区的人数以及每个人的分数。
按照总排名、分区号、注册号的优先级排名。</p>

<h5>分析</h5>

<p>简单模拟题，使用 qsort()排序，注意相同分数的人应该拥有相同的排名。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1026">1026. Table Tennis (30)</a></h2>

<h5>题意</h5>

<p>乒乓球俱乐部有 K 张乒乓球桌，其中有 M 张是 VIP 桌。有很多人到俱乐部打球，如果桌子都满了，多余的人只能排队等待。</p>

<p>有一个特殊的 VIP 制度：如果有空的 VIP 桌，那么等待队列中的第一对 VIP 会员可以使用这张卓，
如果等待队列中没有 VIP 会员，那么一般会员也可以使用 VIP 桌。当轮到 VIP 上的时候，没有 VIP 桌子，那么 VIP 用户也可以使用一般的桌子。</p>

<p>另外，每张桌服务一对会员的时间最大限制在两个小时。</p>

<p>给定了乒乓球桌的数量 M(编号为 1-M)，其中 VIP 卓的数量 K，并指定是那几张桌子。给出来乒乓球俱乐部的 N 对会员的信息，每对会员有一个达到时间，
是否是 VIP 的标记以及打球的时间。要求计算出每对会员的等待时间，以及每张桌服务过的次数。</p>

<h5>分析</h5>

<p>排队模拟题。有两种思路：</p>

<ul>
<li>1.主体循环处理人。将乒乓球桌和人都当做资源，乒乓球桌对应记录了 available 的时间，每次取出 available 最早的时间，从等待队列中选
则最早的会员使用乒乓球桌。其中 vip 处理逻辑为：如果 available 并列最早的桌子中有 vip 桌，则看等待队列中有没有 vip 会员，
如果有则直接处理他，否则按照正常逻辑处理。每次将某会员安置到一个乒乓球桌上，则可以输出该会员的等待时间的结果信息，并将该乒乓球桌的
服务人数增加一。</li>
<li>2.主体循环是时间。这样需要模拟同一时刻所有的乒乓球桌以及等待队列，相对比较复杂。</li>
</ul>


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1027">1027. Colors in Mars (20)</a></h2>

<h5>题意</h5>

<p>给定三个十进制数，要求格式化输出其 13 进制表达。</p>

<h5>分析</h5>

<p>简单的数字处理和 hash 实现。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1028">1028. List Sorting (25)</a></h2>

<h5>题意</h5>

<p>模拟 Excel 中按列排序。N (&lt;=100000) 为数据条数，每条数据由三列组成：ID，姓名，成绩。C 可以等于 1,2,3，分别对应到按三列中的哪一列排序。
输出排序结果。</p>

<h5>分析</h5>

<p>简单排序题。两种思路：</p>

<ul>
<li>1.简单的直接使用 qsort()实现。</li>
<li>2.自己手写排序算法，比如二叉搜索树实现。</li>
</ul>


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1029">1029. Median (25)</a></h2>

<h5>题意</h5>

<p>给定两个已排序的整数序列，求出两组数的集合里中间大小的数。</p>

<h5>分析</h5>

<p>使用归并排序思路实现。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1030">1030. Travel Plan (30)</a></h2>

<h5>题意</h5>

<p>给定加权图，每条边有两种权值：一是路径长度，二是开销。要求求出给点两点间的最短路径，如果路径长度一样，则要求比较选择开销最小的路径。</p>

<h5>分析</h5>

<p>使用 Dijkstra 算法的变形，增加一个权重的判定，可以轻松解决。<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/08/01/pat-1021-1030-solutions/'>http://biaobiaoqi.github.com/blog/2013/08/01/pat-1021-1030-solutions/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PAT 1011-1020 题解]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/07/31/pat-1011-1020-solutions/"/>
    <updated>2013-07-31T23:41:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/07/31/pat-1011-1020-solutions</id>
    <content type="html"><![CDATA[<p>早期部分代码用 Java 实现。由于 PAT 虽然支持各种语言，但只有 C/C++标程来限定时间，许多题目用 Java 读入数据就已经超时，后来转投 C/C++。浏览全部代码：<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/tree/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel">请戳</a></p>

<p>本文谨代表个人思路，欢迎讨论;)</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1011">1011. World Cup Betting (20)</a></h2>

<h5>题意</h5>

<p>给定一个 3*3 的矩阵，找到每行的最大值，格式化输出一个运算结果。</p>

<h5>分析</h5>

<p>非常简单的模拟题。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1012">1012. The Best Rank (25)</a></h2>

<h5>题意</h5>

<p>给定学生的学号和三个科目的分数，查询输出对应学生单门科目排名和总分排名中最高的那个排名。</p>

<h5>分析</h5>

<p>C 里 stdlib.h 中的 qsort()和 C++里 algorithm 中的 sort()函数都能实现快排，应对编程题中的排序一般比自己手写的要快。
分别为三个单科和总分做排序，并将 rank 值记录到 map 结构中去，便于之后的查找。</p>

<p>需要注意并列排名的情况。比如<code>1 2 2 4</code>，由于并列第 2 的都两人，那之后的那个人就是第 4 而不是第 3 了。</p>

<p>另外，由于有多个需要分别排序、排名的项，抽象出公共逻辑到一个函数里比较必要，否则代码分散难于 debug 和维护。
这里稍微特殊点的用法是使用了<a href="http://blog.csdn.net/dyx1024/article/details/7562786">函数指针</a>做参数。</p>

<!--more-->


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1013">1013. Battle Over Cities (25)</a></h2>

<h5>题意</h5>

<p>给定一张图和指定几个点。针对给出的每个点，要求计算，在除掉连接该点的路径的情况下，保证整个图连通所需要添加的边的数量。</p>

<h5>分析</h5>

<p>计算保证整个图连通需要几个点，亦即求出图中有几个连通分量。两种思路：</p>

<ul>
<li>1.并查集</li>
<li>2.DFS</li>
</ul>


<p>针对每个点，执行算法的过程中，需要注意去除掉该点对应的所有通路。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1014">1014. Waiting in Line (30)</a></h2>

<h5>题意</h5>

<p>这道题是排队模拟题。银行有 N 个窗口，每个窗口允许排队 M 个人，如果 N 个窗口占满了排队的人，更多的人需要在黄线外等待。
每个人都会选择尽可能人少的窗口排队，如果有多个窗口等待队列一样长，则选择编号小的窗口。
前 N 个用户设定在 8:00 开始接受服务。给定了 K 个用户所需要接受服务的时间长度，要求在这个排队模型下，每个人的完成处理的时间点。</p>

<h5>分析</h5>

<p>相对另外几个队列模拟题，这个题是很简单的。没有达到时间的差异，只需要不断的从等待队列中取出人员即可。
当然，由于黄线内等待的每个窗口都有 M 人，所以必须单独的模拟每个窗口。
可以使用 queue 模拟每个窗口，循环遍历下次离开窗口的人，继而从等待队列中补上。
需要注意结束条件，如果 17:00 以后还没有开始接受服务，则不用再等待。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1015">1015. Reversible Primes (20)</a></h2>

<h5>题意</h5>

<p>Reversible Primes 是指在某个进制下，一个数本身和它翻转过来形成的新数都是素数。
题中给出多组数据，以负数结尾程序。每组数据包含一个数以及一个进制数。判定该数是否是 Reversible Primes.</p>

<h5>分析</h5>

<p>两个功能点实现：判定素数和特定进制下的数据倒转。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1016">1016. Phone Bills (25)</a></h2>

<h5>题意</h5>

<p>给出一天中每个不同的小时内的电话付费标准，给出一份分为打出和挂断两种记录的通话记录，包括记录发生的时刻和用户名字，
要求整理出当月有效用户的账单，输出格式中需要输出所有的通话记录，包括开始时刻和结束时刻，每次通话的话费以及总计的话费。</p>

<h5>分析</h5>

<p>模拟题。首先对输入的通话记录按照先姓名后时间做 qsort()排序，然后遍历排序后的记录，找到合适的匹配对，计算每次通话的时间，并进行统计和输出。</p>

<p>实现的难点主要有两个：</p>

<ul>
<li>1.在排序后的记录中，找到合适的配对。如果某人的通话记录为<code>1.on;2.on;3.off;</code>，则其中<code>1.on</code>将被抛弃，匹配到<code>2.on;3.off;</code>。
题中仅仅保证了所有记录中至少有一对有效记录，但并没有保证每个人都有有效通话记录，所以还需要做好过滤，
如果某人没有有效通话记录，则不输出。整体的控制流程需要谨慎。</li>
<li>2.由于不同时刻的话费不一样，计算一次有效通话的话费比较复杂。可以采用的方式是用起始时刻分阶段追赶结束时刻。追赶的过程分阶段，也就能计算好不同阶段的开销，
先将起始时间调整到跟结束时间为同一天，细节是先让分钟达到 0，再让小时迭代到 0，天进位，一直迭代到跟结束时间同天；再让起始时刻的小时数追平
结束时刻；最后让分钟追平。以此计算出最终话费。</li>
</ul>


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1017">1017. Queueing at Bank (25)</a></h2>

<h5>题意</h5>

<p>银行有 K 个窗口，所有到达银行的人都应该在黄线外等待，直到有窗口空余。
每个窗口对单个客人最多服务时间为 1 小时。N 个用户的到达时间和需要处理的时间给出。
8:00 到 17:00 接受服务，逾期不服务，也不计入统计数据。要求格式化输出用户的平均等待时间。</p>

<h5>分析</h5>

<p>又一道排队模拟题。相比 PAT1014，此题更复杂在于用户的到达时间是不确定的。
首先使用 qsort()按照到达时间对所有人排序。由于每个窗口同时只有一个人在处理，所以窗口之间没有差异，可以用 priority_queue 建立一个队列，
模拟所有 K 个窗口。
优先队列将结束时间最早的人放到队列的顶端，每次循环处理一个人的结束。然后步入一个黄线外等待的人。如果那个时刻，下一个人还没有达到，则可以将该人开始执行的时间记录为他的到达时间，并加入队列中。
还有一点需要注意的：HH:MM:SS 的时间格式，可以转换为累积秒数的时间，方便计算比较。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1018">1018. Public Bike Management (30)</a></h2>

<h5>题意</h5>

<p>以杭州的公用自行车站点管理为背景。每个站点是一个节点，每个节点上最多停放 Cmax 辆自行车，Cmax/2 为节点的最佳状态。不同节点间距离不同，整个构成了一张带权无向图。要求从起始点（公用自行车管理中心）出发，去目的地维护目的地节点的车辆状态，如果车辆低于 Cmax/2，则给它添加车辆到 Cmax/2 辆，如果多于 Cmax/2，则去除掉几辆车。同时，在去往目的地的过程中，也需要调整所有沿途站点的车辆（这里题目没有交代清楚，实际测试是只能在去往目的地的途中调整，回来的途上不可调整）。求到给定目的地的最短路径，如果有多条最短路径，则按照 1.从管理中心送出的车辆越少越好；2.拿回到管理中心的车越少越好的优先级找到结果。</p>

<h5>分析</h5>

<p>题目的大体框架是有权最短路径问题。步骤如下：</p>

<ul>
<li>1.使用 Dijkstra 找到最短路径，其中注意记录每个节点在最短路径中的【所有】前驱节点；</li>
<li>2.使用 DFS 的方法，得到所有的最短路径。</li>
<li>3.计算每条最短路径的带出和带回的车辆数量。</li>
</ul>


<p>其中 DFS 时，归纳所有答案的过程比较通用，需要掌握。</p>

<p>另外值得注意的是，类比到 PAT1003，该题采用了直接对每个节点增加状态记录的方式，直接得到最优解，而不是先找到最短路径，然后计算比较。本题是无法用这种方法实现的，需要送出和带回的自行车数量无法直接在 Dij 算法中每个节点的计算中体现，并不是前面的节点带回和送出的车辆越少，后面的节点就一定能得到更优解。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1019">1019. General Palindromic Number (20)</a></h2>

<h5>题意</h5>

<p>给定一个十进制数和一个进制，要求计算出在给定进制下的表达并判定是否为回文。</p>

<h5>分析</h5>

<p>简单的数字处理。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1020">1020. Tree Traversals (25)</a></h2>

<h5>题意</h5>

<p>根据二叉树的后序遍历和中序遍历，求层序遍历。</p>

<h5>分析</h5>

<p>具体实现方式：</p>

<ul>
<li>初始：用后序遍历序列确定根节点，在中序遍历序列中找到该根节点，则左右子树分别为中序中该节点左右的序列。</li>
<li>迭代：对各个子树分别执行三步操作，1.在后序序列中找子树的根节点；2。在中序序列中找子树的根节点，并划分开根节点的左右子树；3.根据新生成的左右子树，在后序序列中划分开这些节点，从而得到了两颗子树的后序、中序序列。</li>
</ul>


<p>有一个结论：中序遍历配合另外任何一个遍历，能重建二叉树。其他的任意两个序列的组合都不能唯一的确定重建的二叉树。具体分析参见博文<a href="../../../../2013/04/27/pat1020-pat1043-rebuild-binary-tree/">《根据前中后序和层序重建二叉树(PAT1020、PAT1043)》</a>。</p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/07/31/pat-1011-1020-solutions/'>http://biaobiaoqi.github.com/blog/2013/07/31/pat-1011-1020-solutions/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PAT 1001-1010 题解]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/07/31/pat-1001-1010-solutions/"/>
    <updated>2013-07-31T02:03:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/07/31/pat-1001-1010-solutions</id>
    <content type="html"><![CDATA[<p>早期部分代码用 Java 实现。由于 PAT 虽然支持各种语言，但只有 C/C++标程来限定时间，许多题目用 Java 读入数据就已经超时，后来转投 C/C++。浏览全部代码：<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/tree/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel">请戳</a></p>

<p>本文谨代表个人思路，欢迎讨论;)</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1001">1001. A+B Format (20)</a></h2>

<h5>题意</h5>

<p>格式化输出两数之和。</p>

<h5>分析</h5>

<p>理清输出逻辑即可。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1002">1002. A+B for Polynomials (25)</a></h2>

<h5>题意</h5>

<p>给定两多项式，相加并格式化输出结果。</p>

<h5>分析</h5>

<p>两种思路</p>

<ul>
<li>1.采用链表的处理方式；</li>
<li>2.预设好 int[1005]的数组，用下标表示次方，数组中元素值表示对应系数。</li>
</ul>


<p>第一种方法某种程度上看能节省空间，实现上需要注意操作链表时，循环时的越界问题；
方法二用空间换取时间，且实现上更不容易出错。同时，由于浮点数本身精确位数不够，在判定两浮点数相加是否为 0 时，
需要对结果值取绝对值后，与 1e-6 做对比。</p>

<!--more-->


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1003">1003. Emergency (25)</a></h2>

<h5>题意</h5>

<p>求两个城市之间的加权最短路径。在有多个最短路径记录的情况下，选择路径中所有节点的权重值之和最小的。</p>

<h5>分析</h5>

<p>Dijkstra 算法的变型实现。两种思路：</p>

<ul>
<li>1.计算最短路时，在每个节点上用链表 preList 记下所有最短路径的前节点。
完成计算后，对 preList 做 dfs 获得每条最短路径的权重值之和，比较后得到结果；</li>
<li>2.计算最短路径时，在节点上，除了记录最短路径中前一个节点 preNode 之外，还对应的记录当前的最短路径上所有节点的权重值之和，
这就不用在 Dij 完成之后再做 dfs 了，过程中已经找到了最优解。</li>
</ul>


<p>相比之下，方法 2 明显更简洁。当然，虽然方法 2 的思路很通用，还需要确定，这一加权的判定条件是能够迭代处理的。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1004">1004. Counting Leaves (30)</a></h2>

<h5>题意</h5>

<p>计算给定的树各个层级叶子节点的个数</p>

<h5>分析</h5>

<p>先构建树，鉴于题目的空间限制不严格，可以使用邻接矩阵的方式定义树结构。然后使用 dfs 遍历树的节点，并记录每层的叶子节点数量。
可以看到，时间空间的 trade-off 不仅仅是性能上的提升，也会影响带代码实现的复杂程度。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1005">1005. Spell It Right (20)</a></h2>

<h5>题意</h5>

<p>计算一个数（&lt;=10<sup>100）的各个位数之和，并用英语按位输出。比如</sup> 15 输出为 one five.</p>

<h5>分析</h5>

<p>简单题，输出的实现上实际上就用到了 Hash 思想。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1006">1006. Sign In and Sign Out (25)</a></h2>

<h5>题意</h5>

<p>每个人来到实验室和离开实验室的时间都有记录。找到其中最早来实验室和最晚离开实验室的时间。</p>

<h5>分析</h5>

<p>逻辑上很简单的一个题，遍历所有数据，找到其中最大和最小的值即可。稍微要处理的就是时间。
由于 input 中给出的是 HH:MM:SS 的格式，在比较时需要将其换算为 int 值。实际上，使用 C 语言读入更方便，<code>scanf("%d:%d:%d", &amp;h, &amp;m, &amp;s);</code>
然后计算出<code>time = 3600*h + 60*m + s</code>，时间比较就没有问题了。在最终的输出时再做对应的转换即可。
而在 Java 语言中，使用到了 String 的 split 方法划分子串和 Integer.parseInt()转 String 为 int。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1007">1007. Maximum Subsequence Sum (25)</a></h2>

<h5>题意</h5>

<p>给出一组由正负整数组成的序列，求出拥有最大和的连续子序列。</p>

<h5>分析</h5>

<p>最暴力的算法是两个循环的 O(n<sup>2)；进一步要使用分治的思想，可以得到</sup> O(n*logn)；更好的方法可以达到 O(n)，也可以将它看做分治思想。关键在于数学归纳的证明，编程实现非常简单：假定 [0, n-1]的最大连续子串已经求出了，要求 [0,n]的最大连续子串。</p>

<ul>
<li>1.如果 [0, n-1]中最大子串不包含最右的数字，则判定<code>原最大子串的和</code>与<code>包含最右点的最大子串 + a[n]的和</code>的大小。取大的那个作为 [0, n]的最大子串，并保持一个<code>包含最右点的最大子串</code>。</li>
<li>2.如果 [0, n-1]中最大子串包含最右的数字，则 [0, n]的最大子串为原最大子串+a[n]。</li>
</ul>


<p>实际上，算法的核心是维持了两个量的记录，即当前的<code>最大子串</code>，以及当前<code>包含最右点的最大子串</code>。</p>

<p>更多讨论参见博文<a href="../../../../2013/04/05/maximum-subsequence-sum/">《分治、时间空间的权衡:最大合的连续字串问题 (PAT 1007)
》</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1008">1008. Elevator (20)</a></h2>

<h5>题意</h5>

<p>给出电梯的行进路径，上下的速度和每层停留时间，计算总时间。</p>

<h5>分析</h5>

<p>简单的模拟题。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1009">1009. Product of Polynomials (25)</a></h2>

<h5>题意</h5>

<p>求两个多项式的乘积。</p>

<h5>分析</h5>

<p>参见 PAT1002，使用数组存储虽然空间占用稍大，但比链表实现要便捷很多。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1010">1010. Radix (25)</a></h2>

<h5>题意</h5>

<p>给定两个数，其中单个位置上的数值范围可以为 [0-z]。指定其中一个数的进制，试确定是否存在可能的进制让两数的实际值相等。</p>

<h5>分析</h5>

<p>此题没有交代清楚 input 中 radix 的取值范围以及对一位数有多重可能 radix 的情况如何输出，坑比较大。下面是需要注意的点。</p>

<ul>
<li>1.input 中两个数字可以是 10 位数，虽然没有告诉 radix 的范围，但在<code>9*10^10 10 1 200</code>这个示例中，可以看到结果的 radix 也可以是很大的。从这个角度看，代码中将 radix 和两个数值都设定为 longlong 是合适的选择。</li>
<li>2.在计算另一个数的 radix 时，简单的遍历 [2, 10<sup>18]会超时。单调的区间很自然想到使用二分查找。</sup></li>
<li>3.二分查找的上下界确定能减少耗时：下界选数字的所有位上的最大值+1；上界容易想当然的认为就是题中给定了 radix 的数的值。实际上，示例<code>11 b 1 10</code>就是一个反例，原因在于这个假设忽略了一位数的可能性，解决方案是在取给定 radix 的数值和下界中较大的那个数。</li>
<li>4.在二分查找时，不可直接计算出某个 radix 下数的值，因为可能会 longlong 溢出。于是需要用特定的 compare 函数，在累加的过程中判定是否大于另一个数。算是一种剪枝。</li>
<li>5.还有一个条件：当两个数都是 1 时，输出 2.当两个数相等且不为 1 时，输出题中给出的 radix。（这是从其他人的结题报告中看到的，完全不理解=。=）</li>
</ul>


<p>注意好这些方面，应该能 ac 了。保重。</p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/07/31/pat-1001-1010-solutions/'>http://biaobiaoqi.github.com/blog/2013/07/31/pat-1001-1010-solutions/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[终于算完了这道『1+1』]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/07/29/after-pat-practice/"/>
    <updated>2013-07-29T22:12:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/07/29/after-pat-practice</id>
    <content type="html"><![CDATA[<p>在<a href="http://weibo.com/redow7">@ReDow</a>、<a href="http://weibo.com/cloudbye">@麦迪的小腿</a>和<a href="http://weibo.com/linest">@linest</a> 等小伙伴的帮助下，终于断断续续的爬完了 <a href="http://pat.zju.edu.cn/">PAT</a> 的 Basic Level 和 Advanced Level，阶段性填补了自己惨白的算法短板。在 cs 的圈子里，说 PAT 是入门的『1 + 1』不为过。刚完成『1 + 1』，作为五年科班的人，确实不够光彩。不过现在能做的也只是尽力弥补本科时间里的虚度。</p>

<p>从亲手挖的坑里往外爬，需要付出比其他人更多的努力。没时间享受题目 ac 之后的快感（画外音：这么简单的题会有快感么=.=#），倒会时不时蹦出一股脑的蛋疼：『你当初干 XX 啥去了！』。</p>

<h2>当初&#8230;</h2>

<p>记得大一的时候，每天花好几个小时泡图书馆看各种 IT 杂志和技术书籍。在刚开始学 C 语言编程的时间里，我看着中间件、系统软件、终端融合、东软和用友金蝶之争等一系列摸不着头脑的东西，在对数据还没概念的时候，看着数据库的范式和 E-R 图…总之，就是一直在门外徘徊。</p>

<p>之后专业课多了起来，我又兴高采烈的混在工高大神的队伍里，早上集结同学每天早上五点多轮流爬起来去自习室占座，以看似端正实则不专注的令人发指的学习态度在 GPA 榜单上持续退步着。浑浑噩噩的搞过数模，无果。当然，以『学渣』的水平充着『学霸』也是有好处的，就是沾染了大神的精神气，比如记忆犹新的有在 CMU 念书的鑫磊大神的专注、冷静和每天 4 小时的睡眠。同时，我还风风火火的参加了 ASES 和求是强鹰，搀和着所谓的创业。大四在爱尔兰的交流，除了英语和专业课，其他的倒是学的挺多，比如烧饭，单反和旅游……本科唯一做的跟编程有关的说得出口的，也就写了个 Android 程序在比赛里获了个奖，不提也罢的那种。</p>

<h2>变</h2>

<p>在《<a href="http://book.douban.com/subject/1048007/">高效能认识的七个习惯</a>》里看过一个观点：每个人都有属于自己的『关注圈』和『影响圈』。影响圈是个人对外界产出的途径，关注圈则意味着个人对外界的期许。可以想见，关注圈大于影响圈。正确的成长方式是尽力扩大影响圈，以此催生关注圈的扩大。而我则是走在了相反的方向：一直致力于开发自己的关注圈，后果是影响圈不见长进。一度我开始注意遏制自己这方面的好高骛远，不过事实证明，我还是比较喜欢在学爬得时候看走路的教学视频。</p>

<!--more-->


<p>后来听闻了杨绛先生的一则小事。大概是说，一个年轻人写信给杨绛，说自己平时许多问题想不明白，想请教下怎么应对。杨绛回复说『是你看书太少，想的太多』。第一眼看到这个故事，我的想法就是：那不是在说的我么。对我而言，『书』指的更泛一些，理解为阅历或许更恰当。让可能性禁锢了思想，不值得，不如踏出去，自己去找答案。</p>

<p>研究生的一年又过去，很难说我这一年达到了自己的预期。不过也没怎样，世界变化这么快，也容不得静态的计划。至少，我渐渐的逼近了自己喜欢的生活节奏。</p>

<h2>信仰</h2>

<p>都说现在的国人根子里没有信仰，年岁越长也渐渐有些自己的体会。面对远超过 big-data 量级的选择，我时常彷徨，我不敢说自己有信仰。我只是一直在坚持找寻。</p>

<p>用乔老爷子著名的斯坦福演讲中的一句话结束：</p>

<blockquote><p>You can&#8217;t connect the dots looking forward. You can only connect them looking backwards, so you have to trust that the dots will somehow connect in your future. You have to trust in something&#8211;your gut, destiny, life, karma,whatever&#8211;because believing that the dots will connect down the road will give you the confidence to follow your heart, even when it leads you off the well-worn path, and that will make all the difference.</p></blockquote>

<h3>PS：</h3>

<p>据我所知网上的资料没有对 PAT 题型整体的把握和讲解。接下来的时间，我会整理下自己的代码和解题思路，将整理结果放到博客上来，也算自己的复习。链接都准备好了：<a href="http://biaobiaoqi.me/blog/2013/08/03/overcome-pat/">《PAT 练习题概览》</a>。如果是 404Error，就请再耐心等待几天吧;)</p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/07/29/after-pat-practice/'>http://biaobiaoqi.github.com/blog/2013/07/29/after-pat-practice/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[阿里离线数据处理平台2013暑期学校]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/07/19/odps-in-alibaba/"/>
    <updated>2013-07-19T21:31:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/07/19/odps-in-alibaba</id>
    <content type="html"><![CDATA[<p>本周有幸参加了为期两天的<a href="http://102.alibaba.com/competition/dataSummer.htm">阿里离线数据处理平台 2013 暑期学校</a>的学习。</p>

<p>阿里的前辈们分不同的专题给大家介绍了飞天平台上的离线数据处理服务 ODPS（Open Data Processing Service）。
内容上主要分为两部分，一部分是平台架构，一部分是数据分析。来听课的同学也就分为了两部分，而像我一样关注系统层面的人是少数。</p>

<p>这也正常，用赵本山在『一代宗师』里的话来说，一个是面子，一个是里子。数据分析能直接产生表现层的数据，而系统平台则只是提供支持。
成功了，大家看得到的是分析出的数据，而一旦失败了，那么系统平台的责任就大了。
再者越贴近硬件层次的工作也注定越辛苦，深夜被吵醒也不是没有的事儿。好了，吐槽到此结束，下面是总结笔记整理出几页 slides：</p>

<script async class="speakerdeck-embed" data-id="e0022eb0d24d013089506e9621fcaf9a" data-ratio="1.33333333333333" src="http://biaobiaoqi.github.com//speakerdeck.com/assets/embed.js"></script>




<!--more-->


<p>ppt 下载链接：<a href="https://speakerdeck.com/biaobiaoqi/odps-learning-summary">请戳我</a></p>

<p>三巨头 BAT 都自主研发过大数据平台，另外两家在投入大量资金后面对困难最终关闭了项目，而阿里坚持了下来。通过了解 ODPS 的系统架构，可以看但工业界的系统和学术圈中提出的概念的差异。这也让我更清晰了之后自己的学习路线。</p>

<p>非常感谢阿里暑期学校给予的这次机会来接触飞天系统，非常感谢各位讲师的介绍，特别是杨少华大哥对我的疑惑的耐心解答。<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/07/19/odps-in-alibaba/'>http://biaobiaoqi.github.com/blog/2013/07/19/odps-in-alibaba/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[出栈序列的可能性判定]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/07/16/verify-pop-sequence-for-stack/"/>
    <updated>2013-07-16T01:32:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/07/16/verify-pop-sequence-for-stack</id>
    <content type="html"><![CDATA[<h2>问题说明</h2>

<p><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1051">PAT1051</a>：给定 stack 的容量，给定数据的入栈顺序：从 1 开始的正整数序列，在允许随机的出栈操作的情况下，要求判断某出栈序列是否可能。</p>

<p>比如，告知 stack 容量为 5，入栈序列的最大值为 7。有两个序列需要判断合理性：</p>

<ul>
<li><code>1 2 3 4 5 6 7</code>： 这个序列是可能的，只需每次入栈时都做出栈操作。</li>
<li><code>3 2 1 7 5 6 4</code>： 这个序列是不可能的，其中前半部分<code>3 2 1</code>是合法的，先将<code>1 2 3</code>顺序入栈，然后三次执行出栈操作。而之后的<code>7 5 6</code>则是不可能的。</li>
</ul>


<p>要完成判定过程，常规思路是直接使用的 stack 数据结构模拟出栈序列做操作，然后判定是否会触犯条件。但考虑到 PAT1051 中时间限制只有 10ms，虽然常规方法是线性的，似乎也无法保障（事实证明是错误的，用常规方法也能在 PAT 上 AC），我想到从序列本身的特性入手，找规律，于是有了一种效率更高的判定逻辑。</p>

<h2>常规思路</h2>

<p>直接使用出栈序列指导 stack 模拟操作。判定条件有两条：</p>

<ul>
<li>1.栈中数据量不超过栈的容量。</li>
<li>2.出栈只能从栈顶取，不应该出现从固定的堆栈中取出其他数据的情况。</li>
</ul>


<p>算法描述如下：</p>

<p>用游标记录当前已知压栈的最大数据 cur。如果新的读入数据 tmp（即出栈序列中的某数据）大于 cur，则将 cur 到 tmp 之间的数据顺序压入栈中，更新 cur 并执行检查 1；如果新的读入数据 tmp 小于 cur，则一定是直接出栈获得的，执行检查 2。</p>

<p>如果能顺利完成就是合理的，如果操作过程违背了一些规则，则判定为不合理。C++实现代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include&lt;stdio.h&gt;</span>
</span><span class='line'><span class="cp">#include&lt;stack&gt;</span>
</span><span class='line'><span class="k">using</span> <span class="k">namespace</span><span class="o">::</span><span class="n">std</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">cur</span><span class="p">;</span>
</span><span class='line'><span class="kt">bool</span> <span class="n">flag</span><span class="p">;</span>
</span><span class='line'><span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d %d %d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">);</span>
</span><span class='line'>    <span class="k">while</span><span class="p">(</span><span class="n">k</span> <span class="o">--</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">flag</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>        <span class="n">cur</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>        <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;</span> <span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">cur</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">tmp</span><span class="p">;</span> <span class="o">++</span> <span class="n">j</span><span class="p">)</span>
</span><span class='line'>                    <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">)</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>                <span class="n">cur</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">()</span> <span class="o">!=</span> <span class="n">tmp</span><span class="p">)</span>
</span><span class='line'>                    <span class="n">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;YES</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="k">else</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;NO</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>更高效的判定逻辑</h2>

<p>实际上，在 PAT1051 的环境下，由于入栈序列数据由小到大排列非常特殊，要通过出栈序列判定可能性是存在简便思路的。</p>

<p>对比分析题中 Sample 给出的序列，结合上面提到的两条冲突条件入手分析：</p>

<ul>
<li><p>1.栈中数据量不超过栈的容量：</p>

<p>  只有在入栈时，才会需要考虑栈中数据是否超量。出栈序列中的每个数，都以为着在出栈操作之前，它刚入栈，那么当它入栈的时候能否判定是否超过栈容量呢？可以的，（当前的出栈数值 - 已经执行过的出栈操作数量）就是当前栈中元素的数量。</p></li>
</ul>


<!--more-->


<ul>
<li><p>2.出栈只能从栈顶取，不应该出现从固定的堆栈中取出其他数据的情况。</p>

<p>  根据观察分析发现，当某数据 m 出栈之后，比 m 小的数据如果在 m 之后出栈的，它们所组成的序列本身需要保持从大到小的顺序排列。距离如<code>3 2 1 7 5 6 4</code>这个序列，在<code>7</code>之后有<code>5 6 4</code>这个子序列，它们都大于<code>7</code>，但却没有保持一个递减的顺序，不合法。</p></li>
</ul>


<p>C++实现代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include&lt;stdio.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">max</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">tmp</span><span class="p">;</span>
</span><span class='line'><span class="kt">bool</span> <span class="n">flag</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d %d %d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">);</span>
</span><span class='line'>    <span class="k">while</span><span class="p">(</span><span class="n">k</span> <span class="o">--</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">flag</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>        <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>        <span class="n">min</span> <span class="o">=</span> <span class="mi">1001</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">-</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">)</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>                <span class="k">else</span> <span class="n">max</span> <span class="o">=</span> <span class="n">min</span><span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span> <span class="n">tmp</span> <span class="o">&gt;</span> <span class="n">min</span><span class="p">)</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>                <span class="k">else</span> <span class="n">min</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;YES</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="k">else</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;NO</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>总结</h2>

<p>在我的理解之中，经典的算法、数据结构是在面对编程问题的解决过程中所抽象出的通用模型。而生活是多变的，并不像考试卷一样简单的套用数学题所能解决，很多情况下，编程问题也是如此。那么除了这些经典的方法外，认真分析条件，并进行针对性的优化甚至重新设计就非常重要了。这里仅仅是一个小实践。</p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/07/16/verify-pop-sequence-for-stack/'>http://biaobiaoqi.github.com/blog/2013/07/16/verify-pop-sequence-for-stack/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给博客签上CC协议]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/07/10/cc-license/"/>
    <updated>2013-07-10T22:37:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/07/10/cc-license</id>
    <content type="html"><![CDATA[<p>大家都知道开源软件。通过开放源代码的方式，允许用户学习、修改、增进提高这些软件质量。软件界的开源协议很多，比如常见的 Apache，BSD，GPL 等等。这是一种充分利用网络的便利性，鼓励分享和创新的协议潮流。从这个层面上来说，Creative Commons 也是如此。</p>

<p>这是一个非营利性组织，也是一种创作的授权方式。简称 CC 协议，中国大陆正式名称为知识共享。次组织的主要宗旨是增加创意作品的流通可及性，作为其他人据以创作及共享的基础，并寻找适当的法律以确保上述理念。</p>

<h2>CC 协议的起源</h2>

<p>Creative Commons 最先是 2002 年的 12 月 16 号在美国首次发布的。这个协议最初是根据美国版权法设计出来的。技术的发展，网络的发展，出现了开放共享的需求，而传统的作品保护的模式，对作品的使用和内容的开放带来一些限制。怎么样满足这种需求，同时又尊重权利人的著作权？传统的保护模式不能实现这样的作用，它可能关注于保护的时候可能忽略了对公众的，尤其网络环境下对知识文化这样分享的需求。CC 协议的设计实际上是基于这样一种大的背景，在这样一个大的网络环境下应运而生，它是来倡导一种合法的分享。</p>

<h2>CC 协议内容</h2>

<p>CC 协议可以分为四个部分。每个部分对使用者有不同程度的限定。</p>

<ul>
<li><p>1.署名（BY）：作品上必须附有作品的归属。如此之后，作品可以被修改，分发，复制和其它用途。</p></li>
<li><p>2.非商业性使用（NC）：作品可以被修改、分发等等，但不能用于商业目的。</p></li>
<li><p>3.禁止演绎（ND）：这意味着你可以复制和分发它们，但你不能以任何方式修改它们，或基于它们进行二次创作。</p></li>
<li><p>4.相同方式共享（SA）：作品可以被修改、分发或其它操作，但所有的衍生品都要置于 CC 许可协议下。</p></li>
</ul>


<p>实际使用时，需要对这四种条件分别作出约束。不同的条件共有 16 种组合方式，其中有的组合方式互斥，简化后剩下了 6 种常用协议：</p>

<h5>署名（BY）</h5>

<p>此协议最为宽松，只需署名，其他无约束。</p>

<h5>署名（BY）-禁止演绎（ND）</h5>

<p>署名的同时，不得对作品进行改动。但可以用于商业或非商业用途。</p>

<h5>署名（BY）-非商业性使用（NC）</h5>

<p>署名的同时，可以修改作品，但不能用于商业用途。</p>

<h5>署名（BY）-非商业性使用（NC）-禁止演绎（ND）</h5>

<p>署名，且不得用于商业用途和修改。</p>

<h5>署名（BY）-非商业性使用（NC）-相同方式共享（SA）</h5>

<p>署名，不能商用，但可以演绎，且演绎后的内容必须是同样的共享方式。</p>

<h5>署名（BY）-相同方式共享（SA）</h5>

<p>署名，可以商用，可以演绎，但演绎后的作品必须是同样的共享方式。</p>

<!--more-->


<h2>国内的现状</h2>

<p>昨天，为了防止其他网站的不经允许无署名的转载行为，我刚给所有的文章末尾添加了原文链接信息。</p>

<p>实际上，在中国，这种侵犯著作权的行为非常泛滥。有的网站，甚至就致力于爬其他社区产生的优质数据，并直接复制到自己的网页上，以图在网络世界中获得更高的收益。在大数据的时代，越来越多的数据会在网络上产生，会很容易的在网络间流动。这种侵犯著作权的行为将破坏整个互联网信息流动的环境，阻碍社会进步。原有的著作权管理法定条纹相对守旧，面对互联网环境，本身也是水土不服的。CC 协议的重要性不言而喻。</p>

<h2>博客的实践</h2>

<p>我想在我的博客中采纳 BY-NC-ND 协议。其对应的许可协议网络版链接如下：<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh</a></p>

<p>只需要在在<a href="http://biaobiaoqi.github.com/blog/2013/07/10/decorate-octopress/">昨天的修改</a>基础上，替换 html 内容，即可得到一个签署了 BY-NC-ND 协议的展示结果。具体需修改<code>octopress/plugins/post_footer_filter.rb</code>文件：</p>

<p>1.在文件头加上 utf-8 编码标记，以支持中文。</p>

<p>2.搜索定位到<code>post.content + %Q</code>一行，将内容修改为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">post</span><span class="o">.</span><span class="n">content</span> <span class="o">+</span> <span class="sx">%Q[&lt;p class=&#39;post-footer&#39;&gt;&amp;nbsp;</span><span class="si">#{</span><span class="n">pre</span> <span class="ow">or</span> <span class="s2">&quot;原文地址：&quot;</span><span class="si">}</span><span class="sx">&lt;a href=&#39;</span><span class="si">#{</span><span class="n">post</span><span class="o">.</span><span class="n">full_url</span><span class="si">}</span><span class="sx">&#39;&gt;</span><span class="si">#{</span><span class="n">post</span><span class="o">.</span><span class="n">full_url</span><span class="si">}</span><span class="sx">&lt;/a&gt;&lt;br/&gt;&amp;nbsp;版权声明：自由转载-非商用-非衍生-保持署名| &lt;a href=&#39;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&#39;&gt;Creative Commons BY-NC-ND 3.0&lt;/a&gt;&lt;/p&gt;]</span>
</span></code></pre></td></tr></table></div></figure>


<h3>参考</h3>

<ul>
<li><a href="http://zh.wikipedia.org/zh-cn/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6">开源软件 wiki</a></li>
<li><a href="http://www.awflasher.com/blog/archives/939">五种开源协议的比较(BSD,Apache,GPL,LGPL,MIT) – 整理</a></li>
<li><a href="http://www.baike.com/wiki/CC%E5%8D%8F%E8%AE%AE">CC 协议互动百科</a></li>
<li><a href="http://creativecommons.net.cn/2009/11/30/prof-wang-interview-at-hudong/">王春燕教授做客互动百科谈 CC</a></li>
<li><a href="http://www.aqee.net/a-short-guide-to-open-source-and-similar-licenses/">开源软件许可协议简介</a></li>
</ul>


<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/07/10/cc-license/'>http://biaobiaoqi.github.com/blog/2013/07/10/cc-license/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[定制Octopress]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/07/10/decorate-octopress/"/>
    <updated>2013-07-10T01:53:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/07/10/decorate-octopress</id>
    <content type="html"><![CDATA[<p>在 github pages 上搭建好 octopress 博客之后，博客的基本功能就能使用了。如果想自己定制也是没问题的，octopress 有较详尽的官方文档，原则上有问题求助官方即可：<a href="http://octopress.org/help/">octopress-help</a>。官方没有包纳的也可以去询问 <a href="http://stackoverflow.com/questions/tagged/octopress">stackoverflow</a>。 当然，中文的看起来总会省事儿点。我做了如下一些总结;)</p>

<p>不会 ruby 的童鞋特别注意：配置_ config.yml 的过程中特别注意，配置项『:』后要留空格，否则会报错。</p>

<p>另外，一些『土方法』可能并不利于程序的维护可扩展，有空再仔细研究，大家将就着用吧;).</p>

<h2>0.安装第三方主题</h2>

<p>之所以把这一点标记为 0，是因为在博主刚刚经历了博客主题的更新后，惨烈的发现需要重新配置包括评论、百度统计在内的不少东西。</p>

<p>应该是自己在做定制化的过程中乱修改源码（这是一种很不可取维护方式，使软件难以持续扩展）造成的，又或者 octopress 框架本身对定制化扩展的支持比较弱（对 ruby 不熟，对 octopress 也一知半解，我不确定是不是这个原因）。</p>

<p>简而言之，初接触 octopress 的朋友们，建议先安装第三方主题，再参考以下定制方法。</p>

<p>我使用的第三方主题是<a href="https://github.com/gehaxelt/CSS-WhiteLake">『whitelake』</a>。</p>

<p>安装过程很简单:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd octopress
</span><span class='line'>$ git clone https://github.com/gehaxelt/CSS-WhiteLake.git .themes/whitelake
</span><span class='line'>$ rake install['whitelake']
</span><span class='line'>$ rake generate</span></code></pre></td></tr></table></div></figure>


<p>注意，执行<code>rake install['whitelake']</code>之后，直接使用<code>rake preview</code>浏览网页会遇到很多瑕疵，<code>rake generate</code>之后再<code>rake preview</code>就没问题了。</p>

<p>更多第三方插件和主题资源，参见<a href="https://github.com/imathis/octopress/wiki">官方 repo 的 wiki</a>.</p>

<h2>1.装饰边栏</h2>

<p>以增加豆瓣展示框为例。参加正反反长大哥的博客 <a href="http://icodeit.org/2012/10/how-to-embed-douban-show-in-your-octopress-site/">How to Embed Douban-Show in Your Octopress Site</a></p>

<h2>2.增加评论和分享功能</h2>

<p>虽然 octopress 内置的 disqus 评论系统很不错，但在国内的使用并不普及。相比之下，友言、多说等第三方评论则更接地气，可以利用到微博、人人等 SNS 账号。</p>

<h3>2.1 友言</h3>

<p>本博客采用了友言。首先注册<a href="http://www.uyan.cc/">友言</a>的账号，如果不注册，虽然也能实现评论功能，但没有后台管理整个站点的评论会十分纠结。注册完成之后，选择获取代码，将这串代码贴入相应的位置，即可实现第三方评论。</p>

<p>在路径<code>$OCTOPRESS/source/_includes/post/</code>上创建文件<code>youyanandjiathis.html</code>，功能代码放入其中。</p>

<h3>2.2 加网</h3>

<p>分享方面，本博客使用了<a href="http://www.jiathis.com/getcode/icon">加网</a>。注册后，在更多高级自定义功能中，可能自定义不同的分享按钮，生成代码后，也将生成的代码贴入<code>$OCTOPRESS/source/_includes/post/youyanandjiathis.html</code>中。</p>

<p>现在，youyanandjiathis.html 的样子如下(需要注意，自己使用时，uid 显然是不一样的啦)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="c">&lt;!-- JiaThis Button BEGIN --&gt;</span>
</span><span class='line'><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;jiathis_style_32x32&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>  <span class="nt">&lt;a</span> <span class="na">class=</span><span class="s">&quot;jiathis_button_qzone&quot;</span><span class="nt">&gt;&lt;/a&gt;</span>
</span><span class='line'>  <span class="nt">&lt;a</span> <span class="na">class=</span><span class="s">&quot;jiathis_button_tsina&quot;</span><span class="nt">&gt;&lt;/a&gt;</span>
</span><span class='line'>  <span class="nt">&lt;a</span> <span class="na">class=</span><span class="s">&quot;jiathis_button_tqq&quot;</span><span class="nt">&gt;&lt;/a&gt;</span>
</span><span class='line'>  <span class="nt">&lt;a</span> <span class="na">class=</span><span class="s">&quot;jiathis_button_weixin&quot;</span><span class="nt">&gt;&lt;/a&gt;</span>
</span><span class='line'>  <span class="nt">&lt;a</span> <span class="na">class=</span><span class="s">&quot;jiathis_button_renren&quot;</span><span class="nt">&gt;&lt;/a&gt;</span>
</span><span class='line'>  <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">&quot;http://www.jiathis.com/share?uid=1814751&quot;</span> <span class="na">class=</span><span class="s">&quot;jiathis jiathis_txt jtico jtico_jiathis&quot;</span> <span class="na">target=</span><span class="s">&quot;_blank&quot;</span><span class="nt">&gt;&lt;/a&gt;</span>
</span><span class='line'>  <span class="nt">&lt;a</span> <span class="na">class=</span><span class="s">&quot;jiathis_counter_style&quot;</span><span class="nt">&gt;&lt;/a&gt;</span>
</span><span class='line'><span class="nt">&lt;/div&gt;</span>
</span><span class='line'><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;text/javascript&quot;</span><span class="nt">&gt;</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">jiathis_config</span> <span class="o">=</span> <span class="p">{</span><span class="nx">data_track_clickback</span><span class="o">:</span><span class="s1">&#39;true&#39;</span><span class="p">};</span>
</span><span class='line'><span class="nt">&lt;/script&gt;</span>
</span><span class='line'><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;text/javascript&quot;</span> <span class="na">src=</span><span class="s">&quot;http://v3.jiathis.com/code/jia.js?uid=xxxxxx&quot;</span> <span class="na">charset=</span><span class="s">&quot;utf-8&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
</span><span class='line'><span class="c">&lt;!-- JiaThis Button END --&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="c">&lt;!-- UY BEGIN --&gt;</span>
</span><span class='line'><span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">&quot;uyan_frame&quot;</span><span class="nt">&gt;&lt;/div&gt;</span>
</span><span class='line'><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">&quot;text/javascript&quot;</span> <span class="na">src=</span><span class="s">&quot;http://v2.uyan.cc/code/uyan.js?uid=xxxxxxxx&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
</span><span class='line'><span class="c">&lt;!-- UY END --&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>2.3 将功能增加到博客中</h3>

<p>功能代码已经都在 youyanandjiathis.html 中了，接下来是让 blog 使用到这些功能代码。</p>

<p>首先在_ config.yml 中增加开关：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1">#comment and share                                                                                    </span>
</span><span class='line'><span class="n">comment_and_share</span><span class="p">:</span> <span class="kp">true</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后在<code>$OCTOPRESS/source/_includes/post/sharing.html</code>中的，根据开关<code>comment_and_share</code> 引入对应的功能代码<code>post/youyanandjiathis.html</code>，类比于默认实现中的<code>&lt;facebook_like&gt;</code>部分。代码如下（使用时，先去掉反斜杠）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'>  \{\% if site.comment_and_share \%\}
</span><span class='line'>      \{\% include post/]youyanandjiathis.html \%\}
</span><span class='line'>  \{\% endif \%\}
</span></code></pre></td></tr></table></div></figure>


<h3>2.4 友言验证</h3>

<p>另外，需要在友言的后台处理评论，甚至做一些定制化处理，需要通过友言的验证。详情在友言的管理员后台可见。</p>

<h2>3.定制域名</h2>

<p>如果你拥有自己的域名，可以 CNAME 到 github pages 上。以我的配置为例（我的域名为<code>biaobiaoqi.me</code>）。</p>

<p>1.在 octopress 的 source 目录下创建 CNAME 文件，并输入新域名：biaobiaoqi.com</p>

<p>2.在域名管理中，创建或修改 A 记录，指向 207.97.227.245 这个地址。</p>

<p>3.创建 CNAME 记录，www.biaobiaoqi.com -> biaobiaoqi.github.com</p>

<p>这一过程可能需要好几天才能生效，请耐心等待:)</p>

<h2>4.让博客中连接在新窗口打开</h2>

<p>由于 markdown 不支持这一语法，如果要自己用 html 标签实现，又有些违背了 markdown 以内容为重的立意。</p>

<p>参考博文<a href="http://www.blogjava.net/lishunli/archive/2013/01/20/394478.html">《在 Octopress 中为 markdown 的超链接加上 target=&#8221;_blank&#8221;》</a>，可以通过将如下代码添加到 {OCTOPRESS_HOME}/source/_includes/custom/head.html 文件末尾来实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="o">&lt;</span><span class="nx">script</span> <span class="nx">type</span><span class="o">=</span><span class="s2">&quot;text/javascript&quot;</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kd">function</span> <span class="nx">addBlankTargetForLinks</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;a[href^=&quot;http&quot;]&#39;</span><span class="p">).</span><span class="nx">each</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
</span><span class='line'>
</span><span class='line'>      <span class="nx">$</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;target&#39;</span><span class="p">,</span> <span class="s1">&#39;_blank&#39;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="nx">$</span><span class="p">(</span><span class="nb">document</span><span class="p">).</span><span class="nx">bind</span><span class="p">(</span><span class="s1">&#39;DOMNodeInserted&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">addBlankTargetForLinks</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="err">/script&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>5.列表的排版</h2>

<p>默认情况，所有文字的排头会对齐，但如果有列表项的情况下也如此，列表头就会冲出文章的主体区块了。</p>

<p>在 octopress/sass/custom/_layout.scss 文件中找到#$indented-lists: true 行，去掉#注释即可。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">$indented</span><span class="o">-</span><span class="nx">lists</span><span class="o">:</span> <span class="kc">true</span>
</span></code></pre></td></tr></table></div></figure>




<!--more-->


<h2>6.404ERROR 页面</h2>

<p>在 ocotopress/source 目录下，增加 404.markdown，并做出自定义的呃编辑。本博客使用了腾讯公益 404，推荐大家使用，为社会贡献一分正能量。<a href="http://www.qq.com/404/">公益 404</a></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="o">---</span>
</span><span class='line'>
</span><span class='line'><span class="nx">layout</span><span class="o">:</span> <span class="nx">page</span>
</span><span class='line'>
</span><span class='line'><span class="nx">title</span><span class="o">:</span> <span class="s2">&quot;404 Error&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="nx">date</span><span class="o">:</span> <span class="mi">2013</span><span class="o">-</span><span class="mi">4</span><span class="o">-</span><span class="mi">21</span> <span class="mi">02</span><span class="o">:</span><span class="mi">35</span>
</span><span class='line'>
</span><span class='line'><span class="nx">comments</span><span class="o">:</span> <span class="kc">false</span>
</span><span class='line'>
</span><span class='line'><span class="nx">sharing</span><span class="o">:</span> <span class="kc">false</span>
</span><span class='line'>
</span><span class='line'><span class="nx">footer</span><span class="o">:</span> <span class="kc">false</span>
</span><span class='line'>
</span><span class='line'><span class="o">---</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">script</span> <span class="nx">type</span><span class="o">=</span><span class="s2">&quot;text/javascript&quot;</span> <span class="nx">src</span><span class="o">=</span><span class="s2">&quot;http://www.qq.com/404/search_children.js&quot;</span> <span class="nx">charset</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="o">&gt;&lt;</span><span class="err">/script&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>7.在侧边栏增加标签云(tag cloud)</h2>

<p>octopress 默认只有分类，没有标签。这对于博文的组织和管理很不友好。有人开源出了自己定制的 tag 生成和 tag cloud 展现的代码，可以引入到自己的博客中来。</p>

<p>详细操作参见博文：<a href="http://codemacro.com/2012/07/18/add-tag-to-octopress/">《为 octopress 添加 tag Cloud》</a>。不过博文中没有讲解标签云的 UI 配置参数的使用，为了让 UI 适应页面，请参考原作者的官方说明:<a href="https://github.com/robbyedwards/octopress-tag-cloud">octopress-tag-cloud</a>。我所实践出的较合理的参数值如下</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1">#注意，下面一行的 escape 反斜杠在正常使用时需要去掉</span>
</span><span class='line'><span class="p">\{\</span><span class="o">%</span> <span class="n">tag_cloud</span> <span class="n">font</span><span class="o">-</span><span class="ss">size</span><span class="p">:</span> <span class="mi">70</span><span class="o">-</span><span class="mi">180</span><span class="sx">%, limit: 15,</span> <span class="ss">order</span><span class="p">:</span> <span class="nb">rand</span><span class="p">,</span> <span class="ss">style</span><span class="p">:</span> <span class="n">para</span>  <span class="p">{</span> <span class="o">&amp;</span><span class="n">nbsp</span> <span class="p">}\</span><span class="o">%</span><span class="p">\}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果想将文章分类（category）也放在侧边栏，可以参考这篇博文：<a href="http://paz.am/blog/blog/2012/06/25/octopress-category-list-plugin/">《Octopress - Category List Plug-in》</a></p>

<h2>8.在顶栏增加标签云页面 tab</h2>

<p>1.生成新网页</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">rake</span> <span class="n">new_page</span><span class="o">[</span><span class="s2">&quot;tag-cloud&quot;</span><span class="o">]</span> <span class="c1">#在 octopress/source/中将生成 tag-cloud/文件夹</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.在顶栏增加新页面</p>

<p>修改<code>source/_includes/custom/navigation.html</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">&lt;</span><span class="n">ul</span> <span class="n">class</span><span class="o">=</span><span class="s2">&quot;main-navigation&quot;</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s2">&quot;/&quot;</span><span class="o">&gt;</span><span class="err">首页</span><span class="o">&lt;</span><span class="sr">/a&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s2">&quot;/blog/categories/tech/&quot;</span><span class="o">&gt;</span><span class="err">技术</span><span class="o">&lt;</span><span class="sr">/a&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s2">&quot;/blog/categories/life/&quot;</span><span class="o">&gt;</span><span class="err">生活</span><span class="o">&lt;</span><span class="sr">/a&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s2">&quot;/blog/categories/book/&quot;</span><span class="o">&gt;</span><span class="err">读书</span><span class="o">&lt;</span><span class="sr">/a&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s2">&quot;/tag-cloud/&quot;</span><span class="o">&gt;</span><span class="err">标签云</span><span class="o">&lt;</span><span class="sr">/a&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s2">&quot;/about&quot;</span><span class="o">&gt;</span><span class="err">关于</span><span class="o">&lt;</span><span class="sr">/a&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="sr">/ul&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>在需要的位置增加<code>&lt;li&gt;&lt;a href="http://biaobiaoqi.github.com/tag-cloud/"&gt;标签云&lt;/a&gt;&lt;/li&gt;</code>。如此一来，可以在网页顶栏看到『标签云』一栏了。不过此时，点击进入，页面为空。</p>

<p>3.修改标签云页面内容。</p>

<p>修改<code>octopress/source/tag-cloud/index.markdown</code>，增加标签云执行脚本。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">---</span>
</span><span class='line'><span class="ss">layout</span><span class="p">:</span> <span class="n">page</span>
</span><span class='line'><span class="ss">title</span><span class="p">:</span> <span class="s2">&quot;标签云&quot;</span>
</span><span class='line'><span class="ss">date</span><span class="p">:</span> <span class="mi">2013</span><span class="o">-</span><span class="mo">07</span><span class="o">-</span><span class="mi">10</span> <span class="mo">02</span><span class="p">:</span><span class="mi">53</span>
</span><span class='line'><span class="ss">comments</span><span class="p">:</span> <span class="kp">true</span>
</span><span class='line'><span class="ss">sharing</span><span class="p">:</span> <span class="kp">true</span>
</span><span class='line'><span class="ss">footer</span><span class="p">:</span> <span class="kp">true</span>
</span><span class='line'><span class="o">---</span>
</span><span class='line'>
</span><span class='line'><span class="c1">#注意，代码中的 escape 反斜杠在正常使用时需要去掉</span>
</span><span class='line'><span class="c1">#另外，这几个语句不能使用换行。在我的测试环境下，使用换行后，最终的页面上对换行进行了错误的解码，给增加了一个&lt;code&gt;标签，造成了错误的显示。</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">ul</span> <span class="n">class</span><span class="o">=</span><span class="s2">&quot;tag-cloud&quot;</span><span class="o">&gt;</span><span class="p">\{\</span><span class="o">%</span> <span class="n">tag_cloud</span> <span class="n">font</span><span class="o">-</span><span class="ss">size</span><span class="p">:</span> <span class="mi">90</span><span class="o">-</span><span class="mi">210</span><span class="sx">%, limit: 1000,</span> <span class="ss">style</span><span class="p">:</span> <span class="n">para</span> <span class="p">\</span><span class="o">%</span><span class="p">\}</span><span class="o">&lt;</span><span class="sr">/ul&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>9.博客末尾增加原文链接、版权等</h2>

<p>最近发现有其他小网站未经授权直接 copy 我的博客内容，在违章的末尾加上版权、原文链接变得很有必要了。</p>

<p>详情参见博客<a href="http://codemacro.com/2012/07/26/post-footer-plugin-for-octopress/">《为 octopress 每篇文章添加一个文章信息》</a>。</p>

<p>值得注意的是，插件代码中如下几行需要去掉缩进和换行符。原因跟第 8 节所讲一样，换行符引起了错误的解码，造成了错误的显示。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">post</span><span class="o">.</span><span class="n">content</span> <span class="o">+</span> <span class="sx">%Q[&lt;p class=&#39;post-footer&#39;&gt;</span>
</span><span class='line'><span class="sx">            </span><span class="si">#{</span><span class="n">pre</span> <span class="ow">or</span> <span class="s2">&quot;original link:&quot;</span><span class="si">}</span><span class="sx"></span>
</span><span class='line'><span class="sx">            &lt;a href=&#39;</span><span class="si">#{</span><span class="n">post</span><span class="o">.</span><span class="n">full_url</span><span class="si">}</span><span class="sx">&#39;&gt;</span><span class="si">#{</span><span class="n">post</span><span class="o">.</span><span class="n">full_url</span><span class="si">}</span><span class="sx">&lt;/a&gt;&lt;br/&gt;</span>
</span><span class='line'><span class="sx">            &amp;nbsp;written by &lt;a href=&#39;</span><span class="si">#{</span><span class="n">url</span><span class="si">}</span><span class="sx">&#39;&gt;</span><span class="si">#{</span><span class="n">author</span><span class="si">}</span><span class="sx">&lt;/a&gt;</span>
</span><span class='line'><span class="sx">            &amp;nbsp;posted at &lt;a href=&#39;</span><span class="si">#{</span><span class="n">url</span><span class="si">}</span><span class="sx">&#39;&gt;</span><span class="si">#{</span><span class="n">url</span><span class="si">}</span><span class="sx">&lt;/a&gt;</span>
</span><span class='line'><span class="sx">            &lt;/p&gt;]</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后，kevin 没有提及的是，为了做好美化，还需要增加一段针这块区域的 css：</p>

<p>编辑<code>sass/custom/_style.scss</code>，在末尾增加如下内容：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nc">.post-footer</span><span class="p">{</span><span class="k">margin-top</span><span class="o">:</span><span class="m">10px</span><span class="p">;</span><span class="k">padding</span><span class="o">:</span><span class="m">5px</span><span class="p">;</span><span class="k">background</span><span class="o">:</span><span class="k">none</span> <span class="k">repeat</span> <span class="k">scroll</span> <span class="m">0pt</span> <span class="m">0pt</span> <span class="m">#eee</span><span class="p">;</span><span class="k">font-size</span><span class="o">:</span><span class="m">90</span><span class="o">%</span><span class="p">;</span><span class="k">color</span><span class="o">:</span><span class="nb">gray</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样，原文链接和版权信息就能很好的和正文内容分离开了。</p>

<h2>10.给中英文之间加空格</h2>

<p>参见博文<a href="http://xoyo.name/2012/04/auto-spacing-for-octopress/">《给中英文间加个空格》</a>。</p>

<p>特别注意 ruby 文件的编码：复制博文中的代码时，需要去掉前几行的描述性注释，让<code>#encoding:UTF-8</code>语句暴露在.rb 文件的第一句。否则，<code>rake generate</code>时，会报错无法识别<code>\p{Han}</code>。</p>

<h2>Tips</h2>

<p>既然是个博客站点，就算是 web 产品啦，可以考虑下 SEO。推荐博文<a href="http://codemacro.com/2012/09/06/octopress-seo/">《Octopress 中的 SEO》</a><p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/07/10/decorate-octopress/'>http://biaobiaoqi.github.com/blog/2013/07/10/decorate-octopress/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《俞敏洪口述》]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/07/07/yuminhong/"/>
    <updated>2013-07-07T23:53:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/07/07/yuminhong</id>
    <content type="html"><![CDATA[<h2>质朴、诚恳和坚韧</h2>

<p>这本书是某次在 Amazon 上购书『满 100 送书一本』时挑的。放在抽屉里有段日子了。</p>

<p>一直挺崇拜俞敏洪老师。初次了解到他是高中的时候看的『赢在中国』，俞敏洪老师是嘉宾点评。而后混在考 T 的大流中去上了新东方的课程，几个老师讲得不错，比较可惜的是远离了老俞的时代。恰好前两天热映的『中国合伙人』，又把他拉回视野前沿。周日，趁着没心情码代码，忙里偷闲的读完了这本自传体的文字。</p>

<p>我不太喜欢读『活人』的传记。没有盖棺定论的事儿，或多或少掺杂些美华。但读这本书，却丝毫没有表现出浮夸，就像他的性格一般质朴、诚恳和坚韧。</p>

<p>或许在某些名人的传记里，永远不会看到他通过喝酒打通关系搞定了某个问题，而老俞有。书里多次的描述了他是怎样融入了这个『人情社会』。不可否认，他的本分和待人诚恳让他有人缘，这是他的优势。</p>

<p>他能在面对东方学校过河拆桥的举动下，沉住气，以和为贵，用合理的手段占据主动。</p>

<p>他能在北大读本科的阶段受众人嘲讽的环境下成长，不断学习，在毕业时，喊出『你们干十年成的我干二十年，你们二十年成的我干四十年。如果实在不行，我会保持心情愉快、身体健康，到八十岁以后把你们送走了我再走』。</p>

<p>凡此种种……</p>

<h2>世界观</h2>

<p>从每个成功的人的经历中，都能总结出数不清的箴言。成功的理由永远说不完。而这本书里，对我而言感触最深的无非是下面这些话：</p>

<blockquote><p>人生就是这样，你不受这个苦就会受那个苦。一个人如果从苦中能找到乐和幸福，那他就是幸运的。……我深刻的意识到什么也不做的痛苦比任何其他痛苦更加深刻，所以我一定要做事，做事的标准就是必须做对社会有好处的事情，以最大的努力在痛苦的世界中尽力而为。</p></blockquote>

<p>对我而言，这句话实在受用。我无法证明这些字在未来的时间里能对我造成的影响，却打在我最近几年来受困扰最多的点上。</p>

<p>乐观让人笑着面对生活。生活总归是有各种委屈、各种阻力，笑脸的背后，时常是受伤的心，区别在于受伤的心能埋得多深。我宁愿相信，乐观是因为能接受苦，能从苦中找到快乐，而不是没有苦。</p>

<p>时常的，我被不好的状态左右。那是种很奇怪的感觉，是面对压力的逃避、拖延，独自缩在没有人看得见的角落，在电脑屏幕前刷着网页，时间慢慢流走。然后心情越来越差，因为一事无成的颓废感。我是闲不下来的人。是的，『什么也不做的痛苦，比任何其他痛苦更加深刻』！</p>

<p>曾经在 ASES 的分享会上，听 dd 讲起过<a href="http://cuitianyi.com/blog/authentic-happiness-%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/">『积极心理学』</a>。其中有个观点是：『享乐是心灵资本的消费，而心流中的满足则是心灵资本的投资』。简单的讲，创造价值的事情会让我得到心流的满足，而简单的娱乐则会消费这种满足感。或许当两者之差为负的时候，我就感受到了那种空虚和煎熬，不止什么都不做，还消费了更多。</p>

<p>正是对社会责任的追求，老俞没有沉浸再新东方的飞速发展中。对他而言，现在的新东方的经营一切都要权衡公司的利益和教育理念。虽然他的新东方充满了实用主义和人文情怀，虽然他能让新东方尽到企业的社会责任，但这依然不是他想要的。他正在筹划办私立高校，用他的教育理念，给中国的教育发展贡献力量。这是中国的希望。</p>

<p>最后，以老俞的一句话结尾：</p>

<blockquote><p>人生的苦难肯定是没有尽头的，人要做的是在苦难中奋发起来，做自己能够做的和应该做的事儿，这就是我的世界观。</p></blockquote>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/07/07/yuminhong/'>http://biaobiaoqi.github.com/blog/2013/07/07/yuminhong/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《清单革命》]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/07/05/checklist-manifesto/"/>
    <updated>2013-07-05T00:54:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/07/05/checklist-manifesto</id>
    <content type="html"><![CDATA[<h2>应该叫『清单宣言』</h2>

<p>在 Amazon 上『满 100 送一本』的活动中随手挑到了它。鉴于其空洞的标题，被束之高阁半年多，最近关注个人管理方面的知识，才拍拍灰尘读起来。</p>

<p>书的英文原名是『The Checklist Manifesto: How to Get Things Right』，直译成『清单宣言』在我看来更贴切，而非充满噱头的『清单革命』。正如一个小功能难以做成独立的产品，一个方法改进也难以成就革命。『清单能大大的改善效率，降低失败概率』这一观点，在医生出生的作者手中翻来覆去的被各种事例证明着，案例的行业背景从医学到建筑，到航天，再到投资，实在乏味。当然，这不妨碍『清单』这一工具对生活工作的助力所带给我们的思考。</p>

<h2>三类问题</h2>

<p>清单作为处理问题的工具，需要从问题的分类谈起。问题大致可分为三类：简单问题、复杂问题和极端复杂的问题。</p>

<ul>
<li>简单问题，诸如洪培蛋糕，只需要知道流程，就可以独立完成，没有复杂的过程和细节。</li>
<li>复杂问题，比如火箭发射升空。通过耐心分解，复杂问题能划分成很多的简单问题，进而得到解决。这时候，需要借助集体的力量。</li>
<li>极端复杂的问题，比如子女的抚养。问题的领域极其宽广和复杂，充满了不确定性，理性的分析难以完全掌控。</li>
</ul>


<p>这三种类型的问题由简单到复杂的梯度递增。</p>

<h2>实践经验：清单</h2>

<p>实践领域的失败分为两种，一种是无知之错，俗话说得好，『不知者无罪』；另一种是无能之错，即按照知识储备，完全能成功解决问题，最终却因为各种原因失败了。随着社会的发展，后者的出现频率越来越高。造成这一现象的原因容易理解，社会复杂度越来越高，各种问题的实施难度加大，远超过个人能力的范围了。这个时候『清单』的重要性凸显了出来。</p>

<p>人脑有一个认知防护网，体现在如下认知缺陷上：</p>

<ul>
<li>记忆不完整</li>
<li>注意力不集中</li>
<li>惰性思维</li>
</ul>


<p>清单能帮助人处理问题：</p>

<ul>
<li>重压之下，人脑容易忽视某些细节。</li>
<li>人脑对于熟知的事实，思考时容易跳过一些事项。</li>
</ul>


<p>使用清单时，特别注意需要保证清单的简单、可测、高效。清单是给人用的，基于人脑局限性，复杂和模糊的认知难以帮助事情的发展。</p>

<blockquote><p>清单需要简单、可测、高效</p></blockquote>

<p>当然，清单也有显而易见的缺点：死板。它是一张纸条上的几行文字，不会知道水的冷暖。那么，当意外发生，需要应变的就是执行者本人。生活中，事物总是充满着变化，清单的控制也需要注意及时的应变。</p>

<blockquote><p>制定清单、执行清单的过程，也需要灵活应变。</p></blockquote>

<h2>用清单处理问题</h2>

<ul>
<li>简单问题： 简单的问题可以通过清单提高效率和成功率。</li>
<li>复杂问题： 可以拆分为许多的简单问题，分由多人管理和复杂，再辅以清单解决。另外，需要注意人与人之间沟通，这能降低出错的可能性，提高个人效率。</li>
<li>极端复杂的问题：更多的需要不断的试错、调整。</li>
</ul>


<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/07/05/checklist-manifesto/'>http://biaobiaoqi.github.com/blog/2013/07/05/checklist-manifesto/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给女朋友的礼物]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/06/11/gift-to-girl-friend/"/>
    <updated>2013-06-11T17:12:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/06/11/gift-to-girl-friend</id>
    <content type="html"><![CDATA[<h2>背景</h2>

<p>一个月前发现了 <a href="http://v2ex.com">V2EX</a> 这个网站，用创始人 <a href="http://www.v2ex.com/member/Livid">Livid</a> 的话来说，『这是一个主要关于做事儿的地方』。确实如此，我在这里收获了很多想法和灵感。</p>

<p>本文所记的，也是得益于某天的对<a href="http://www.v2ex.com/t/69145">某个主题</a>的浏览。帖子中，大家分享了很多给女朋友做的网页，说『技术宅改变世界』太过了，但拥有这样一个礼物，确实是一种属于程序员的快乐和程序员的女友的幸福。</p>

<p>快到我跟我妹子恋爱四周年的日子了，也正逢她本科毕业，无论如何都是个有趣的时间点。受了那个帖子的刺激，我也筹划着给女朋友做一个小网页，以示纪念。</p>

<p>遗憾的是，我自己从来没有写过网页，javascript 和 css 只知道概念，html 也只是知道一些简单的标签，这些可是完成一个小网页所必备的技能呢。技术能力直接阻碍了创造性成果出现的可能:(。于是，解决方案只能是搜集开源代码，然后自己做定制了。实际上，最后的产出，也就是三份代码的拼接。</p>

<h2>资料搜集</h2>

<p>通过各方搜寻，我找到了如下几个网页：</p>

<ul>
<li>1.<a href="http://love.hackerzhou.me/">复旦的学长 hackzhou 的爱心动画</a>，<a href="https://github.com/hackerzhou/Love">github 托管代码</a>。</li>
</ul>


<p>网页用到了 html5 的一些特性实现了动态的心形花的绘制和类似程序代码敲击的文字呈现形式。由于内容仅仅是文字的，可定制性强。如下图：
<img src="https://dl.dropboxusercontent.com/u/64021093/Pics/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202013-06-11%20%E4%B8%8B%E5%8D%888.12.01.png" title="hackerzhou's page" alt="hackerzhou's love project" /></p>

<ul>
<li>2.<a href="http://carfieldloverita.sinaapp.com/">一对异国情侣的 Google 地图应用</a>，<a href="https://github.com/wong2/lovegift">github 托管代码</a>。</li>
</ul>


<p>网页调用了 Google 地图的 API，可以定义聚焦的地理位置和坐标尺，显示照片，像日记一样记录了点点滴滴，有背景音乐。最后还以地点输入框的形式做了表白。很有创意！
<img src="https://dl.dropboxusercontent.com/u/64021093/Pics/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202013-06-11%20%E4%B8%8B%E5%8D%888.12.18.png" title="Googlemap app" alt="Google map app" /></p>

<ul>
<li>3.<a href="http://liumeijun.com/">v2ex 上某童鞋基于百度地图的应用</a>。</li>
</ul>


<p>跟 2 类似，调用了百度 API，配上『Lemon tree』的背景音乐，很有调调！
<img src="https://dl.dropboxusercontent.com/u/64021093/Pics/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202013-06-11%20%E4%B8%8B%E5%8D%888.16.00.png" title="baidumap app" alt="baidumap app" /></p>

<h2>定制计划</h2>

<p>限于没有前端的基础，开发效率会很低，只能硬顶着拿着前面的三个项目做混搭了。其中项目 1 和 2 都有在 github 上开源代码，而 3 则在 v2ex 的帖子里被作者授权直接查源码使用了。</p>

<p>我做了简单的混搭修改计划：</p>

<ul>
<li>1.以 hackzhou 的项目为基础，修改文字内容和基本布局。</li>
<li>2.添加加载等待过程，加载背景音乐。</li>
<li>3.加载完成后，出现开始按钮，按开始按钮播放背景音乐，进入动画效果。</li>
<li>4.增加全屏效果。</li>
</ul>


<h2>实施</h2>

<h5>1.项目启动</h5>

<p>我在 github 上 fork 了 <a href="https://github.com/hackerzhou/Love">hackerzhou 的代码</a>。(<a href="https://github.com/biaobiaoqi/Love">我 fork 的版本</a>)</p>

<p>clone 到本地，尝试阅读 js 代码，尝试做小改动，找到动画开始的调用。</p>

<h5>2.尝试添加背景音乐</h5>

<p>网上查资料，找到了<code>&lt;embeded&gt;</code>可以用来添加背景音乐，测试成功。但这个音乐播放无法支持同步的加载，不可控，在网络环境差的情况下，如果没有配乐动画过程会缺少表现力。放弃这种方案。</p>

<p>在 <a href="http://liumeijun.com/">v2ex 上某童鞋基于百度地图的应用</a>源码中找到了一个第三方音乐播放库：<a href="http://www.schillmania.com/projects/soundmanager2/">soundmanager2</a>。查看官方文档，确认能满足项目需求，于是加入到代码中。</p>

<p>为了让页面展现更加顺畅，需要音乐文件越小越好。我尝试了 MIDI 格式，但是很多浏览器并不支持，作罢。而 soundmanager 似乎对 wma 的支持有问题，于是只剩下 mp3 文件。我选择了 JJ 的『小酒窝』做背景音乐，在 mac 下使用 ocenaudio 将原来 3MB 的 mp3 文件截取了前一半，并导出为不同设定采样率的版本，经过测试，发现 56kb 采样率下，音质没有受到大的影响，且大小也足够小了，于是确定用这种格式的 mp3。最终 MP3 文件的大小为 500KB！</p>

<h5>3.加载逻辑和开始按键</h5>

<p>需求：加载过程需要隐藏前景内容，在音乐加载完成后，显示开始按钮，开始按钮能触发动画效果。</p>

<p>通过 Google 找到了使用 js 隐藏和显示内容的方式</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>document.getElementById('hint').style.display = "none"; //hide hint
</span><span class='line'>document.getElementById('start_btn').style.display = ""; //show start button</span></code></pre></td></tr></table></div></figure>


<p>虽然不是特别理解 js 引擎的单线程运作机制，但经过简单的试错、调试后，就完成了加载等待和开始按钮触发的原型。</p>

<p>之后是对按钮和加载提示配置 css。由于懒得理解 css 的一些细节，直接使用了<a href="https://github.com/wong2/lovegift">这份项目</a>中的 css 代码。</p>

<h5>4.部署</h5>

<p>github 为每个项目提供了静态网页展示的功能，应付这个项目的网页展示完全够了。具体操作流程参见<a href="http://www.worldhello.net/gotgithub/03-project-hosting/050-homepage.html#project-homepage">《GotGithub》3.5.2. 创建项目主页</a>。实际上，链接中介绍的几种创造干净的 gh-pages 分支的方法，在这个项目的发布里是不必的。因为项目主页的展示代码跟 master 分支里的代码本身就是一样的，那么需要做的就只是开启 gh-pages 分支，并提交代码了。</p>

<p>项目成果：<a href="http://biaobiaoqi.me/Love">请戳这里</a></p>

<h2>结语</h2>

<p>感谢 v2ex，感谢 hackerzhou、loo2k 和 wong2 童鞋，我参考了你们很多代码。</p>

<p>创造力需要靠技术手段实现。混迹在互联网上，没有自己建站的能力实在是很苦逼的一件事情。之后自己准备花些时间在 RoR 上。积累技术实力，努力做出好产品;)</p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/06/11/gift-to-girl-friend/'>http://biaobiaoqi.github.com/blog/2013/06/11/gift-to-girl-friend/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《写给大家看的设计书》]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/06/11/the-non-designers-design-book/"/>
    <updated>2013-06-11T13:58:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/06/11/the-non-designers-design-book</id>
    <content type="html"><![CDATA[<h3>从 iOS7 的扁平化谈起</h3>

<p>昨晚看了 WWDC2013 的直播，iOS7 以扁平化 UI 的方式展现在世人面前。于是接下来进入了微博吐槽时间。</p>

<p>大象要跳舞是很难的，这正是苹果面临的情况。现在无论是 Android 还是 Winphone，与 iOS 系统体验上的差异已经不是难以企及的，甚至有些方面更能为大众接受。于是 Ive 带领他的团队开始拥抱<strong> Flat Design</strong>。乔布斯子不知道会怎么想，他可是坚持了一辈子的拟物风格。当然，无论乔老爷子怎么想，时势如此，由不得苹果不变。</p>

<p>从微博疯狂的 iOS7 刷屏中挑出了些有价值的信息，关于扁平化和拟物化的：</p>

<ul>
<li><a href="http://www.zhihu.com/question/20881633">什么是扁平化设计（Flat Design）？扁平化设计是未来的趋势吗？</a></li>
<li><a href="http://www.inside.com.tw/2013/03/25/flat-design">UI 美學趨勢備忘錄─淺析扁平化設計</a></li>
<li><a href="http://www.oschina.net/translate/flat-design-principles">扁平化设计原则</a></li>
</ul>


<p>看完这些已经晕头了。人的思维总是有惰性的，倾向于接受自己头脑中已经有条理的思维结果。不情愿的说，这些略显专业的介绍已经超出了我对设计的思考范畴了，我看到的只是零散的观点，而找不到源头。</p>

<p>于是想起了《写给大家看的设计书》。作为非设计人员，这本书够接地气。一个多月前看完，让自己对设计的认识从一个完全的小白提升为一个略有喜好和观点的小白了。还是先聊这本书吧。</p>

<h2>设计的基本原则</h2>

<p>读这本书之前，在不同平台上看见它的好多推荐了。不过鉴于大多数设计类书都是『手把手教你画马』的效果（详情参见下图），一直不太感冒。</p>

<p><img src="https://dl.dropboxusercontent.com/u/64021093/Pics/307-12110Q62915932.jpg" title="画马" alt="怎样画马" /></p>

<p>后来码代码太烦躁，抱着试一试的态度在多看上下载了下来，一着眼便被吸引住了。书本本身的排版设计就透露着简洁明了的设计感，配色也恰到好处的清新。</p>

<p>全书循序渐进的从设计的四大基本原则讲起，结合丰富的案例分析，延伸到具体的主题设计技巧中。这部分是最让我觉得受益的部分。当然，不仅仅只是这些，还有涉及到颜色的运用、字体的设计等内容，本着『不要在意这些细节』的原则，它们被我匆匆略过。</p>

<p>可以这么夸张的说，设计的『四项基本原则』是我有自主意识以来觉得最受用的『条条框框』：</p>

<h3>原则一：亲密性</h3>

<p>亲密性的根本目的是组织性。还有个副产品，利用亲密性可以使空白更美观。</p>

<ul>
<li>将相关的项组织在一起。</li>
<li>物理位置的接近就意味着存在关联。</li>
</ul>


<h3>原则二：对齐</h3>

<p>对齐的根本目的是使页面统一而有条理。不论创建精美的、正式的、有趣的还是严肃的外观，通常都可以利用一种明确的对齐来达到目的。</p>

<ul>
<li>任何元素都不能在页面上随意安放。每一项都应当与页面上的某个内容存在某种视觉联系。</li>
<li>对齐的项会形成一个内聚的单元。</li>
<li>居中对齐显得正式、稳重，但一般不要用居中对齐。</li>
<li>一定要坚持页面上只使用一种文本对齐，避免混合使用多种文本对齐。</li>
<li>可以适时的打破规则，但在此之前得清楚什么是规则。</li>
</ul>


<h3>原则三：重复</h3>

<p>重复的根本目的是统一，并增强视觉效果。</p>

<ul>
<li>设计的某些方面需要在整个作品中重复</li>
<li>重复是一种全局的一致性，比如杂志每页的标题都使用同样的字体大小。这有利于信息的组织。</li>
<li>重复也一定程度给作品带来专业性和权威性。</li>
<li>要避免太多的重复，重复太多会让人厌烦。注意对比的价值</li>
</ul>


<h3>原则四：对比</h3>

<p>根本目的有两方面。一个目的是增强页面效果，如果一个页面看起来很有意思，往往更有可读性；另一个目的是有助于信息的组织。</p>

<ul>
<li>如果两项不完全相同，就应当使之不同，而且应当是截然不同。</li>
<li>对比一定要强烈。</li>
</ul>


<h3>应用设计原则</h3>

<p>优秀的设计就这么容易：</p>

<ul>
<li>1.学习 4 大基本原则;</li>
<li>2.认识到自己没有运用这些原则；</li>
<li>3.应用基本原则。</li>
</ul>


<p>这四个基本设计原则是相互关联的，只应用某一个原则的情况很少。当对应着一个个的举例体验过四条基本原则的威力后，接下来就是在自己身边实践这些原则了。</p>

<p>一方面，可以观察四项原则在现有设计中的应用：比如当前所打开的网页，是否足够清晰、明确的展示了它所要表达的意图；手头的书本，排版是否跟内容在情感上吻合。</p>

<p>另一方面，时常会有些文档、写报告、为展示写 slides 的需求，自己在创作的过程中，也可以应用起这四条原则，慢慢体会，慢慢修炼。</p>

<h2>体会</h2>

<p>歌德在《浮士德》中提到过这么一句话：『理论是灰色的，生活之树常青』。在我看来，所有的事物都是如此，人性使然。抛开这四条原则本身，它们归结起来都是要实现意图的传递：</p>

<blockquote><p>将信息从设计者准确无误的传递给目标用户</p></blockquote>

<p>设计作为一种原始信息的载体，本身的形式上会带来附加的信息量，如何让这些设计自身的附加量不混淆了核心的原始信息，是设计好坏的根本。更进一步，设计的更高层次应该是让设计的附加量起到正相关的增益效果。《写给大家看的设计书》中的四个原则正是最基础的实践。</p>

<p>现在是信息的时代，信息量的暴增让信息的简洁展示和选择变得越发关键。前文提到的扁平化的设计风格的崛起，就是一个例证:</p>

<p>『扁平化设计具有一种给你让人心醉的美丽，没有大量的修饰，它能以一个简单直白的方式传达一个信息或者帮助一个产品以及思想变得更加深入人心……扁平化设计正是通过放弃任何附加效果的方式，创建一个「零」3D 属性的设计方案。在这里，没有阴影效果、斜角、浮雕、渐变等其他方法来帮助元素产生相对于屏幕的凹凸效果。不带有羽化边缘以及阴影效果的图标和 UI 元素也都看起来非常鲜明。』</p>

<p>相对而言，乔布斯推崇的拟物风格中，所秉承的是让所有用户能快速的学会如何使用它。而随着时代的发展，这种降低学习成本的方式渐渐的不是必须，数码产品充斥着生活，大多数人已经有足够的经验来应对新的操作体验。从这个角度讲，扁平化在现阶段或许是更有好的选择。</p>

<p>不管怎么样，WWDC 以后，苹果股价已经持续下跌了，祝福苹果吧，希望 Ive 不要成为苹果的罪人，据说他是最懂乔布斯的人呢。</p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/06/11/the-non-designers-design-book/'>http://biaobiaoqi.github.com/blog/2013/06/11/the-non-designers-design-book/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
</feed>
