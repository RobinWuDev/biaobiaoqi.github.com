<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Biaobiaoqi的博客]]></title>
  <link href="http://biaobiaoqi.github.com/atom.xml" rel="self"/>
  <link href="http://biaobiaoqi.github.com/"/>
  <updated>2013-06-12T20:51:16+08:00</updated>
  <id>http://biaobiaoqi.github.com/</id>
  <author>
    <name><![CDATA[Biaobiaoqi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[给女朋友的礼物]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/06/11/gift-to-girl-friend/"/>
    <updated>2013-06-11T17:12:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/06/11/gift-to-girl-friend</id>
    <content type="html"><![CDATA[<h2>背景</h2>

<p>一个月前发现了<a href="http://v2ex.com">V2EX</a>这个网站，用创始人<a href="http://www.v2ex.com/member/Livid">Livid</a>的话来说，『这是一个主要关于做事儿的地方』。确实如此，我在这里收获了很多想法和灵感。</p>

<p>本文所记的，也是得益于某天的对<a href="http://www.v2ex.com/t/69145">某个主题</a>的浏览。帖子中，大家分享了很多给女朋友做的网页，说『技术宅改变世界』太过了，但拥有这样一个礼物，确实是一种属于程序员的快乐和程序员的女友的幸福。</p>

<p>快到我跟我妹子恋爱四周年的日子了，也正逢她本科毕业，无论如何都是个有趣的时间点。受了那个帖子的刺激，我也筹划着给女朋友做一个小网页，以示纪念。</p>

<p>遗憾的是，我自己从来没有写过网页，javascript和css只知道概念，html也只是知道一些简单的标签，这些可是完成一个小网页所必备的技能呢。技术能力直接阻碍了创造性成果出现的可能:(。于是，解决方案只能是搜集开源代码，然后自己做定制了。实际上，最后的产出，也就是三份代码的拼接。</p>

<h2>资料搜集</h2>

<p>通过各方搜寻，我找到了如下几个网页：</p>

<ul>
<li>1.<a href="http://love.hackerzhou.me/">复旦的学长hackzhou的爱心动画</a>，<a href="https://github.com/hackerzhou/Love">github托管代码</a>。</li>
</ul>


<p>网页用到了html5的一些特性实现了动态的心形花的绘制和类似程序代码敲击的文字呈现形式。由于内容仅仅是文字的，可定制性强。如下图：
<img src="https://dl.dropboxusercontent.com/u/64021093/Pics/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202013-06-11%20%E4%B8%8B%E5%8D%888.12.01.png" title="hackerzhou's page" alt="hackerzhou's love project" /></p>

<ul>
<li>2.<a href="http://carfieldloverita.sinaapp.com/">一对异国情侣的Google地图应用</a>，<a href="https://github.com/wong2/lovegift">github托管代码</a>。</li>
</ul>


<p>网页调用了Google地图的API，可以定义聚焦的地理位置和坐标尺，显示照片，像日记一样记录了点点滴滴，有背景音乐。最后还以地点输入框的形式做了表白。很有创意！
<img src="https://dl.dropboxusercontent.com/u/64021093/Pics/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202013-06-11%20%E4%B8%8B%E5%8D%888.12.18.png" title="Googlemap app" alt="Google map app" /></p>

<ul>
<li>3.<a href="http://liumeijun.com/">v2ex上某童鞋基于百度地图的应用</a>。</li>
</ul>


<p>跟2类似，调用了百度API，配上『Lemon tree』的背景音乐，很有调调！
<img src="https://dl.dropboxusercontent.com/u/64021093/Pics/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202013-06-11%20%E4%B8%8B%E5%8D%888.16.00.png" title="baidumap app" alt="baidumap app" /></p>

<h2>定制计划</h2>

<p>限于没有前端的基础，开发效率会很低，只能硬顶着拿着前面的三个项目做混搭了。其中项目1和2都有在github上开源代码，而3则在v2ex的帖子里被作者授权直接查源码使用了。</p>

<p>我做了简单的混搭修改计划：</p>

<ul>
<li>1.以hackzhou的项目为基础，修改文字内容和基本布局。</li>
<li>2.添加加载等待过程，加载背景音乐。</li>
<li>3.加载完成后，出现开始按钮，按开始按钮播放背景音乐，进入动画效果。</li>
<li>4.增加全屏效果。</li>
</ul>


<h2>实施</h2>

<h5>1.项目启动</h5>

<p>我在github上fork了<a href="https://github.com/hackerzhou/Love">hackerzhou的代码</a>。(<a href="https://github.com/biaobiaoqi/Love">我fork的版本</a>)</p>

<p>clone到本地，尝试阅读js代码，尝试做小改动，找到动画开始的调用。</p>

<h5>2.尝试添加背景音乐</h5>

<p>网上查资料，找到了<code>&lt;embeded&gt;</code>可以用来添加背景音乐，测试成功。但这个音乐播放无法支持同步的加载，不可控，在网络环境差的情况下，如果没有配乐动画过程会缺少表现力。放弃这种方案。</p>

<p>在<a href="http://liumeijun.com/">v2ex上某童鞋基于百度地图的应用</a>源码中找到了一个第三方音乐播放库：<a href="http://www.schillmania.com/projects/soundmanager2/">soundmanager2</a>。查看官方文档，确认能满足项目需求，于是加入到代码中。</p>

<p>为了让页面展现更加顺畅，需要音乐文件越小越好。我尝试了MIDI格式，但是很多浏览器并不支持，作罢。而soundmanager似乎对wma的支持有问题，于是只剩下mp3文件。我选择了JJ的『小酒窝』做背景音乐，在mac下使用ocenaudio将原来3MB的mp3文件截取了前一半，并导出为不同设定采样率的版本，经过测试，发现56kb采样率下，音质没有受到大的影响，且大小也足够小了，于是确定用这种格式的mp3。最终MP3文件的大小为500KB！</p>

<h5>3.加载逻辑和开始按键</h5>

<p>需求：加载过程需要隐藏前景内容，在音乐加载完成后，显示开始按钮，开始按钮能触发动画效果。</p>

<p>通过Google找到了使用js隐藏和显示内容的方式</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>document.getElementById('hint').style.display = "none"; //hide hint
</span><span class='line'>document.getElementById('start_btn').style.display = ""; //show start button</span></code></pre></td></tr></table></div></figure>


<p>虽然不是特别理解js引擎的单线程运作机制，但经过简单的试错、调试后，就完成了加载等待和开始按钮触发的原型。</p>

<p>之后是对按钮和加载提示配置css。由于懒得理解css的一些细节，直接使用了<a href="https://github.com/wong2/lovegift">这份项目</a>中的css代码。</p>

<h5>4.部署</h5>

<p>github为每个项目提供了静态网页展示的功能，应付这个项目的网页展示完全够了。具体操作流程参见<a href="http://www.worldhello.net/gotgithub/03-project-hosting/050-homepage.html#project-homepage">《GotGithub》3.5.2. 创建项目主页</a>。实际上，链接中介绍的几种创造干净的gh-pages分支的方法，在这个项目的发布里是不必的。因为项目主页的展示代码跟master分支里的代码本身就是一样的，那么需要做的就只是开启gh-pages分支，并提交代码了。</p>

<p>项目成果：<a href="http://biaobiaoqi.me/Love">请戳这里</a></p>

<h2>结语</h2>

<p>感谢v2ex，感谢hackerzhou、loo2k和wong2童鞋，我参考了你们很多代码。</p>

<p>创造力需要靠技术手段实现。混迹在互联网上，没有自己建站的能力实在是很苦逼的一件事情。之后自己准备花些时间在RoR上。积累技术实力，努力做出好产品;)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《写给大家看的设计书》]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/06/11/the-non-designers-design-book/"/>
    <updated>2013-06-11T13:58:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/06/11/the-non-designers-design-book</id>
    <content type="html"><![CDATA[<h3>从iOS7的扁平化谈起</h3>

<p>昨晚看了WWDC2013的直播，iOS7以扁平化UI的方式展现在世人面前。于是接下来进入了微博吐槽时间。</p>

<p>大象要跳舞是很难的，这正是苹果面临的情况。现在无论是Android还是Winphone，与iOS系统体验上的差异已经不是难以企及的，甚至有些方面更能为大众接受。于是Ive带领他的团队开始拥抱<strong>Flat Design</strong>。乔布斯子不知道会怎么想，他可是坚持了一辈子的拟物风格。当然，无论乔老爷子怎么想，时势如此，由不得苹果不变。</p>

<p>从微博疯狂的iOS7刷屏中挑出了些有价值的信息，关于扁平化和拟物化的：</p>

<ul>
<li><a href="http://www.zhihu.com/question/20881633">什么是扁平化设计（Flat Design）？扁平化设计是未来的趋势吗？</a></li>
<li><a href="http://www.inside.com.tw/2013/03/25/flat-design">UI 美學趨勢備忘錄─淺析扁平化設計</a></li>
<li><a href="http://www.oschina.net/translate/flat-design-principles">扁平化设计原则</a></li>
</ul>


<p>看完这些已经晕头了。人的思维总是有惰性的，倾向于接受自己头脑中已经有条理的思维结果。不情愿的说，这些略显专业的介绍已经超出了我对设计的思考范畴了，我看到的只是零散的观点，而找不到源头。</p>

<p>于是想起了《写给大家看的设计书》。作为非设计人员，这本书够接地气。一个多月前看完，让自己对设计的认识从一个完全的小白提升为一个略有喜好和观点的小白了。还是先聊这本书吧。</p>

<h2>设计的基本原则</h2>

<p>读这本书之前，在不同平台上看见它的好多推荐了。不过鉴于大多数设计类书都是『手把手教你画马』的效果（详情参见下图），一直不太感冒。</p>

<p><img src="https://dl.dropboxusercontent.com/u/64021093/Pics/307-12110Q62915932.jpg" title="画马" alt="怎样画马" /></p>

<p>后来码代码太烦躁，抱着试一试的态度在多看上下载了下来，一着眼便被吸引住了。书本本身的排版设计就透露着简洁明了的设计感，配色也恰到好处的清新。</p>

<p>全书循序渐进的从设计的四大基本原则讲起，结合丰富的案例分析，延伸到具体的主题设计技巧中。这部分是最让我觉得受益的部分。当然，不仅仅只是这些，还有涉及到颜色的运用、字体的设计等内容，本着『不要在意这些细节』的原则，它们被我匆匆略过。</p>

<p>可以这么夸张的说，设计的『四项基本原则』是我有自主意识以来觉得最受用的『条条框框』：</p>

<h3>原则一：亲密性</h3>

<p>亲密性的根本目的是组织性。还有个副产品，利用亲密性可以使空白更美观。</p>

<ul>
<li>将相关的项组织在一起。</li>
<li>物理位置的接近就意味着存在关联。</li>
</ul>


<h3>原则二：对齐</h3>

<p>对齐的根本目的是使页面统一而有条理。不论创建精美的、正式的、有趣的还是严肃的外观，通常都可以利用一种明确的对齐来达到目的。</p>

<ul>
<li>任何元素都不能在页面上随意安放。每一项都应当与页面上的某个内容存在某种视觉联系。</li>
<li>对齐的项会形成一个内聚的单元。</li>
<li>居中对齐显得正式、稳重，但一般不要用居中对齐。</li>
<li>一定要坚持页面上只使用一种文本对齐，避免混合使用多种文本对齐。</li>
<li>可以适时的打破规则，但在此之前得清楚什么是规则。</li>
</ul>


<h3>原则三：重复</h3>

<p>重复的根本目的是统一，并增强视觉效果。</p>

<ul>
<li>设计的某些方面需要在整个作品中重复</li>
<li>重复是一种全局的一致性，比如杂志每页的标题都使用同样的字体大小。这有利于信息的组织。</li>
<li>重复也一定程度给作品带来专业性和权威性。</li>
<li>要避免太多的重复，重复太多会让人厌烦。注意对比的价值</li>
</ul>


<h3>原则四：对比</h3>

<p>根本目的有两方面。一个目的是增强页面效果，如果一个页面看起来很有意思，往往更有可读性；另一个目的是有助于信息的组织。</p>

<ul>
<li>如果两项不完全相同，就应当使之不同，而且应当是截然不同。</li>
<li>对比一定要强烈。</li>
</ul>


<h3>应用设计原则</h3>

<p>优秀的设计就这么容易：</p>

<ul>
<li>1.学习4大基本原则;</li>
<li>2.认识到自己没有运用这些原则；</li>
<li>3.应用基本原则。</li>
</ul>


<p>这四个基本设计原则是相互关联的，只应用某一个原则的情况很少。当对应着一个个的举例体验过四条基本原则的威力后，接下来就是在自己身边实践这些原则了。</p>

<p>一方面，可以观察四项原则在现有设计中的应用：比如当前所打开的网页，是否足够清晰、明确的展示了它所要表达的意图；手头的书本，排版是否跟内容在情感上吻合。</p>

<p>另一方面，时常会有些文档、写报告、为展示写slides的需求，自己在创作的过程中，也可以应用起这四条原则，慢慢体会，慢慢修炼。</p>

<h2>体会</h2>

<p>歌德在《浮士德》中提到过这么一句话：『理论是灰色的，生活之树常青』。在我看来，所有的事物都是如此，人性使然。抛开这四条原则本身，它们归结起来都是要实现意图的传递：</p>

<blockquote><p>将信息从设计者准确无误的传递给目标用户</p></blockquote>

<p>设计作为一种原始信息的载体，本身的形式上会带来附加的信息量，如何让这些设计自身的附加量不混淆了核心的原始信息，是设计好坏的根本。更进一步，设计的更高层次应该是让设计的附加量起到正相关的增益效果。《写给大家看的设计书》中的四个原则正是最基础的实践。</p>

<p>现在是信息的时代，信息量的暴增让信息的简洁展示和选择变得越发关键。前文提到的扁平化的设计风格的崛起，就是一个例证:</p>

<p>『扁平化设计具有一种给你让人心醉的美丽，没有大量的修饰，它能以一个简单直白的方式传达一个信息或者帮助一个产品以及思想变得更加深入人心……扁平化设计正是通过放弃任何附加效果的方式，创建一个「零」3D属性的设计方案。在这里，没有阴影效果、斜角、浮雕、渐变等其他方法来帮助元素产生相对于屏幕的凹凸效果。不带有羽化边缘以及阴影效果的图标和UI元素也都看起来非常鲜明。』</p>

<p>相对而言，乔布斯推崇的拟物风格中，所秉承的是让所有用户能快速的学会如何使用它。而随着时代的发展，这种降低学习成本的方式渐渐的不是必须，数码产品充斥着生活，大多数人已经有足够的经验来应对新的操作体验。从这个角度讲，扁平化在现阶段或许是更有好的选择。</p>

<p>不管怎么样，WWDC以后，苹果股价已经持续下跌了，祝福苹果吧，希望Ive不要成为苹果的罪人，据说他是最懂乔布斯的人呢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac的GUI哲学]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/06/09/something-about-mac-gui/"/>
    <updated>2013-06-09T01:00:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/06/09/something-about-mac-gui</id>
    <content type="html"><![CDATA[<h2>GUI哲学</h2>

<p>前些日子，看了Tinyfool老师的一篇文章<a href="http://blogread.cn/it/article/1089?f=wb">《开发人员为何应该使用 Mac OS X 兼 OS X 小史》</a>，才恍然Mac系统可不仅仅是UI上与Windows大相径庭，而是自底而上的区别。这种区别渗透到了整个系统框架的设计理念中。</p>

<p>简单概括下我的认识：相比Windows和Linux两大阵营，Mac OS X除了『品味』上的优势之外，最重要的两点是：1.对GUI应用程序脚本化的有力支持；2.能实现GUI程序之间快捷的进程间通信。</p>

<h4>GUI程序之间的进程间通信</h4>

<p>IPC对于多用户分时系统的重要性不言而喻。其中从用户视角来看，如何让多个程序之间能更友好的交互是非常重要的。C++语言虽然面向对象，但在底层来看，其实依旧是冷冰冰的汇编代码，没有更整体的对象环境支撑，而以此构建的Linux也无法对进程间通信形成强力的支持。相比之下，乔布斯的团队借助于SmallTalk的消息传递机制创造了Objective-C，并搭建了自己的运行时和类库框架Cocoa，让系统无论从自身的迭代开发还是应用开发，得到了很大提升。值得一提的是，Objc虽然最近才由于iOS、Mac平台的开发的火热进入热门编程语言的行列，其实它比Java还早十年出生。像最近由于Rails框架而火爆起来的Ruby和持续坚挺的Java，都从SamllTalk中吸收了很多设计理念，就别提C#了。</p>

<h4>GUI应用程序的脚本化</h4>

<p>图形的交互方式确实人性化，但应用程序脚本化控制的方式在一些特定的场景里也可以大大提高生产效率。比如微软Office的VBScript。即使是一般用户，不愿意自己写脚本，脚本化的方式也能让开发人员更方便快捷的开发出新颖的功能和产品。</p>

<p>让应用全部统一开放脚本很难，特别是从市场的层面而言，如果没有一直贯彻这一战略，造成平台很多应用不支持这一功能，则很难推广。苹果九十年代已经开始积累这方面的基础，有先见之明。</p>

<h2>GUI工具</h2>

<p>下面是我接触过的一些Mac下的GUI工具。它们大都散发着对开发者的自由开放的态度:)</p>

<h3>Quicksilver</h3>

<p>『为了不把Mac当Windows用』，可以从<a href="http://qsapp.com/">Quicksilver</a>入手。它能将双手从触摸板中解脱出来，或许这是很多开发者的梦想吧;)。只需用热键激活输入框，输入简单的匹配字符串，就可召唤出某个应用，或者执行某些搜索、查找任务，快哉！</p>

<p>简单说说配置和使用方式：</p>

<ul>
<li>1.安装好后，在preference -> command中可以设置HotKey（唤醒的虚拟按键），我的习惯设置是<code>control+enter</code>。preference -> application可以设置是否需要在dock中显示，以及登入时自动启动。</li>
<li>2.基本功能：快捷打开应用。按下Quicksliver的HotKey（我的是<code>control+enter</code>）,在弹出的输入框中输入所需应用的头几个字母或者缩写，Quicksliver会自动匹配最可能的应用，并显示出来，如果不是自己想要的，可以移动「上下光标」打开下拉菜单选择。选中后回车即可，如图。</li>
</ul>


<p><img src="https://dl.dropboxusercontent.com/u/64021093/Pics/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202013-06-09%20%E4%B8%8B%E5%8D%881.23.22.png" title="Quicksilver示例" alt="Quicksilver" /></p>

<ul>
<li>3.还有很多其他的细节功能，通过Quicksliver的插件实现，可以根据自己的需求来定制。</li>
</ul>


<h3>Shortcat</h3>

<p><a href="http://shortcatapp.com/">shortcat</a>是Mac下的快捷操作利器。相比Quicksilver，Shortcat有不同的定位：通过键盘定位到屏幕上某窗体内的某个位置。其官网的示例就是如何通过Shortcat使用键盘更改DNS设置，注意，是完全不用鼠标噢。有人可能会想那为什么卜直接使用cmd呢？我想答案是Shortcat就是基于GUI的解决方案，是GUI和键盘快捷键的完美组合，与cmd并不冲突。</p>

<p>下面简单的交代下Shortcat的使用方式：</p>

<ul>
<li>1.快捷键<code>Cmd+Shift+Space</code>用来激活输入框。使用关键字的定位方式类似于Quicksilver。比如：如果目的是『Language &amp; Text』，那么输入『lt』、『lang』；『sa』代表show all，显示所能用于文字定位的区域。『.』能展示出所有可控制区域，包括没有文字定位的区域。</li>
<li>2.输入了关键字后，界面中被匹配到的模块会被套上不同颜色的方框。接下来，可以使用<code>control+key</code>重定位到对应位置，其中key为对应的匹配上的模块的字符标识。</li>
</ul>


<p><img src="https://dl.dropboxusercontent.com/u/64021093/Pics/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202013-06-09%20%E4%B8%8B%E5%8D%881.42.39.png" title="Shortcat示例" alt="Shortcat" /></p>

<ul>
<li>3.定位到合适的位置后，按下<code>enter</code>，可执行单击动作；对应的，双击<code>enter</code>为鼠标双击动作；如果需要配合其他按键的点击，比如<code>command+click</code>，执行<code>command+enter</code>即可；鼠标悬浮为<code>control</code>；双击<code>control</code>可实现聚焦。</li>
</ul>


<h3>GeekTool</h3>

<p><a href="http://projects.tynsoe.org/en/geektool/">GeekTool</a>类似于Windows下的widget，可以个性化的定制自己的桌面，添加插件，将CPU、HDD信息直接展示在桌面上，正如其名，Geek而又文艺!如下效果图：</p>

<p><img src="http://bbs.dgtle.com/data/attachment/album/201111/10/011505943pmpmm68enxwwd.png" title="GeekTool示例桌面" alt="GeekTool" /></p>

<p>详细配置可参考这篇文章<a href="http://www.dgtle.com/article-797-1.html">《教你装小清新—— Geektool &amp;&amp; Rainmeter 桌面皮肤推荐》</a></p>

<h3>Nocturne</h3>

<p><a href="http://code.google.com/p/blacktree-nocturne/downloads/detail?name=Nocturne.2.0.0.zip">Nocturne</a>这是桌面颜色控制的工具，与Quicksilver同为blacktree公司的产品。</p>

<p>使用方式：下载Nocturne2.0.0，解压后拖入应用程序文件夹，打开。在preference中可很直观的配置各项属性。其中，switch to night功能可以将Mac界面切换到黑夜模式，很好玩;)。</p>

<h3>参考：</h3>

<ul>
<li><a href="http://ksmx.me/blog/2012/03/18/customize-mac-desktop/">矮矬穷Mac桌面美化得瑟教程</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SDN：软件定义网络]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/06/08/software-defined-network/"/>
    <updated>2013-06-08T00:39:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/06/08/software-defined-network</id>
    <content type="html"><![CDATA[<p>最近高级网络课的小组任务是在老师给定的范围内自选方向主题研究并做展示报告。我们组选了sdn。原以为这东西会是工业界无人问津的概念化产品，Google了一下却发现其实sdn挺火的，由于它可能带来的可扩展性，一些大互联网企业也在开始涉足相关的研发，比如Google呵Facebook。这里简要的梳理下我对SDN概念性的认识。</p>

<h2>背景</h2>

<h3>虚拟化的大趋势</h3>

<p>近年来，大数据、云计算兴起，虚拟化技术的重要性越发突出。提到虚拟化，不得不提的是计算机行业里的一句老话：</p>

<blockquote><p>计算机世界的绝大部分问题都可以通过分层的方法来解决</p></blockquote>

<p>其实虚拟化也可以理解成一种分层的思想。就拿云计算这个应用场景来说，虚拟化的技术就是在原有的<code>硬件-操作系统-用户</code>层次中，增添了<code>虚拟机</code>这么一层，变成了<code>硬件-虚拟机-操作系统-用户</code>，用虚拟机来管理硬件资源，增加了动态调整硬件资源的语义。</p>

<p>纵观计算机的发展历程，各方面都可以看到通过增加类似的虚拟化层次来提高生产效率的案例。比如高级语言之于汇编，比如图形界面之于命令行。这种添加层次的解决方案，总是能让问题得到更清晰的解决。</p>

<h3>网络虚拟化</h3>

<p>网络经历了<a href="http://article.yeeyan.org/view/100437/70880">数十年的发展</a>，如今在人们的生产、生活中发挥着巨大的作用。全球的网络拓扑结构结构错综复杂，有许多的自制系统组成。数据包从中国的一台PC机发出，访问到美国的主机，需经过一系列的路由、转发，而经由的网络拓扑节点由层层网关、路由器支配，难于控制。一些组织，在架设自身的可扩展、大规模网络环境时，也同样遇到了拓扑结构复杂、难于维护的问题。</p>

<p>如果能剥离开网络的物理拓扑结构，将网络资源虚拟化，隐藏物理结构的复杂性，统一的进行逻辑层的管理控制，就能满足多变的网络需求了。</p>

<p>SDN和OpenFlow就是一个这样的解决方案。</p>

<h2>OpenFlow和SDN</h2>

<p>OpenFlow起源于斯坦福的Ethane项目。该项目试图通过一个集中式的控制器，让网络管理员可以方便地定义基于网络流的安全控制策略，并将这些安全策略应用到各种网络设备中，从而实现对整个网络通讯的安全控制。受到此项目的启发，斯坦福的老师和学生将Ethane的设计更一般化，将传统网络设备的数据转发(data plane)和路由控制(control plane)两个功能模块相分离，通过集中式的控制器(Controller)以标准化的接口对各种网络设备进行管理和配置。2008年，他们提出了OpenFlow的概念。</p>

<p>这种分布式的实现方式，让控制平面可以和转发平面物理的分离开，控制平面完全可以运行在运算能力更强的服务器上，而不是路由器。OpenFlow协议则是分离的两者之间的通信协议。关于OpenFlow的技术细节，<a href="http://network.51cto.com/art/201306/397443.htm">《虚拟化的逆袭：OpenFlow和SDN》</a>一文中有简明介绍。</p>

<p>基于OpenFlow为网络带来的可编程的特性，有研究人员提出了SDN即Software Defined Network（2009年）。在这个概念中，网络中所有的网络设备被视为被管理的资源，以此抽象出一个网络操作系统(Network OS)的概念，这个网络操作系统一方面抽象了底层网络设备的具体细节，同时还为上层应用提供了统一的管理视图和编程接口。SDN的架构细节，参见<a href="http://network.51cto.com/art/201211/366278.htm">《SDN是生意 OpenFlow是技术》</a>。</p>

<p>SDN和OpenFlow的关系，就像互联网之于TCP/IP协议栈。OpenFlow是SDN的核心协议，用于控制转发面设备的控制转发。而SDN是上层的变成界面。</p>

<p>有观点认为，『OpenFlow是技术，SDN是生意』。最近对SDN唱衰的报道也证明了这桩『生意』的前途未仆。</p>

<h2>SDN的发展</h2>

<p>在云计算飞速发展的同时，SDN也喧嚣尘上。Google,Facebook等大公司也结成了产业联盟，来推动其发展。</p>

<p>但其现状也并非一片明朗：</p>

<blockquote><p>根据IDC的研究结果显示，在2013年，整个企业网络行业的市场价值为420亿美元，其中将近一半来自2-3层网络交换机市场。SDN只能产生约37亿美元的价值(8.8%)，而且要到2016年才能达到这个数字。与早前的预测相比，IDC的预测数字有所增加，但从整个网络行业来看，SDN仍然相去甚远。</p></blockquote>

<p>一方面，SDN的性能还有待改善，另一方面，由于SDN的统一平台的思想，会带来硬件设备的同质化，威胁到厂商的利益，将会面临来自厂商锁定的阻力。<a href="http://www.csdn.net/article/2013-06-08/2815714">《理性看待SDN》</a>一文中有较详细的解释。</p>

<p>虽然虚拟化能解放生产力，是大势所趋，但就像功耗更大的复杂指令集在市场上战胜了精简指令集一样，市场是残酷的。只能期待开源和开放的脚步不要停下。</p>

<h3>参考</h3>

<ul>
<li><a href="http://blog.sina.com.cn/s/blog_72628e9f0100yg3b.html">什么是SDN(Software Defined Networking)？</a>
*</li>
<li><a href="http://blog.sina.com.cn/s/blog_5385c0b901010pu3.html">OpenFlow/SDN本质论</a></li>
<li><a href="http://article.yeeyan.org/view/323168/358956">软件定义网络(SDN)：是什么，如何工作，为什么重要</a></li>
<li><a href="http://network.51cto.com/art/201305/394648.htm">SDN：仍处于起步阶段</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《Hadoop技术内幕》学习笔记——RPC和动态代理]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/06/08/ipc-in-hadoop/"/>
    <updated>2013-06-08T00:24:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/06/08/ipc-in-hadoop</id>
    <content type="html"><![CDATA[<p>本文是《hadoop技术内幕——深入解析Hadoop Common和HDFS架构设计与实现原理》第4章的1-3节的学习笔记。内容为Hadoop IPC部分的基础知识介绍。</p>

<h2>知识框架</h2>

<p>由于Hadoop分布式环境需要一个更高效和正对性优化的IPC机制，传统的诸如RMI的解决方案无法满足这一要求，Hadoop自己实现了一套IPC方法。</p>

<p>第4章第1节讲解了RPC的原理，包括Stub-Skeleton的架构等，进而用<code>RMI</code>举例（可以参考的<a href="">演示代码</a>）。RMI的调用实现主要包括了服务器端的registry和客户端的lookup。虽然Hadoop不是使用RMI做IPC，但了解一下其调用方式对感性的认识到如何进行分布式环境下的远程调用还是有作用的。</p>

<p>接下来的2,3小节，简单的介绍了IPC过程所依赖的技术方法：Java的动态代理方式和NIO的网络传输方式。</p>

<p>第2节讲<code>动态代理</code>，这里需要理解面向对象的代理模式和<em>动态</em>的原因。代理模式分很多种，这里用到的是简单的对行为的传递。动态代理的动态特性，则是因为框架能提供动态创建某个接口的实现的能力(可以参考的<a href="">演示代码</a>)。</p>

<p>更系统的看动态代理过程，分为两个阶段：</p>

<ul>
<li>1.代理接口的实现：静态方法Proxy.newInstance()生成动态对象。</li>
<li>2.调用转发过程：InvocationHandler实现</li>
</ul>


<p>第3节的<code>NIO</code>，跟传统的套接字(Socket)通信过程做了对比。需要了解Socket通信的特点：同步，阻塞，基于字节，理解这种特点带来的服务器端的线程闲置的压力。对应的，NIO则是可异步的，非阻塞的，基于块的。具体的实现上，需要了解缓冲区(Buffer)的原理和使用方式，通道(Channel)和选择器(Selector)配合的使用方式。</p>

<p>我总结了一份slides，如下：(挂在speackerdeck上，如果加载缓慢，请稍候:))</p>

<script async class="speakerdeck-embed" data-id="fbcb8590b1540130690c2e6f0be13e84" data-ratio="1.33333333333333" src="http://biaobiaoqi.github.com//speakerdeck.com/assets/embed.js"></script>


<p>slides下载地址：<a href="https://dl.dropboxusercontent.com/u/64021093/slides/%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E5%92%8CNIO.pdf">请戳</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于毕业季照片分享的思考]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/05/25/some-ideas-about-using-bt-protocol-to-sync/"/>
    <updated>2013-05-25T22:47:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/05/25/some-ideas-about-using-bt-protocol-to-sync</id>
    <content type="html"><![CDATA[<h2>背景</h2>

<p>毕业季到了，女朋友跟班里同学们一起拍了很多照片。由于照片分散在不同的人的手机、相机里，她也无法立即给我传来她的照片。这个情景一年前我也遇到过，只是当时自己比较忙，加上考虑着还会在本校读研，也没太在意毕业季照片的手机这一需求，以至于到现在我的电脑里甚至没有一张我穿学士服的照片:-=。而现在，当我想看看gf的照片时，这个需求横亘在我面前，让我特别的想解决掉它。</p>

<p>让我们从事实出发，理清问题的思路。</p>

<h2>需求的产生</h2>

<p>大学生拍毕业季照的现状：</p>

<ul>
<li>1.大学生在毕业季拍照留念是刚需，几乎平日爱拍照、不爱拍照的所有人都会参与其中。</li>
<li>2.拍照一般以小团体为基本单元进行。多是班级、社团这种常见的凝聚力较强的团体。</li>
<li>3.随着科技的发展和生活水平的提高，越来越多的人具备了拍出高质量照片的设备和实力。</li>
</ul>


<p>由于这种以小团体为单位的照片的大量产生，每个团体中的照片会交叉散落在较多人手中。在这种分散的格局面前，单独挑选出自己的照片并保存的成本巨大，直接导致了大家最终需求的统一：</p>

<ul>
<li>将所有的照片分发到所有人手中。</li>
</ul>


<h2>原有解决方案</h2>

<p>现有的解决方案主要方案归纳为如下四种：</p>

<ul>
<li><p>1.用移动硬盘等设备人力拷贝</p>

<p>  这种方式太过古老和原始，缺点费时费力。</p></li>
<li><p>2.使用公邮、网盘、QQ群共享等方式统一上传、下载</p>

<p>  主要缺点是外网网速限制；另外，网速的限制让用户上传和下载的门槛变高，影响了上传积极性，如果有人迟迟不上传，最终下载完整数据的时间也会一直拖延，带来消极的体验；如果注册一次性账号，这也不见得是环保的行为（或许这想法有点数据洁癖吧>&lt;），如果使用非一次性账号，那么权限管理将比较头疼。</p></li>
<li><p>3.使用内网BT资源站分别打包上传、下载</p>

<p>  优点是利用了内网网速的优势。缺点是每个人都打包做种，会让资源分散的很厉害，难于汇集。且做种等步骤对于部分用户而言，有操作门槛。</p></li>
<li><p>4.先使用1中方法，统一手机照片数据，然后按照2或3的方法发布数据</p>

<p>  这大概是最靠谱的方式了，缺点集中在需要有人费时费力的手机数据上。当然，如果班里有一个任劳任怨的好班长，这个问题就解决了。</p></li>
</ul>


<h4>总结：</h4>

<p>对于一个懒人而言，现有的解决方案都是蹩脚的。这些解决方案都不约而同的希望首先将数据聚合到一个外部空间中，然后再统一的分发给大家。这个步骤必要吗？实际上，我们只是需要每个人都方便、快捷的获得所有照片。</p>

<h2>一个简单的设计</h2>

<p>我将问题抽象为：</p>

<ul>
<li>完整的数据分散在10至20个数据拥有者手中，需要通过一定手段，让每个个体都不重复的拥有完整的数据。</li>
</ul>


<p>由于外网网速的限制，基于校园内网建立的工具就有了天然的优势。但如果使用内网，就不得不抛弃各大公司免费提供的邮箱存储空间、网盘存储空间。而校内的资源是有限的，没有自己的服务器，没有足够的空间存储大家的数据，这也就迫使我们考虑到了p2p的系统架构。于是，有了这样的解决方案，设定代号为BBT：</p>

<ul>
<li>PC机安装BBT工具软件后，可以设定<code>共享目录</code>和对应的<code>分享ID</code></li>
<li>放入特定<code>共享目录</code>的文件，将使用基于p2p同步的方式，在拥有相同的<code>分享ID</code>的<code>共享目录</code>间同步数据，目的是让所有人都获得到每个人的数据</li>
</ul>


<p>在跟阿豪童鞋的交流中，他建议为了进一步简化用户操作，可以尝试这样一种体验方式：</p>

<ul>
<li>班级内所有人在同一个链接下载工具软件。保证这一链接下载的软件能互相通信，实现数据同步。这杨就节省了用户自己设定相同的<code>分享ID</code>的流程，而将这一过程转移到班长请求下载链接的过程中。</li>
</ul>


<p>确实够简洁，很赞，实现成本还需要调研。</p>

<h6>BitTorrent Sync</h6>

<p>在构思的过程中，突然想起前几天在start up news上看到了一个基于BT协议的同步软件<a href="http://labs.bittorrent.com/experiments/sync.html">BitTorrent Sync</a>。</p>

<p><img src="http://labs.bittorrent.com/img/wide/sync.png" title="BitTorrent Sync" alt="BitTorrent Sync" /></p>

<p>它的实现方式大概是我们所需要的。可惜的是，由于它的功能全面，界面略显复杂。而同时，它并没有开放二次开发接口。</p>

<p>或许我需要自己搭建一个p2p的系统？</p>

<h6>PS:</h6>

<p>BT的优势，在于利用了所有节点的存储和传输能力，节点数量越多，下载越快</p>

<p>BitTorrent  Sync的优势，则在于能动态的集合分散在不同节点中的数据</p>

<p>感觉这种去中心化的分布式系统，前景大大的有啊;)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[KMP算法实现]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/05/25/kmp-algorithm/"/>
    <updated>2013-05-25T21:22:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/05/25/kmp-algorithm</id>
    <content type="html"><![CDATA[<p>本文描述了单模式的字符串匹配的经典算法KMP算法的实现。首先对字符串匹配算法做简单的介绍，然后是KMP算法的实现描述，最后推荐两道简单的ACM模板题做练手用。</p>

<h2>字符串匹配算法</h2>

<p>字符串匹配(String Matchiing)也称字符串搜索(String Searching)是字符串算法中重要的一种，是指从一个大字符串或文本中找到模式串出现的位置。一个基本的字符串匹配算法分类如下：</p>

<ul>
<li>单模式匹配：即每次算法执行只需匹配出一个模式串。</li>
<li>有限集合的多模式匹配：即算法需要同时找出多个模式串的匹配结果，而这个模式串集合是有限的。</li>
<li>无限集合的多模式匹配：如正则表达式的匹配。</li>
</ul>


<p>单模式匹配最容易理解，构造也非常简单。一个最朴素的思路就是从文本的第一个字符顺次比较模式串，不匹配则重新从下一个字符开始匹配，直到文本末尾。Java实现代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'> <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">bruteforce</span><span class="o">(</span><span class="n">String</span> <span class="n">str1</span><span class="o">,</span> <span class="n">String</span> <span class="n">str2</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>         <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">!=</span> <span class="n">str1</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">)</span> <span class="o">{</span>
</span><span class='line'>               <span class="k">if</span> <span class="o">(</span><span class="n">str1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">str2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">j</span> <span class="o">++;</span>
</span><span class='line'>                    <span class="n">i</span> <span class="o">++;</span>
</span><span class='line'>                    <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">str2</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>               <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>                    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>               <span class="o">}</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>          <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>     <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是这种算法，有明显的效率黑洞。因为每次匹配失败后，都会回到原来的匹配起点的下一个字符开始匹配，这些步骤很多情况下，并不是必要的。</p>

<p>实际上这些字符很有可能已经被读入了一次。理论上，如果我们能对所有被读入过的字符有足够的了解，那就能判定是否能避免再次读入一遍做匹配运算了。经典的KMP算法正是基于这点思考，对原有的蛮力算法做出了优化。</p>

<h2>KMP算法</h2>

<p>网络上关于KMP算法的描述很多，其中个人觉得阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">《字符串匹配的KMP算法》</a>对KMP的描述最为简明和清晰。图例展示的算法流程更容易让人接受和理解。这里仅记录我所认为重点的知识点。</p>

<h5>算法的思想</h5>

<p>相比蛮力算法，KMP算法预先计算出了一个哈希表，用来指导在匹配过程中匹配失败后尝试下次匹配的起始位置，以此避免重复的读入和匹配过程。这个哈希表被叫做“部分匹配值表(<strong>Particial match table</strong>)”，它的设计是算法精妙之处。</p>

<h5>部分匹配值表</h5>

<p>要理解部分匹配值表，就得先了解字符串的前缀(prefix)和后缀(postfix)。</p>

<ul>
<li>前缀:除字符串最后一个字符以外的所有头部串的组合。</li>
<li>后缀：除字符串第一个字符以外的所有尾部串的组合。</li>
<li>部分匹配值：一个字符串的前缀和后缀中最长共有元素的长度。</li>
</ul>


<p>举例说明：字符串<code>ABCAB</code></p>

<ul>
<li>前缀：{A， AB， ABC， ABCA}</li>
<li>后缀：{BCAB， CAB， AB， B}</li>
<li>部分匹配值：2 （AB）</li>
</ul>


<p>而所谓的部分匹配值表，则为模式串的所有前缀以及其本身的部分匹配值。</p>

<p>举例如下：还是针对字符串<code>ABCAB</code>，它的部分匹配值表为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="n">A</span> <span class="n">B</span>
</span><span class='line'><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span>
</span></code></pre></td></tr></table></div></figure>


<p>这代表着：字符串<code>A B C A B</code> 中，子串<code>A B C</code>的部分匹配值为0，而子串<code>A B C A</code>的部分匹配值为1，诸如此理。</p>

<h5>算法实现</h5>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">next</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">kmp</span><span class="o">(</span><span class="n">String</span> <span class="n">str</span><span class="o">,</span> <span class="n">String</span> <span class="n">dest</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="c1">// i stands for index of str string, j stands for index in dest string.</span>
</span><span class='line'>  <span class="c1">// At the beginning of each loop process, j is the new position of dest</span>
</span><span class='line'>  <span class="c1">// taht should be compared.</span>
</span><span class='line'>  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="n">dest</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span>
</span><span class='line'>          <span class="c1">// This loop is to get a matching character recursively. Another</span>
</span><span class='line'>          <span class="c1">// stop condition is when particial match value meets end.</span>
</span><span class='line'>          <span class="n">j</span> <span class="o">=</span> <span class="n">next</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span><span class="c1">// As i in str and j in dest is comparing,</span>
</span><span class='line'>                          <span class="c1">// recomputing of j should be in the former</span>
</span><span class='line'>                          <span class="c1">// character substring, which is next[j-1]</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">dest</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span>
</span><span class='line'>          <span class="n">j</span><span class="o">++;</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">dest</span><span class="o">.</span><span class="na">length</span><span class="o">())</span>
</span><span class='line'>          <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">kmpNext</span><span class="o">(</span><span class="n">String</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="kt">int</span><span class="o">[]</span> <span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">()];</span>
</span><span class='line'>  <span class="n">next</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>  <span class="c1">// i stands for index of string, j is temporary for particail match</span>
</span><span class='line'>  <span class="c1">// values computing, at the beginning of each loop process, j is the</span>
</span><span class='line'>  <span class="c1">// particial match value of former character .</span>
</span><span class='line'>  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span>
</span><span class='line'>          <span class="c1">// This loop is to get a matching character recursively. Another</span>
</span><span class='line'>          <span class="c1">// stop condition is when particial match value meets end.</span>
</span><span class='line'>          <span class="n">j</span> <span class="o">=</span> <span class="n">next</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span><span class="c1">// j will be recomputed in the recursion. Take</span>
</span><span class='line'>                          <span class="c1">// care that next[j-1] is the particial match</span>
</span><span class='line'>                          <span class="c1">// value of the first j characters substirng.</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="c1">// If not in this case, j must</span>
</span><span class='line'>                                          <span class="c1">// meets end, equals to zero.</span>
</span><span class='line'>          <span class="o">++</span><span class="n">j</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">next</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">next</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>理解算法实现时，有几点特别需要注意：</p>

<ul>
<li>在生成部分匹配值数组的kmpNext()方法中，第一层循环内，<code>i</code>是字符串的索引，而<code>j</code>则在每次循环开始时代表了<code>i</code>所指定字符之前的子串的部分匹配值。</li>
<li>kmpNext()方法的内层while()循环，是为了迭代得到让<code>i</code>指定字符匹配到的情况。有另外一种实现方案：不有用这一层循环，而是直接使用一层循环，在大循环内部做j值变更的判定即可。</li>
<li>kmpNext()方法的while()循环中，需要特别注意是<code>next[j -1]</code>，部分匹配值j对应到的是字符串中的第<code>j-1</code>个字符。</li>
<li>kmp()的循环代码和kmpNext()部分匹配值表生成的循环代码很类似。两者使用了相同方式，在字符匹配失败后迭代获取新的可匹配情况，且都是利用了next数组。</li>
</ul>


<h2>其他</h2>

<p>KMP算法虽然能达到O(M+N)的算法复杂度，但在实际使用中，KMP算法的性能并不如<a href="http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html">BM</a>算法强。</p>

<h2>模板题</h2>

<h4>基础模板题</h4>

<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2203">HDOJ的2203题</a>是一个能检验算法正确性的模板题。Java实现的答案代码<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/practice/hdoj/HDOJ2203.java">请戳这里</a>。</p>

<h4>延伸模板题</h4>

<p><a href="http://poj.org/problem?id=2406">POJ的2406题</a>，对考察点做了巧妙的变形，对更深入的理解KMP中的部分匹配表（即next数组）很有帮助。Java实现的答案代码<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/practice/poj/POJ2406.java">请戳这里</a>。</p>

<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1867">HDOJ的1867题</a>也属于kmp的变形。要求对kmp利用next数组进行比较的过程有清晰的认识。Java实现的答案代码<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/practice/hdoj/HDOJ1867.java">请戳这里</a>。</p>

<h3>其他参考资料：</h3>

<ul>
<li><p><a href="http://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm">wiki:Knuth–Morris–Pratt Algorithm</a></p></li>
<li><p><a href="http://en.wikipedia.org/wiki/String_searching_algorithm">wiki:String Searching Algorithm</a></p></li>
<li><p><a href="http://www.cppblog.com/converse/archive/2006/07/05/9447.html">《KMP算法的实现》</a></p></li>
<li><p><a href="http://wangcong.org/blog/archives/2090">《Linux 内核中的 KMP 实现》</a></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《程序员的思维修炼》]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/05/22/pragmatic-thinking-and-learning-refactor-your-wetware/"/>
    <updated>2013-05-22T01:14:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/05/22/pragmatic-thinking-and-learning-refactor-your-wetware</id>
    <content type="html"><![CDATA[<h3>别鄙视方法论</h3>

<p>曾经很长时间里，我这么认为：方法论的东西没什么实际的用处，不过是其他人按照自己的喜好来处理事物的途径而已，何必照着他人的思路。比如，作为一只不靠谱的程序猴子，在一些偏颇的思维习惯的影响下，我甚至对许多图形化的东西比较反感，自以为文本信息已经足以表达清楚事实且更有效率，从而本能的回避能造成视觉冲击的事物。直到后来，发现自己每每定下的计划都无法完整实施，自然也是没有收到预期的效果。我开始关注到方法本身是否合理，寻找那把平衡效率和体验的钥匙。</p>

<p>这本书给出了一个很好的答案。</p>

<p>虽然标题上赫然是“程序员”几个大字，但其实并没有这么局限。这是一本谈论思维习惯的书，对所有想了解大脑认知过程以更好的发觉其潜能的读者而言，都是可以参考的。虽然自己只是看完了这本书，而没有长期实践的效果证明，但从以往的经验来看，它的观点总能让我信服。</p>

<!--more-->


<p>下面是我印象最深刻的观点的总结：</p>

<h2>德雷福斯模型（Dreyfus）</h2>

<p>技能获取领域的模型。这个模型针对于某个技能而言，是一个情景模型。他将技能的掌握分为5个阶段：</p>

<ul>
<li>新手 -> 高级新手 -> 胜任者 -> 精通者 -> 专家</li>
</ul>


<p>新手和专家最主要的区别在于【直觉】：新手需要与情景无关的规则让他们高效工作，而专家则相反，他们更多的使用【情景】相关的直觉。（我不觉得需要记住所有这五个阶段，只需要知道，这是一个不断积累知识、培养思维习惯的过程。）</p>

<h2>认识大脑</h2>

<p>大脑的配置是双CPU，单主机总线的。</p>

<ul>
<li>线性模式的L（左脑）：主要负责线性、【逻辑思维】和【语言处理】。它按部就班的处理指令，相对缓慢，使用了大脑中较少的一部分资源。</li>
<li>富模式的R（右脑）：大脑的Google，负责搜索、模式匹配。它是异步执行的，【非理性】的。可能某个想法几天后才突然跳出来。它不做任何语言处理，这意味着它的结果也不是语言能表达的。它的处理只能邀请，不能强制命令 。我们可以时常记录各种想法，让它运转，以激发它的活跃状态。</li>
</ul>


<p>这两个CPU共享通过内存核心的总线（意识），每次只有一个CPU可以访问内存。</p>

<p>值得注意的是，积极的情感对学习和创造性思维非常关键。处于“高兴”的状态可以扩展你的思维过程，激活更多的大脑物质。</p>

<p>理解了大脑的工作模式，以及它们的不同和对实际思考能力的作用，就大概知道了平时应该怎么使用它对自己而言更有效。</p>

<h2>充分利用右脑</h2>

<p>需要强调R的功能，因为它关系着【直觉】，而这正是成为专家的必经之路。</p>

<ul>
<li><p>多感官的输入，能获得更高的效率。比如软件工程中使用CRC卡片做设计，或者使用积木、乐高玩具做架构设计。</p></li>
<li><p>大脑善于适应变化的环境。因此，要定期改变环境，满足你的大脑。任何一种感官的参与都可能是有益的。（当年还强迫自己不间断的工作，既累又不讨好>&lt;…）</p></li>
<li><p>在学习技能时，可以用R型探路，掌握全局，而后用L型紧跟，两者配合好。（举例参见读书的SQ3R方法）</p></li>
<li><p>隐喻是一种激发创造力的强大技能，它能很好的沟通好L和R型处理能力。幽默感正是这种从不同的想法中创造新奇的联系的方式，幽默感可以建立更强大的隐喻。</p></li>
<li><p>大脑在处理不同的输入时，差别并不大。记忆不是永远不变的，每次提取记忆，也会重构记忆。我们可以通过提供给自己有益的暗示，来促进自身进步。</p></li>
<li><p>一切输入都会被存储。如果被存储的事物之间有好的区分度， 那就更容易在查询时被检索到。举个编程的例子，源代码的阅读次数远远多于它的编写次数，所以通常应该花更多功夫把代码变得适合阅读，让代码风格和注释更易于阅读，会事半功倍。</p></li>
<li><p>晨写和无目的的散步这种方式，能活跃右脑，增加R型工作的机会。</p></li>
</ul>


<h2>调试大脑</h2>

<p>大脑有一些固有的偏见，比如自以为是。我们需要对这些点予以关注。</p>

<ul>
<li><p>每个人个性倾向不同，处理事儿的方式也不相同。（推荐<a href="http://www.apesk.com/mbti/">MBTI测试</a>，这里是我的<a href="http://biaobiaoqi.me/blog/2013/05/12/mbti-test/">测试结果</a>。）</p></li>
<li><p>重要的是要认识到：在某种情况下，别人的反应行为和你所设想的不一样时，他们并不是疯了、懒惰或者非常难以相处。你也不是。</p></li>
<li><p>遇到问题，深呼吸，包托变味的空气。深深吸气。数到十。记住你是高级动物。让蜥蜴式的相应过去，请新大脑皮层来处理问题。</p></li>
<li><p>既然性格和技能水平各异，可能奖励措施也应该各式各样才对。否则奖励反而让获奖人感到不自在。</p></li>
<li><p>大脑会偷懒，很多时候，我们的看法是基于预测的。</p></li>
</ul>


<h2>主动学习</h2>

<h5>SMART方法</h5>

<p>学习过程中，使用目标激励的方式会很有效（早年自己没目标，还老找借口说没目标自己也会不断努力的…汗颜）遵循SMART方法（这么多条，没必要全记住，核心就在用目标激励前进）：</p>

<ul>
<li>Specific：将目标具体化</li>
<li>Measurable：让目标能度量</li>
<li>Achievable：目标不能是空想，要能够实现</li>
<li>Relevant：要与自己足够相关，才能更大化其效益</li>
<li>Time-boxed：时间上可控，有最后期限</li>
</ul>


<h5>学习方式分类</h5>

<p>每个人对学习方式的敏感度不一样，学习者分三类：</p>

<ul>
<li>视觉型：需要看到学习资料和老师，对图片，图表，老师的肢体语言和面部表情敏感。</li>
<li>听觉型：需要听到学习材料，对讲座、研讨会、播客敏感</li>
<li>动觉型：通过活动和触摸来学习，需要亲身感受来学习材料</li>
</ul>


<p>每个人都有自己的默认属性，比如倾向于视觉型或者其他。有时候，尝试不同的学习类型，或许会带来灵感。</p>

<h5>SQ3R</h5>

<p>书面指令的传递一般是最无效的，大脑处理语言相关部分很小，除此以外，大脑整个剩余部分都不懂语言。常规的阅读方式效率很低，这里推荐一种主动阅读方式，大家可以按需参考。</p>

<p>SQ3R主动看书法：</p>

<ul>
<li><ol>
<li>调查（Survey）：扫描目录和每章总结，得出总体看法。</li>
</ol>
</li>
<li><ol>
<li>问题（Question）：记录所有问题</li>
</ol>
</li>
<li><ol>
<li>阅读（Read）：阅读内容</li>
</ol>
</li>
<li><ol>
<li>复述（Recite）：总结</li>
</ol>
</li>
<li><ol>
<li>回顾（Review）：重读，拓展笔记，与同事讨论。</li>
</ol>
</li>
</ul>


<h5>思维导图</h5>

<p>思维导图是一种图表，显示各个主题和它们之间的关系。</p>

<ul>
<li><p>思维导图的颜色信息、形状信息大大增加了表达的丰富性，让人更容易接受，易于理解。</p></li>
<li><p>多次迭代思维导图图，可以充分利用起R型的思维。</p></li>
<li><p>当陷入没有明确思路的混沌状态时，思维导图有助于理清思路，指引方向。</p></li>
<li><p>另外，跟思维导图一样，记录文档也是不错的选择。或许文档不会有人看，但记录的过程，能促进思考。</p></li>
</ul>


<h2>经验</h2>

<ul>
<li><p>在最后期限面前，对L型活动可能有激励，但对R型活动是一种灾难。压力扼杀了认知。</p></li>
<li><p>我们是天生的模仿者，如果身边的人技能水平高，那么我们一般会潜移默化的向他们学习，继而提高自身水平。</p></li>
<li><p>语言描述不是一个最好的教学方式。人脑只有很少计算资源在做语言处理。用更多形象的，比如声音、图形、动过可以更好的促进学习。</p></li>
</ul>


<h2>注意力</h2>

<p>保持注意力的三点：</p>

<ul>
<li>1.学会安抚喋喋不休的L型思维。</li>
<li>2.主动在前进中思考和增强思想，即使是不成熟的。</li>
<li>3.明确情景切换的昂贵代价，尽可能避免。</li>
</ul>


<p>注意力修炼：冥想</p>

<ul>
<li>寻找一个安静的地方，舒适、清醒的坐着，挺直背</li>
<li>闭上眼睛，集中注意力到呼吸上</li>
<li>注意呼吸节奏，不要试图改变它，只是感觉。不要与自己交谈。每当发现自己在思考一些问题或与自己交谈，及时抛弃这些想法，轻轻将注意力回到呼吸上。</li>
</ul>


<p>查邮件等会打扰工作状态，这种打扰，会让之后的二十分钟甚至更长无法进入工作状态。这是一种情景切换，大脑不善于情景切换。</p>

<h2>超越专家</h2>

<p>做到有效的改变很难。以前的习惯依然存在在大脑里。当回到某个旧习惯时，不用懊恼。承认它，大脑就是这样工作的。当意识到它的出现时，重新回到正确的道路上去。</p>

<p>即使成为专家，也要意识到局限性：可能创新不足，过于相信意识等。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《Facebook效应》]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/05/21/the-facebook-effect/"/>
    <updated>2013-05-21T00:23:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/05/21/the-facebook-effect</id>
    <content type="html"><![CDATA[<p>前两年风靡了一阵子的电影《社交网络》毕竟是电影，一种艺术的方式的表达。虽然无法完全的印证《Facebook效应》一书中记载的正确性，但其细节足以给人启示。</p>

<p>电影中，主人公炫酷的人生经历能催生观者产生极强的代入感，不少同学看后可能就会想着自己在寝室特立独行的捣鼓几下，也来做出个震惊世界的产品。且慢。细读本书，就会了解到，成功并非像电影中所描述的那么轻松愉快和力所能及。</p>

<p>以下是我的一些总结。</p>

<!--more-->


<h2>团队</h2>

<p>先来看看扎克伯格的经历。</p>

<blockquote><p>“他几乎赢得了在高中时期能得到的所有荣誉和奖项，获奖科目中有数学、天文学、物理学甚至是古典文学，还是击剑队队长和最有价值队员，能读写发育、希伯来语、拉丁语和古希腊语”</p>

<p>“扎克伯格就读的飞利浦爱思特中学是一所精英云集的高中，哪里的学生能进入常春藤联盟的任何一所高等学府”</p>

<p>“扎克伯格不断创造出一些在网上运行的小程序，其中又一个能帮助他快速强记‘高古斯都时代的艺术’的考试内容”</p>

<p>“扎克伯格如今这样说，‘那一年我做了12个项目。当然，那个项目都不是我全权负责的‘，他说，大多数都是关于’发现人们如何通过相互参照建立联系‘’”。</p></blockquote>

<p>而之后的TheFacebook，也并非一蹴而就的发展为如今的Facebook，它的想法来自于当时常春藤名校之间关于在线花名册、照片的需求以及对社交、分享的一直以来的思考，而非电影中几杯啤酒、几个小时的facemesh。实际上，扎克伯格也并非孤注一掷。一直到2004年夏天之前，他还只是将飞速发展的Facebook当做自己经手的一个项目，以规避自己所投入中存在的风险，他同时又与另一个天才程序员合作了另外一个项目wirehog，甚至为它成立了公司，直到试运行失败后才收手。</p>

<p>另外，扎克伯格的各路圈子的朋友中不乏IT界精英，他们有着高智商，良好的教育背景或者传奇的过往经历和远大理想。他们可能在中学时就已经写出影响行业圈的软件，可能有各行业经营公司的职业背景、经历，可能精通文史、商业哲学。记得以前被老师告知了一句话，“一个人的收入约等于最亲密的六个朋友的收入的平均值”。可能扎克伯格做不到这一点了，他会是最高的吧=。=</p>

<h2>扎克伯格的性格</h2>

<ul>
<li>冷静、不善公开与人对抗</li>
</ul>


<p>成功者都是偏执的。扎克伯格不易动感情，热切他很少显露出情绪。这种表面平和的独特个人魅力，是他吸引人才投靠他的一个关键因素，同时也使人们对他恼火的一重要原因。</p>

<ul>
<li>扎克伯格善于听取各方面意见，然后做出自己的结论</li>
</ul>


<p>在Facebook发展到06年时，扎克伯格的角色开始发生变化，但他似乎没有控制好这个变化。在前期为他招揽人才的罗宾说“公司高管们的士气正在跌落，流言满天飞，而马克没有对任何人说明真正发生着什么。管理团队几乎准备要把扎克伯格拉下马”。这引起了罗宾的不满。扎克伯格对待罗宾的指责时，并没有抵触，而是欣然接受。这种气魄是他对产品本身追求大过对虚荣的提现。他善于倾听，吸取意见。他顺利的转变了CEO的角色。</p>

<ul>
<li>理想远大，目标明确</li>
</ul>


<p>他对Facebook的决策，从来都是为了让它在之后成为更伟大的产品，而不是为了一时的利益。因此一直以来都排斥一般形式的广告。他也一直坚持着对公司的控制权，让一切在他的掌握之下。</p>

<ul>
<li>坚韧</li>
</ul>


<p>大部分人会给自己设定里程碑，达到里程碑后，会稍作休息，从而获得征服感和满足感。扎克伯格不会。这大概是他的天赋吧。正常人就不要效仿了，反而会拖垮效率的。</p>

<h2>产品的演变</h2>

<p>Facebook的发展过程中，并非是一直特立独行。与此同时的互联网世界，在社交范围内的公司也是层出不穷，不乏竞争对手。但经过不断的产品迭代创新，Facebook达到了目前的高度。</p>

<ul>
<li>1.图片分享</li>
</ul>


<p>曾在Facebook上尝试wirehog，一个多媒体分享工具，没有成功。之后，当发现用户对更换主页图片感兴趣后，Facebook准备开发新的图片分享功能。而为了与挖掘出社交的能力，考虑到了以图片中的人名来设置标签，并相应的给标记的人发送消息通知。这是扎克伯格的理想中重要的一环，他以越来越广泛的理论来阐释了社交的意义。</p>

<ul>
<li>2.动态新闻</li>
</ul>


<p> 创造的是一种订阅朋友信息的方式，先例是RSS（简易信息聚合）。</p>

<ul>
<li>3.开发注册到所有用户</li>
</ul>


<p>经过对全社会开发注册和动态新闻的两件事情的领导之后，扎克伯格作为一个领袖的声望在Facebook腾云直上。</p>

<ul>
<li>4.应用平台。</li>
</ul>


<p>成为其他应用程序在上面运行的软件平台是软件技术一行最为光荣的终极目标。Facebook有着自传播力，这是平台的优势。</p>

<ul>
<li>5.定制式的广告系统</li>
</ul>


<p>精准的广告。相比Google按需求搜索广告，Facebook则是希望利用人际关系网，为用户产生需求，让用户找到自己所想要的东西。桑德伯格的到来，让Facebook建立起了合理的商业模式。</p>

<ul>
<li>6.翻译</li>
</ul>


<p>利用用户产生翻译内容的自动化翻译工具。在世界扩张。</p>

<ul>
<li>7.Facebook联谊会</li>
</ul>


<p>授权其他网站调用Facebook的资料等</p>

<ul>
<li>8.twitter迅速发展</li>
</ul>


<p>twitter迅速发展对Facebook形成了压力。Facebook为此进行了改版。改版被不少用户反对，扎克伯格提出了公平投票的方式来决定。他把用户视作公民。</p>

<ul>
<li>9.开放信息流API。</li>
</ul>


<p>Facebook不怕流量因此被分流，他们希望Facebook成为一个基础架构。</p>

<h2>初期发展</h2>

<p>初期发展中，Facebook的团队也会犯严重的错误，比如源代码被开放给所有用户，比如广告导引错误。但相信那种自由状态下的发展，是足够<strong>高效</strong>的。</p>

<blockquote><p>马克安德森支持扎克伯格：“一个快速成长的公司，是没有办法可以一直做出正确的决定的。更好的办法是，快速修正不可避免的错误决定。”</p></blockquote>

<p>虽然王淮描述工程师文化时说道，需要重复两遍以上的事儿，Facebook都会开发出工具去自动化的实现。个人推论，这更多的是在公司获得千万投资，开始扩招员工以后的事情。在初期的发展阶段，即使是牛逼如扎克伯格、莫斯科为茨的人，也被快速发展的步伐所牵制。而当员工数量达到一定规模，有了足够多的人才后，才开始逐步形成了现在的Facebook的工程师文化。</p>

<h2>市场</h2>

<p>大学生市场是一块宝地。</p>

<p>大学生们不看电视，不看报纸，而他们将迎来第一张信用卡，第一个银行账户等等。名校更是拥有强大的号召力，优越感。早期Facebook发展时，没有对外开放，将各个学校一一增加到可注册用户范围内，用一种自己可以把控的节奏，维持了发展的平衡。避免了飞速发展带来的服务器端的巨大压力。</p>

<h2>Facebook的定位</h2>

<p>社交需求的理论基础是馈赠型经济。更多介绍，参见<a href="http://biaobiaoqi.me/blog/2013/05/13/free-the-bit-economics/">《免费》中关于非货币市场章节描述</a></p>

<p>扎克伯格的梦想是赋予每个人权利，对于他自己来说，Facebook能解决的最重要的问题就是给人们提供工具，让他们更好的交流。</p>

<p>Facebook建立在一个激进的社会假说下，即认为现代社会在不可避免的逐步超公开透明的方向发展。扎克伯格说“这个世界的透明程度将不会再允许一个人拥有双重身份。换句话说，即使你希望把私生活和职场分开，你也不可能做到，因为关于你的信息正在互联网和其他各个地方传播。”</p>

<p>Facebook希望最终成为一个基础架构。Facebook只是其用户集体行动的表征，除此之外，它什么都不是，Facebook上会发生什么完全取决于用户兴趣所在。但扎克伯格对无聊的应用感到失望，那确实很多用户的真实需求。</p>

<p>Facebook不是浪费时间，而是帮助人们理解他们身边的世界。扎克伯格不希望人们太粘Facebook，希望他们多花时间去找朋友，与他人交流互动。<em>所以Facebook的界面是中性的，没有表现出态度</em>。</p>

<p>有管理学家如是评价“历史上只有两个基本方法去集中和扩散人们的才能，它们就是<em>官阶体制</em>和<em>市场</em>。而在最近十年，增加了第三个——网络，他让我们能够协同工作对付一些棘手的问题，但也削弱了掌权者的力量，通常只有掌权者可以决定谁可以知道什么。”</p>

<h2>Facebook vs  Google：</h2>

<ul>
<li>Google是针对于数据的，认为整合全世界的数据是最重要的事情，而Facebook是针对于人的。</li>
<li>Google会收集到所有数据，而Facebook是在用户乐于分享的前提下，自己上传数据</li>
<li>Google：不作恶；Facebook ：别因为赚钱而做差劲的事儿。</li>
</ul>


<h2>争议：</h2>

<ul>
<li><p>在可靠的控制个人信息的愿望与不经意间的社会沟通之间，很可能存在着不可协调的矛盾。</p></li>
<li><p>Facebook应该鼓励用户纰漏多少个人信息。有关这个话题的讨论一直贯穿了公司的整个发展历程。</p></li>
<li><p>身份识别系统可能妨碍公民的自由。</p></li>
<li><p>Facebook为何有权利拥有大家的真实身份。</p></li>
<li><p>当Facebook打通了支付渠道，成为一个全球化的经济体，银行不高兴了</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hadoop和RDBMS的混合系统介绍]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/05/20/hybrid-distributed-data-management-system/"/>
    <updated>2013-05-20T14:52:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/05/20/hybrid-distributed-data-management-system</id>
    <content type="html"><![CDATA[<p>现在大数据概念被时常提起，社会各界对其关注度越来越高。往往越是火热的东西，人们越容易忽略它的本质。在slides中，我首先按照自己的理解，简单的理顺数据处理领域的发展历程。之后，落脚点是两个比较有代表性的混合的分布式系统：<a href="http://biaobiaoqi.me/blog/2013/05/18/a-hybrid-system-hadoopdb/">HadoopDB</a>和微软的<a href="http://biaobiaoqi.me/blog/2013/04/25/split-querying-process-in-polybase/">Polybase</a>。由于缺乏实战经验，很多东西由各方论文和博文中得到，有不恰当的地方，欢迎大家拍砖讨论;)</p>

<p>slides的提纲如下：</p>

<!--more-->


<h2>提纲</h2>

<h3>背景</h3>

<ul>
<li>RDBMS的出现</li>
<li>大数据时代到来</li>
<li>NoSQL技术</li>
<li>新时代的挑战</li>
</ul>


<h3>HadoopDB</h3>

<ul>
<li>PB级数据分析</li>
<li>HadoopDB是什么</li>
<li>框架和组件介绍</li>
<li>示例</li>
<li>总结</li>
</ul>


<h3>Polybase</h3>

<ul>
<li>Polybase总览</li>
<li>PDW结构</li>
<li>Polybase的实现</li>
<li>性能分析</li>
</ul>


<p>slides在线展示：</p>

<script async class="speakerdeck-embed" data-id="77bdc950a3460130c98a12e3c5740641" data-ratio="1.33333333333333" src="http://biaobiaoqi.github.com//speakerdeck.com/assets/embed.js"></script>


<p>slides下载：
<a href="https://dl.dropboxusercontent.com/u/64021093/slides/Hybrid%20system.pdf">请戳这里</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分布式一致性]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/05/18/distributed-consistency/"/>
    <updated>2013-05-18T18:58:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/05/18/distributed-consistency</id>
    <content type="html"><![CDATA[<p>本文来自<a href="http://book.douban.com/subject/3108801/">《分布式原理与泛型》</a>的一致性章节笔记。由于缺乏实践经验，这本书对我来说太过理论，难于理解，现在已经暂停该书的阅读，转而加强实践。另有相关博文<a href="http://biaobiaoqi.me/blog/2013/05/15/cap-and-eventual-consistent/">《CAP和最终一致性》</a>，可供参考阅读。</p>

<!--more-->


<h3>1.分布式的一致性概述</h3>

<p>分布式系统的一个重要问题是数据的复制。对数据的复制一般有两个原因：</p>

<ul>
<li>1.增加系统的可靠性，防止单点失效的问题；</li>
<li>2.提高系统性能，利用不同地理位置的副本迅速响应用户需求。</li>
</ul>


<p>数据复制的主要难题是保持各个副本的一致性。即在更新一个副本时，必须确保同时更新其他的副本，否则数据的各个副本将不再相同。</p>

<h3>2.以数据为中心的一致性模型</h3>

<p>一致性模型实质上是进程和数据存储之间的一个约定。正常情况下，一个数据项上执行读操作时，它期待该操作返回的是该数据在其最后一次写操作之后的结果。在没有全局时钟的情况下，精确的定义哪次写操作是最后一次写操作是十分困难的。于是就产生了一系列用其他方式定义的一致性模型。</p>

<h4>2.1 持续一致性</h4>

<p>有人提定义了区分不一致性的三个互相独立的坐标轴：副本之间的数值偏差，副本之间新旧程度偏差以及更新操作顺序的偏差。</p>

<p>数值偏差可以这样理解：已应用于其他的副本，但还没有应用于给定副本的更新数目。</p>

<p>文中使用了<a href="http://en.wikipedia.org/wiki/Vector_clock">向量时钟</a>来举例对一致性单元进行持续抑制性分析，</p>

<h4>2.2 严格一致性</h4>

<p>任意read(x)操作都要读到最新的write(x)的结果。
依赖于绝对的全局时钟，实际系统不可能做到。</p>

<h4>2.3顺序一致性</h4>

<p>对于一些读写写操作的集合，所有进程看到的都是同样的顺序。也就是将并行的操作序列化，而且每个进程得到的序列都相同。</p>

<p>那么，很自然对于同一个进程执行的操作，必然要按照它们执行的顺序出现。</p>

<h4>2.4因果一致性（Casual Consitency）</h4>

<p>要求：</p>

<p>有因果关系的写操作必须按照它们的因果关系的顺序被看到，没有因果关系的写操作可以以任意顺序被别的进程看到。</p>

<p>例如：(其中[&#8230;.]是占位符，表示没有操作)</p>

<blockquote><p>进程1  W(x)a 将x写成a
进程2  [..]R(x)a W(x)b
进程3  [&#8230;.]R(x)a R(x)b
进程4  [&#8230;.]R(x)b R(x)a</p></blockquote>

<p>进程3和1、2是满足因果一致性的，加上4就不满足了。因为进程2是由于读到x=a才把x写成b的，所以W(x)a和W(x)b之间有因果关系，必须按照因果的顺序出现。</p>

<p>相比顺序一致性，去掉了那些没有联系的操作达成一致顺序观点的要求，只是保留那些必要的顺序（有因果关系的）。</p>

<h4>2.5入口一致性（Entry Consistency）</h4>

<p>其实也就是对每个共享数据定义一个同步变量（即：锁）。当然，没有进行同步就进行的读操作结果是不保证的。</p>

<h3>3 客户为中心的一致性</h3>

<p>也就是从用户视角来看数据是一致的。只是关心数据最终会一致（eventually consitent）。</p>

<p>只要保证对于同一个用户，他访问到的数据是一致的就可以了。如果用户只是访问一个副本，这个就很好实现，否则就需要一定策略了。当没有更多的更新的时候，要保证当前的更新会最终传播到所有的副本上。著名的例子有：DNS系统，万维网。</p>

<p>但最终一致性需要注意一个典型的问题。即当客户访问不同的副本时，问题就出现了。更具体的例子比如，博客作者更改了一篇博文内容，在A地的用户先访问到最新的内容，而B地由于离博客服务器远，看到的还是原先的内容。</p>

<p>对于最终一致性的的数据存储而言，这个示例很有代表性。问题是由用户有时可能对不同的副本进行操作的事实引起的。以客户为中心的一致性分为如下几大类：</p>

<h4>3.1 单调读（Monotonic Reads）</h4>

<p>当进程从一个地方读出数据x，那么这个以后再读到的x应该是和当前x相同或比当前更新的版本。也就是如果进程迁移到了别的位置，那么对x的更新应该比进程先到达。这里的客户就是指这个进程。</p>

<h4>3.2 单调写（Monotonic Writes）</h4>

<p>跟单调读相应，如果一个进程写一个数据x，那么它在本地或者迁移到别的地方再进行写操作的时候，原来的写操作必须要先传播到这个位置。也就是进程要在任何地方至少和上一次写一样新的数据。</p>

<h4>3.3 Read your writes</h4>

<p>一个进程对于数据x的写操作，那么进程无论到任何副本上都应该看到这个写操作的影响，也就是看到和自己写操作的影响或者更新的值。</p>

<h4>3.4 Writes follow reads</h4>

<p>顾名思义了，也就是在读操作后面的写操作要是基于至少跟上一次读出来一样新的值。也就是如果进程在地点1读了x，那么在地点2要写x的副本的话，至少写的时候应该是基于至少和地点1读出的一样新的值。</p>

<h3>4 副本放置（Replica Placement）</h3>

<h4>4.1 放置的三个方法</h4>

<p>Permanent replica/永久副本: 选几个固定位置放置副本，镜像呈现。</p>

<p>Server-initiated/服务端发起: 服务端动态决定什么时候向什么地方分发副本，又称push cache</p>

<p>Client-initiated/客户端发起: 客户端缓存,client cache</p>

<h4>4.2 更新传播</h4>

<h5>4.2.1 传播什么？</h5>

<ul>
<li>可以是更新的通知（客户自己来取）</li>
<li>可以是更新后的数据</li>
<li>可以是更新的操作</li>
</ul>


<h5>4.2.2 谁来传播</h5>

<ul>
<li>服务器push或客户pull</li>
</ul>


<h5>4.2.3 传播协议？</h5>

<ul>
<li>保证最终会收敛到一致</li>
</ul>


<h4>4.3 复制协议（Replication Protocols）</h4>

<h5>4.3.1 远程写（Remote-Write）协议</h5>

<p>对于数据x有一个主副本，当没有x副本的服务器操作x的时候就会得到一个x的副本。而有x副本的服务器响应客户读请求的时候可以立刻返回。而当客户进行写操作的时候，写操作首先在主副本完成，然后再通知其他副本更新。</p>

<h5>4.3.2 本地写（Local-Write）协议</h5>

<p>和远程写比较类似，不同点是当一个服务器得到了副本以后就成了新的主副本，以后的写操作首先在本地完成，然后再通知其他的副本，本地写的名字由此而来。</p>

<h5>4.3.3 主动复制（Active Replication）</h5>

<p>对于副本的操作要设计到另外一个单一对象。比如，n个副本代理对象C的一个接口，如果向所有副本发出请求，每个副本都会发一个请求到C，那么同样的操作就执行了n次。所以需要一个协调者。另外，多副本返回值的时候也会有同样的情况。所以这种只执行一次的动作需要副本种有一个协调者，保证操作只被执行一次或者只返回一次。</p>

<h5>3.3.4 基于候选团（Quorum-Based）协议</h5>

<p>也就是读操作要得到r个服务器的同意，写操作要得到w个进程的同意。总共有n个进程。r和w要满足以下条件：</p>

<ul>
<li>r＋w > n 这样就不可能同时发生读写，并且读到的server肯定有一个以上被更新过的</li>
<li>w > n/2   这样就不可能同时发生两个写</li>
</ul>


<p>也就是类似于投票获得读写的锁。在Dynamo系统中可以配置这种wrn参数以自持特定的一致性。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HadoopDB：混合分布式系统]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/05/18/a-hybrid-system-hadoopdb/"/>
    <updated>2013-05-18T17:58:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/05/18/a-hybrid-system-hadoopdb</id>
    <content type="html"><![CDATA[<p>HadoopDB是一个Mapreduce和传统关系型数据库的结合方案，以充分利用RDBMS的性能和Hadoop的容错、分布特性。2009年被Yale大学教授Abadi提出，继而商业化为<a href="http://hadapt.com/">Hadapt</a>，据称从VC那儿拉到了10M刀投资。</p>

<p>本文是对HadoopDB论文的总结。其中不免掺杂些自己的不成熟想法，更详细的内容，还请参见原论文 HadoopDB: An Architectural Hybrid of MapReduce and DBMS Technologies for Analytical Workloads</p>

<!--more-->


<h2>背景</h2>

<h3>PB级数据分析系统的能力要求</h3>

<ul>
<li>1.性能：节省开销（时间、资金）。</li>
<li>2.容错：数据分析系统（即使有故障节点也能顺利工作） 不同于 事务型的系统的容错（从故障中无损的恢复）。节点故障时，原来的查询操作不需要重启。</li>
<li>3.在异构型环境中运行的能力。即使所有机器硬件一样，但某些机器在某些时候可能因为软件原因、网络原因也会性能降低。分布式操作时，要防止木桶效应。</li>
<li>4.活的查询接口：商业化的数据分析一般建立在SQL查询上，UDF等non-SQL也是需要的。</li>
</ul>


<h5>并行数据库</h5>

<p>满足1,4：利用分表的方式，扩散到多个节点。一般情况下节点最多为几十个，原因：1.每增加一个节点，失败率增加；2.并行数据库假设各个机器都是同质化的，但这往往不太可能</p>

<h5>MapReduce</h5>

<p>满足2,3,4：Map - repartition - Reduce原为非结构化数据，但也可以适用结构化数据。</p>

<ul>
<li>2：（错误节点）动态的规划节点执行任务，将错误节点任务发放给新节点。并在本地磁盘做checkpoint存储。</li>
<li>3：（拖后腿的节点）节点间冗余的执行。执行慢的节点的任务交付给速度快的节点执行</li>
<li>4：Hive的HQL</li>
</ul>


<h5>HadoopDB</h5>

<p>融合了之前两者，做出系统层面的改进，而不仅仅是语言和接口层面。</p>

<p>这三个解决方案对4个指标的关系如下图：</p>

<p><img src="http://dl.dropboxusercontent.com/u/64021093/hadoopDB/QQ%E6%88%AA%E5%9B%BE20130518135802.png" title="compare" alt="alt compare" /></p>

<h2>架构</h2>

<p>如图
<img src="https://dl.dropboxusercontent.com/u/64021093/hadoopDB/QQ%E6%88%AA%E5%9B%BE20130518135814.png" title="framework" alt="alt framework" /></p>

<h2>组件介绍</h2>

<h5>Databse Connector:</h5>

<ul>
<li><p>作用</p>

<p>  hadoopTask &lt;-通信-> Database on Node。节点上的DB类似于Hadoop中的数据源HDFS</p></li>
<li><p>实现</p>

<p>  扩展了Hadoop的InputFormat</p></li>
</ul>


<h5>Catalog：</h5>

<ul>
<li><p>作用</p>

<p>  1.链接参数如数据库位置，驱动类和证书；
  2.一些元数据如数据簇中的数据集，副本的位置，数据的划分。</p></li>
<li><p>实现</p>

<p>  HDFS上的XML。希望做成类似于Hadoop的namenode。</p></li>
</ul>


<h5>Data Loader</h5>

<ul>
<li><p>作用</p>

<p>  将数据合理划分，从HDFS转移到节点中的本地文件系统</p></li>
<li><p>实现</p>

<p>  global hasher：分配到不同节点
  local hasher：继续划分为不同chunks</p></li>
</ul>


<h5>SQL to MapReduce to SQL (SMS) Planner</h5>

<ul>
<li><p>作用</p>

<p>  将HiveQL转化为特定执行计划，在hadoopDB中执行。原则是尽可能的讲操作推向节点上的RDBMS上执行，以此提高执行效率。</p></li>
<li><p>实现</p>

<p>  扩展Hive：
  1.执行查找前，用catolog的信息更新Hive的metastore，定向到节点数据库的表
  2.执行前，决定划分的键；将部分查询语句推到节点的数据库中执行。</p></li>
</ul>


<h2>示例</h2>

<p>示例参见下文的slides</p>

<h2>总结</h2>

<p>对hadoopDB的一些看法：</p>

<ul>
<li>其数据预处理代价过高：数据需要进行两次分解和一次数据库加载操作后才能使用；</li>
<li>将查询推向数据库层只是少数情况，大多数情况下，查询仍由Ｈive完成．因为数据仓库查询往往涉及多表连接，由于连接的复杂性，难以做到在保持连接数据局部性的前提下将参与连接的多张表按照某种模式划分；</li>
<li>维护代价过高．不仅要维护Ｈadoop系统，还要维护每个数据库节点；</li>
<li>目前尚不支持数据的动态划分，需要手工一次划分好</li>
</ul>


<p>slides：</p>

<script async class="speakerdeck-embed" data-id="48c5e680a1ab0130e1707290244918d4" data-ratio="1.33333333333333" src="http://biaobiaoqi.github.com//speakerdeck.com/assets/embed.js"></script>


<p>下载slides，请猛戳<a href="https://dl.dropboxusercontent.com/u/64021093/hadoopDB/%5B2013-05-18%5DHadoopDB.pptx">这里</a></p>

<h2>参考资料</h2>

<ul>
<li>HadoopDB: An Architectural Hybrid of MapReduce and DBMS Technologies for Analytical Workloads</li>
<li><a href="http://dbanotes.net/database/hadoopdb.html">《HadoopDB》 —— Fenng</a></li>
<li>《架构大数据:挑战、现状与展望》 计算机学报 王珊</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS的安全性和越狱]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/05/17/jail-break-your-ios/"/>
    <updated>2013-05-17T00:10:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/05/17/jail-break-your-ios</id>
    <content type="html"><![CDATA[<p><img src="https://dl.dropboxusercontent.com/u/64021093/2013-5-16.jpg" title="Jailbrek" alt="alt jailbreak" /></p>

<p>提到<a href="http://en.wikipedia.org/wiki/IOS_jailbreaking#Security.2C_privacy.2C_and_stability">越狱</a>，很多人第一反应大概是免费的游戏和app。</p>

<p>作为软件从业人员，深知中国的大环境的特殊性。内有用户想吃免费午餐的不良付费习惯，外有行业内大头诸如某讯对创新的绞杀。大家对越狱是为了免费、盗版软件的认识，也就不奇怪了。</p>

<p>还有另一派人。越狱对他们来说，意味着开放。个人认为这也是Hack精神的精髓之一。事实上，iOS越狱也有自己的生态圈：Cydia就是越狱设备上App Store。</p>

<!--more-->


<h2>越狱的合法性</h2>

<p>数字千年版权法对iphone的越狱进行了特赦，直到2015年，对iPhone、iPod touch的越狱依然有效。但注意，iPad就没这么幸运了。</p>

<p>详情参见博文<a href="http://www.cultofmac.com/213144/unlocking-a-new-iphone-is-now-illegal-but-jailbreaking-is-still-safe-what-it-all-means-for-you/">《Unlocking A New iPhone Is Now Illegal, But Jailbreaking Is Still Safe — What It All Means For You》</a></p>

<h2>iOS安全性</h2>

<p>由于iOS没有开源，学术界和工业界对它的安全机制的论述资料很少。我在网上找到了上交一位学长对ios安全机制的分析文章，是他的硕士学位<a href="http://www.doc88.com/p-405566264292.html">论文</a>。作为参考，我整理了一些关键知识点。</p>

<h4>基于信任链的启动</h4>

<p>iOS的信任机制从系统启动那一刻起已经开始。
系统可信启动<a href="http://elinux.org/images/2/28/Trusted_Boot_Loader.pdf">trustedboot</a>：启动每一步都会检测签名，构成整个信任链。</p>

<p>还有另一种启动方式，是设备固件升级方式（DFU，Device Firmware Update），也是由签名构建信任链。</p>

<h4>程序签名</h4>

<p>iOS应用的ipa压缩包中包含可执行文件和数据文件。可执行文件只有在已签名的前提下才能运行。确保应用经过苹果认证。</p>

<p>越狱提升运行权限到root，修改引用加载策略，接受任意签名的应用。
“通过软件保证软件安全是不可能的”，iOS使用了硬件来做保护，但硬件部分也遭到了越狱的破解。</p>

<h4>沙盒技术</h4>

<p>iOS用沙盒技术实现访问控制
trustedBSD ：http://www.trustedbsd.org/
http://www.freebsd.org/doc/zh_CN/books/arch-handbook/mac-synopsis.html</p>

<h4>ASLR和PIE</h4>

<p>使用地址空间布局随机化（ASLR， address space layout randomization）和位置无关可执行代码（PIE，position independent executable）编译用来防止经典的缓冲区溢出攻击。</p>

<h4>数据保护机制：</h4>

<ul>
<li>硬件加密：AES协处理器，存储着UID，GID</li>
<li>软件加密：系统中每个文件、数据都用一个唯一的秘钥来加密。秘钥是有UID、GID一起产生的，存在keybag中，keybag通过用户的4位密码来保护。</li>
</ul>


<h2>越狱</h2>

<p>越狱主要就是在信任链的根bootrom阶段攻击。由于系统不断升级，攻击的方式也在不断演进，这个<a href="http://bbs.gean.cn/archiver/showtopic-213.aspx">链接</a>介绍了其中的一种情况。</p>

<h4>越狱后注意</h4>

<p>总的来说，越狱打破了iOS封闭的生态环境，也打破了它特有的保护壳。手机获得了root权限，恶意代码有了可趁之机。不要轻易的使用来源不明的应用和插件。</p>

<ul>
<li>非越狱手机：仅允许用户访问照片、视频数据；通过备份，可在pc端获取所有数据</li>
<li>越狱手机：拥有root权限。可以通过许多渠道如ssh，ftp获取系统数据。</li>
</ul>


<p>更多细节参见
* <a href="http://bbs.weiphone.com/read-htm-tid-1750886.html">《浅谈iOS越狱前后的安全问题以及安全风险》</a>
* <a href="http://www.pcpop.com/doc/0/890/890768_all.shtml">《iPad越狱不安全!安装应用/插件需谨慎》</a>
* <a href="http://www.cnbeta.com/articles/229192.htm">《iOS完美越狱 - 福利还是阴谋？》</a></p>

<h4>SHSH</h4>

<p>iPhone 3GS出来时候，苹果为加强对iPhone OS的控制对恢复(Restore)固件(Firmware)采用了验证过程，每次iTunes要恢复固件的时候都要连接苹果的服务器验证。手机的ECID和所刷系统版本号一起签名出一个SHSH文件，发送给服务器，服务器检测SHSH是否为新版本的系统所产生，如果是，则允许继续进行刷机，否则传回组织继续的信号。</p>

<p>SHSH是存储在苹果公司的服务器上的，用户需要通过备份原来的SHSH，并伪装一台苹果服务器来协助验证。　　</p>

<p>网络上SHSH备份方法的介绍很多，不了解的朋友自行Google吧。</p>

<h2>附录</h2>

<p>对于想开发iOS应用而又没有开发者账号的朋友，可以参考这篇文章<a href="http://kqwd.blog.163.com/blog/static/4122344820117191351263/">《Xcode 4.1~4.6 + iOS 5、iOS 6免证书(iDP)开发+真机调试+生成IPA全攻略》</a>，Xcode4.6 iOS6.0 亲测有效。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CAP和最终一致性]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/05/15/cap-and-eventual-consistent/"/>
    <updated>2013-05-15T00:30:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/05/15/cap-and-eventual-consistent</id>
    <content type="html"><![CDATA[<p>查阅资料整理了最终一致性、CAP相关的内容。由于图省事儿，没有做文字的整理记载，只有slides和一些查阅过的链接，大家将就着看。欢迎指正。</p>

<p>slides：</p>

<script async class="speakerdeck-embed" data-id="cca07ce09e92013076c646310b996896" data-ratio="1.33333333333333" src="http://biaobiaoqi.github.com//speakerdeck.com/assets/embed.js"></script>




<!--more-->


<p>slides链接：<a href="https://speakerdeck.com/biaobiaoqi/cap-and-eventually-consistent">请戳这里</a></p>

<h2>背景</h2>

<p>为什么系统要扩张？历史的发展路径是怎么样的？请看<a href="http://rdc.taobao.com/blog/cs/?p=614">《系统可扩展性演化》</a></p>

<h2>CAP理论</h2>

<ul>
<li><p>CAP理论的提出：分布式系统的CAP理论是2000年左右被提出的概念，直到Dynamo的出现，开始在工业界被广泛实践：
<a href="http://www.julianbrowne.com/article/viewer/brewers-cap-theorem">《Brewer&#8217;s CAP Theorem》</a>/<a href="http://code.alibabatech.com/blog/dev_related_728/brewers-cap-theorem.html">中文翻译</a></p></li>
<li><p>对CAP的理解：<a href="http://www.douban.com/group/topic/11765014/">《谈正确理解CAP理论》</a>\ <a href="http://rdc.taobao.com/blog/cs/?p=631">《CAP理论及分布式系统一致性》</a></p></li>
</ul>


<h2>BASE理论</h2>

<ul>
<li>BASE的理论解释：<a href="http://rdc.taobao.com/blog/cs/?p=637">《分布式事务工程实现》</a></li>
</ul>


<h2>最终一致性</h2>

<ul>
<li><p>amazon的CTO分析最终一致性：<a href="http://www.allthingsdistributed.com/2008/12/eventually_consistent.html">Eventually Consistent - Revisited</a>/<a href="http://blog.csdn.net/xiaoqiangxx/article/details/7566654">中文翻译</a></p></li>
<li><p>Dynamo论文：<a href="http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf">Dynamo: Amazon’s Highly Available Key-value Store</a></p>

<p>关于Dynamo的一篇中文简述：<a href="http://www.infoq.com/cn/articles/nosql-dynamo">《解读NoSQL技术代表之作Dynamo》</a></p></li>
</ul>


<h2>引申</h2>

<ul>
<li>CAP原作者对CAP的反思和澄清：<a href="http://www.infoq.com/cn/articles/cap-twelve-years-later-how-the-rules-have-changed">《CAP十二年回顾：规则变了》</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《免费》]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/05/13/free-the-bit-economics/"/>
    <updated>2013-05-13T00:46:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/05/13/free-the-bit-economics</id>
    <content type="html"><![CDATA[<h2>比特经济的到来</h2>

<p><a href="http://en.wikipedia.org/wiki/Chris_Andersen">克里斯·安德森</a>人称鸟人安德森，现效力于热火队，一直以来都是值得信赖的角色球员，板凳匪徒，内线尖兵。好了，不扯了……回到另外一个<a href="http://t.cn/akRhip">克里斯·安德森</a>的思想世界来。</p>

<p>长尾理论早就为人熟知了，最早就是由安德森提出的，用于解释Amazon和Netflix的商业和经济模式。虽然没有阅读过原书，只是从网络接收了一些二手甚至三手的相关观点，但也可以从当今互联网的新兴中发现许多端倪。</p>

<p>按作者的话来说，“免费”是<a href="http://book.douban.com/subject/1919072/">《长尾理论》</a>没讨论完的话题，它并非新生事物，但是一直在变化，它的变化促使我们要反思人类行为和经济动因方面最根深蒂固的一些观念。</p>

<!--more-->


<p>作为没有系统学习经济理论的工科生，未必深刻的理解了作者观点的精华部分，但至少从作者娓娓道来的文字中获得了商业模式和经济原理的联系的启迪。这是从微博140个文字的刷屏中难以获取的。</p>

<p>当然，这种了解层面显然是无法发挥<a href="http://book.douban.com/subject/3932520/">《免费》</a>的效力的。正文安德森所言，那些懂得“免费”将会统摄明日市场并摧毁今日市场的人其实已经走在前面了，而《免费》所能带来的思考能点亮的新的商业模式，还得沉淀到对生活、市场的思考中去。</p>

<p>下面是个人阅读的一些收获，简略匆草，欢迎拍砖讨论。</p>

<h2>原子经济和比特经济</h2>

<p>20世纪的经济主要是一种原子经济的时代，是基于物质的。而21世纪的经济则是一种比特经济，核心是信息。原子经济的基调是通货膨胀，而比特经济的主旋律是通货紧缩。</p>

<p>在原子经济中，想要得到任何免费都需要换一种方式把钱付了，而比特经济中，真正的免费是存在的。
“免费经济学”的兴起正是由数字时代的科技进步来推动的。是比特经济的一大特征。</p>

<p>而这个发展趋势的原因，在于互联网的基础设施价格不断下降，处理器、网络带宽和存储器是造成科技界价格下行的三驾马车。互联网的边际成本很低。</p>

<p>摩尔定律何以持续？每当某种生产流程出现了改进产业效率能力下滑的局面，就会更快的产生提出某种全新的、更好观念的动力。正是很多段的单一学习曲线共同组成了按趋势下降的摩尔定律。我们称这样的曲线为<em>复合学习曲线</em>。</p>

<p>在互联网领域，信息越发重要。最早认识到比特经济的影响的是黑客们：</p>

<blockquote><p>一方面，信息想要变得昂贵，因为它很宝贵，在恰当的地点得知恰当的信息，能够改变你的人生。而在另一方面，信息也要变得免费，因为发布信息的成本一直在下降。因此，这两种趋势在互相牵制。</p></blockquote>

<p>这一观点，在科技和思想之间建立起了经济纽带。</p>

<h2>充裕和稀缺：</h2>

<p>人类似乎与生俱来对资源贫瘠要比对资源充裕的理解更加深刻。正如我们在进化过程中形成了对威胁过度反应的本能一样，我们的一个生存技能就是关注资源耗竭会带来的威胁。</p>

<p>人们习惯于匮乏管理，大多数环境下，资源都是匮乏的。而在充裕管理时，显得手足无措。</p>

<p>基于供需定价关系，一旦物品稀缺了，那么价格就会上涨。实际上，一种资源变得稀缺而且昂贵了，那么就会促使人类去寻找另一种更充裕的资源，而目前对稀缺资源的需求也会逐渐向别种资源转移。如此一来，之前稀缺的资源的价格也不会大幅提升。</p>

<p>供需关系决定在任何时间节点上的商品价格。从长期的角度来看，价格趋势是由技术本身决定的，某种商品数量越多，那么价格就会越便宜。</p>

<p>浪费一般是个贬义词，但正是对充裕资源的浪费，催生了创新。自然界就是通过浪费生命来实现生命的进化。</p>

<h2>免费</h2>

<p>免费归根结底都表现为同一实质——让钱在不同的产品之间、人之间、现在和未来之间、不与钱打交道的市场和金钱市场之间转义。经济学家称其为交叉补贴。交叉补贴体现了“天下没有免费的午餐”这句话的实质。</p>

<p>交叉补贴的世界里，免费可以分为四大类：</p>

<h6>1.直接交叉补贴</h6>

<ul>
<li>什么免费：吸引你掏腰包买其他商品的东西免费</li>
<li>谁享受免费：以某种方式最终掏腰包的人</li>
<li>举例：超市打折某些商品，吸引你到超市购，从而卖出其他商品</li>
</ul>


<h6>2.三方市场</h6>

<ul>
<li>什么免费：内容、服务、软件等</li>
<li>谁享受免费：任何人</li>
<li>举例：电视、广播、报刊等媒体</li>
</ul>


<h6>3.免费加收费模式（Freemium）</h6>

<ul>
<li>什么免费：和付费版本想匹配的任何商品</li>
<li>谁享受免费：基本用户</li>
<li>举例：软件分为免费版和收费版</li>
</ul>


<h6>4.非货币市场(非货币市场的不同表现形式：礼品经济、劳动交换、盗版)</h6>

<ul>
<li>什么免费：人们选择免费赠送的、没有寄希望别人付钱的东西</li>
<li>谁享受免费：任何人</li>
<li>举例：写博客供其他人阅读</li>
</ul>


<p>盗版或仿制行为刺激的市场需求要比它满足的需求更多。</p>

<p>在非货币市场中，礼品经济比市场资本主义离人性化走的更近一点。一直以来，经济学家做过很多尝试，但由于顿巴数（Dunbar number）的作用，超过150这个规模的群体就难以维系。而互联网的到来，给礼品经济带来了新的机会，可能打破顿巴数的局限，让建立在互利基础之上的经济有效运转。</p>

<h3>免费的特性</h3>

<ul>
<li><p>免费给所有市场带来了更强的流动性，让市场能够运转的更为顺畅。它将上亿美元的产业转变为百万美元的产业，但通常情况下，财富似乎并未蒸发，相反，它只是以难以衡量的方式被重新分布配。它让用户更便捷的交流，降低了开销。</p></li>
<li><p>免费具有破坏性，却常常能导致更高效市场的出现。比如wiki摧毁了《大英百科全书》的市场，而自身并不怎么赚钱。当然，他提高了人们的获取知识的效率。</p></li>
<li><p>免费的坏处：去货币化的长期积极效应显现之前可能出现短期消极后果。在改变的多方关系中，可能存在脆弱的节点。</p></li>
</ul>


<h2>比特经济下的典型市场</h2>

<p>传统媒体上发布的广告全都是销售稀缺资源——空间。而互联网最不缺的就是空间，因此很多互联网广告效果甚至不如平面媒体。但Google通过广告的精准匹配，将它转化为稀缺资源。</p>

<p>视频游戏领域对免费的实践很多。</p>

<p>低于边际成本的数字书籍，实际上是为高边际成本演说或深入探讨而开展的市场营销。</p>

<p>在一个竞争性市场中，价格等于边际成本。垄断、专利权、版权和商标权等都能拒竞争对手于千里之外。于是形成了递增收益。而互联网编辑成本很低，很倾向于竞争性市场。</p>

<p>“搭便车问题”：wiki毫无利润可言，每个人都会搭便车。但实际上，在大规模的用户下，只要有人参与其中，大部分志愿者社区就能发展和完善。因为大量消极顾客本身正是对少数做出贡献的汇报——他们被成为观众。</p>

<h2>Google</h2>

<p>在比特经济的主战场的IT领域，免费方式已经获得了很大的成功。经典的案例包括微软操作系统和inux之争，以及google推出免费邮箱冲击雅虎。</p>

<p>Google通过为一小部分核心产品做广告而赚取大部分利润。互联网创业成本低、边际成本低，造就了Google的成长和规模化。它拥有很大的数据中心，这种对数据处理、存储和存储的融合，产生了规模经济。</p>

<p>互联网具备极强的网络效应。由于用户之间交流沟通方便，容易导致”羊群效应“。在传统行业，排名前三的竞争对手，他们的市场份额一般是60% 30% 5%，而在网络效应突出的市场中则为：95%，5%，0%。现在的Google已经站在了第一的位置。</p>

<p>唯一能限制google增长势头之处在于互联网自身的扩展步伐。因此Google设计出众多的产品，以扩展包括免费无线接入和免费存储在内的互联网应用。这是经济学家所说的”互补品“。 当然，前不久Google关闭了GoogleReader的事实证明，一切都是定量的trade-off，或许greader在Google的战略中已经变成了投入产出比过低的产品了吧。</p>

<h2>非货币市场</h2>

<p>非货币市场：注意力经济 和 声誉经济。</p>

<p>在互联网上，流量就是注意力，而链接就是声誉。</p>

<p>Google的商业模式就是将声誉经济转化为注意力经济进而转化为货币的很好例证。Google控制着整个经济体系，并不断改善搜索排名算法，以防止经济体系中的通货膨胀，保持货币的价值。Facebook运营“朋友”，Twitter运营“追随者”，用户均可创建声誉资本，并将其转化为注意力。</p>

<p>付出一定代价才能换来充裕，而代价就是别处的匮乏。</p>

<p>当所有物质需求都得到满足时，最值钱的商品就变成了社会资本。</p>

<p>我们始终被自己不曾拥有的而非已拥有的事物激励着。</p>

<p>从经济学角度看，充裕是创新和增长的推进器。但从心理学角度看，匮乏才是我们真正理解的一切。</p>

<p>时尚经济学：“诱导性过时”，将一种专有设计方案转化成一大众商品广泛复制。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我的MBTI职业性格测试]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/05/12/mbti-test/"/>
    <updated>2013-05-12T01:04:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/05/12/mbti-test</id>
    <content type="html"><![CDATA[<h2>背景</h2>

<p>最近在看<a href="http://book.douban.com/subject/5372651/">《程序员的思维训练——开发人之前能的九堂课》</a>，其中讲到了<a href="http://wiki.mbalib.com/wiki/MBTI%E4%BA%BA%E6%A0%BC%E7%90%86%E8%AE%BA">MBTI职业性格测试</a>的指导意义。记起来两年多以前在面试ASES的时候有做过这个测试，只可惜当时的测试结果在好几次的更换电脑的过程中不知踪影了。最近自己的思考也集中在认知领域，于是重新找到那个链接，做了一次测试。<a href="http://www.apesk.com/mbti/">点击链接测试</a>，正文是我的测试结果。</p>

<p>我也使用了另一个在线MBTI来检验测试结果，相差不大。一个是ENTJ（本文的测试结果），一个是ENFJ（E:8,I:2,S:8,N:12,T:10,F:10,J:11,P:9），差别不大。</p>

<p>总的来说，这是一个带有个人倾向性的测试结果，至于结果对不对，这都不重要。能在对测试结果的分析中，反省自身，那就够了。</p>

<!--more-->


<blockquote><p>知己知彼，百战不殆</p></blockquote>

<h2>ENTJ 统帅型——一切尽在掌握</h2>

<h3>一、你的MBTI图形</h3>

<p><img src="http://dl.dropboxusercontent.com/u/64021093/Pics/D567480F-DB00-481E-9AEF-08EBFC61E0B1.png" title="Title" alt="alt text" /></p>

<ul>
<li> 倾向示意图表示四个维度分别的倾向程度。从中间往两侧看，绿色指示条对应下面坐标的哪个区间。</li>
</ul>


<h3>二、基本描述</h3>

<p>才储分析：您的性格类型倾向为“ ENTJ ”(外向 直觉 思维 判断 倾向度： E75 N80 T52 J80  不假思索指数：15)</p>

<p>坦诚、果断，有天生的领导能力。能很快看到公司/组织程序和政策中的不合理性和低效能性，发展并实施有效和全面的系统来解决问题。善于做长期的计划和目标的设定。通常见多识广，博览群书，喜欢拓广自己的知识面 并将此分享给他人。在陈述自己的想法时非常强而有力。</p>

<p>ENTJ型的人是伟大的领导者和决策人。他们能轻易地看出事物具有的可能性，很高兴指导别人，使他们的想象成为现实。他们是头脑灵活的思想家和伟大的长远规划者。因为ENTJ型的人很有条理和分析能力，所以他们通常 对要求推理和才智的任何事情都很擅长。为了在完成工作中称职，他们通常会很自然地看出所处情况中可能存在的缺陷，并且立刻知道如何改进。他们力求精通整个体系，而不是简单地把它们做为现存的接受而已。 ENTJ型 的人乐于完成一些需要解决的复杂问题，他们大胆地力求掌握使他们感兴趣的任何事情。 ENTJ型的人把事实看得高于一切，只有通过逻辑的推理才会确信。 ENTJ型的人渴望不断增加自己的知识基础，他们系统地计划和研 究新情况。他们乐于钻研复杂的理论性问题，力求精通任何他们认为有趣的事物。他们对于行为的未来结果更感兴趣，而不是事物现存的状况。 ENTJ型的人是热心而真诚的天生的领导者，他们往往能够控制他们所处的任何 环境。因为他们具有预见能力，并且向别人传播他们的观点，所以他们是出色的群众组织者。他们往往按照一套相当严格的规律生活，并且希望别人也是如此。因此他们往往具有挑战性，同样艰难地推动自我和他人前进。</p>

<p>您适合的领域有：工商业、政界、金融和投资领域、管理咨询、培训、专业性领域</p>

<p>您适合的职业有：</p>

<ul>
<li>各类企业的高级主管</li>
<li>总经理</li>
<li>企业主</li>
<li>社会团体负责人</li>
<li>政治家</li>
<li>投资银行家</li>
<li>风险投资家</li>
<li>股票经纪人</li>
<li>公司财务经理</li>
<li>财务顾问</li>
<li>经济学家</li>
<li>企业管理顾问</li>
<li>企业战略顾问</li>
<li>项目顾问</li>
<li>专项培训师</li>
<li>律师</li>
<li>法官</li>
<li>知识产权专家</li>
<li>大学教师</li>
<li>科技专家</li>
<li>房产开发商</li>
<li>教育咨询顾问</li>
<li>投资顾问</li>
<li>（人事、销售、营销）经理</li>
<li>技术培训人员</li>
<li>（后勤、电脑信息服务和组织重建）顾问</li>
<li>国际销售经理</li>
<li>特许经营业主</li>
<li>程序设计员</li>
<li>环保工程师</li>
</ul>


<h3>三、气质类型</h3>

<p>根据大卫.凯尔西（David Keirsey）气质与性情理论，你属于“概念主义者”，下面是对“概念主义者”的描述：</p>

<p>“概念主义者”型的人自信、有智慧、富有想像力。他们的原则是“所有的事情都要做到最好”。</p>

<p>“概念主义者”是最独立的一种人。他们工作原则性强，标准高，对自己和对别人的要求都很严格。他们不会被别人的冷 遇和批评干扰，喜欢以自己的方式做事。</p>

<p>“概念主义者”型的人天生好奇，无论是由于工作本身的需要还是出于长远的考虑，他们很喜欢不断地吸取知识，他们因此而常常看 得到同一问题的多个不同的方面，习惯于全面地、概括地思考问题，和一分为二地看待问题。他们很善于发现事物的可能性，理解事 物的复杂性，喜欢进行逻辑的分析，从而对真实或假设的问题构思出解决方案。</p>

<p>“概念主义者”喜欢能够提供自由、变化和需要有较高的智力才能完成的工作，不喜欢简单、重复的工作。他们喜欢看到自己的想法 能够得到实施。“概念主义者”会对那些他们认为不够能干的人不耐烦，喜欢与很有能力的上司、下属、同事共事。许多“概念主义 者”型的人推崇权力，易于被有权力的人和权力地位所吸引。</p>

<h6>总体描述</h6>

<ol>
<li>善于分析、总结、判断</li>
<li>善于从整体上把握事物</li>
<li>喜欢追根究底，力图抓住事物的本质</li>
<li>对文字、语言敏感</li>
<li>抽象思维能力强，能理解复杂的理论概念，善于将事情概念化，善于从中推断出原则或预测趋势</li>
<li>擅长策略性思维</li>
<li>会接受建设性的批评，而不把它当作针对个人的问题</li>
</ol>


<h6>潜在的弱点</h6>

<ol>
<li>由于有时给自己定了不切实际的高标准，可能对自己和他人的期望过高</li>
<li>易于像紧逼自己工作一样去逼着别人工作</li>
<li>常常不希望别人对抗自己的意愿，有时给人顽固、死板的印象</li>
<li>易于过份强调工作，从而损害了家庭的和谐</li>
<li>常常不记得花时间夸奖同事、下属或其他人</li>
<li>常常忽视了一些工作中所需要的社交礼仪</li>
<li>有时没有注意到他人的情绪感受，从而给人冷漠、不近人情的印象</li>
<li>有时会因忽略了细节而没有注意到周围环境的变化</li>
<li>易于过于理论化而不考虑实际情况，易受远景规划诱惑，难以具体落实</li>
<li>有时想法太多，不知道哪些切实可行，不知道真正应该做什么</li>
</ol>


<h3>四、优势与劣势</h3>

<p>ENTJ的特质： 统帅型——一切尽在掌握</p>

<h5>优势：</h5>

<p>你直率、果断，能够妥善解决组织的问题，是天生的领导者和组织的创建者。你擅长发现一切事物的可能性并很愿意指导他人实现梦想，是思想家和长远规划者。</p>

<p>你逻辑性强，善于分析，能很快地在头脑里形成概念和理论，并能把可能性变成计划。树立自己的标准并一定要将这些标准强加于他人。你看重智力和能力，讨厌低效率，如果形势需要，可以非常强硬。你习惯用批判的眼光看待事物，随时可以发现不合逻辑和效率低的程序并强烈渴望修正它们。</p>

<p>你善于系统、全局地分析和解决各种错综复杂的问题，为了达到目的，你会采取积极行动，你喜欢研究复杂的理论问题，通过分析事情的各种可能性，事先考虑周到，预见问题，制定全盘计划和制度并安排好人和物的来源，推动变革和创新。</p>

<p>愿意接受挑战，并希望其他人能够象自己一样投入，对常规活动不感兴趣。长于需要论据和机智的谈吐的事情，如公开演讲之类。</p>

<h5>劣势：</h5>

<p>你经常在没有了解细节和形势之前就草率地做决定。</p>

<p>你总是很客观、带有批判性地对待生活，容易对别人的情况和需要表现得较粗心、直率、无耐心。建议你注意倾听周围人的心声，并对别人的贡献表示赞赏。你需要学会在实施自己的计划之前听取别人的建议，以免独断专横。</p>

<p>你考虑问题非常理智，很少受无关因素影响。你没有时间和兴趣去体会情感，容易忽略他人的感受，显得不尽人情。但当你的感情被忽视或没有表达出来的时候，你会非常敏感。你们需要给自己一点儿时间来了解自己的真实感情，学会正确地释放自己的情感，而不是爆发，并获得自己期望和为之努力的地位。
你容易夸大自己的经验、能力。 你需要接受他人实际而有价值的协助，才能更好的提高能力并获得成功。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[全分布式的Hadoop初体验]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/05/12/touch-hadoop/"/>
    <updated>2013-05-12T00:26:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/05/12/touch-hadoop</id>
    <content type="html"><![CDATA[<h2>背景</h2>

<p>之前的时间里对Hadoop的使用都是基于学长所搭建起的实验环境的，没有完整的自己部署和维护过，最近抽时间初体验了在集群环境下装机、配置、运行的全过程，梳理总结到本文中。</p>

<h2>配置</h2>

<ul>
<li>内存:8G</li>
<li>CPU：i5-2400 3.1GHz；</li>
<li>硬盘：960G</li>
<li>系统：windows 7旗舰 64bits</li>
</ul>


<!--more-->


<ul>
<li>虚拟机：VMware7.1.1</li>
<li>虚拟集群：</li>
<li><ul>
<li>T （master节点）Ubuntu11.04 32 bits 内存512MB；硬盘100G；单核；</li>
</ul>
</li>
<li><ul>
<li>T2（slave节点） Ubuntu11.04 32 bits 内存512MB；硬盘100G；单核；</li>
</ul>
</li>
<li><ul>
<li>T3（slave节点） Ubuntu11.04 32 bits 内存512MB；硬盘100G；单核；</li>
</ul>
</li>
<li><ul>
<li>T4（slave节点） Ubuntu11.04 32 bits 内存512MB；硬盘100G；单核；</li>
</ul>
</li>
</ul>


<h2>环境准备</h2>

<h5>1.节点机器的配置</h5>

<p>配置固定IP:修改<code>/etc/nerwork/interfaces</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>auto lo
</span><span class='line'>iface lo inet loopback
</span><span class='line'>address 192.168.108.131
</span><span class='line'>gateway 192.168.108.2
</span><span class='line'>netmask 192.168.108.0
</span><span class='line'>broadcast 192.168.108.0</span></code></pre></td></tr></table></div></figure>


<p>为了便于管理，建议按统一约定修改hostname：修改<code>/etc/hostname</code>；同时，Hadoop集群要求每个节点使用同一个账号来管理、运行，所以，也需要设置好公用账号。</p>

<h5>2.集群ssh配置</h5>

<p>ssh相关原理和操作，参见博文<a href="http://biaobiaoqi.me/blog/2013/04/19/use-ssh/">《SSH原理和使用》</a>。</p>

<p>在每台机器上生成密钥对，并将所有机器的公钥集成到master的<code>~/.ssh/authorized_keys</code>中,之后将这个文件分发到集群所有机器上。
这样，所有机器之间都可以实现免密码的ssh访问了。</p>

<p>使用如下指令，可以将本机的公钥添加到master的authorized_keys文件末尾。当所有节点都执行一遍以后，再将master的authorized_keys发布到各个节点上。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#cat .ssh/id_rsa.pub | ssh T 'cat &gt;&gt; ~/.ssh/authorized_keys'</span></code></pre></td></tr></table></div></figure>


<h5>3.工具脚本</h5>

<p>在分布式的环境里，运维工作的自动化很有必要。为了方便集群的运维，我写了两个简单的batch脚本。</p>

<h6>统一执行脚本</h6>

<p>在所有节点上执行同样的动作。使用时，在master节点上调用batch脚本，参数为对应的batch执行语句。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/bin/bash
</span><span class='line'>#Program:
</span><span class='line'># Execute instructions in hosts in slaveslist.
</span><span class='line'>#Description:
</span><span class='line'>#2013/5/8 biaobiaoqi First Release
</span><span class='line'>if [ $# -lt 1 ]; then
</span><span class='line'>   echo  "usage: $0 COMMAND"
</span><span class='line'>   exit 0
</span><span class='line'>fi
</span><span class='line'>
</span><span class='line'>for i in `cat slaveslist`
</span><span class='line'>do
</span><span class='line'>   ssh biaobiaoqi@$i "$1"
</span><span class='line'>done
</span></code></pre></td></tr></table></div></figure>


<p>脚本中使用的slaveslist文件保存着所有slave节点的hostname，需要与脚本放在同一个工作目录下。</p>

<h6>统一替部署脚本</h6>

<p>将主节点的某文件或目录统一的更新部署替换到所有节点上（注意，所有节点拥有相同的目录结构，即替换的文件路径相同）。</p>

<p>遇到hadoop集群中节点的增删改动需要修改配置文件的，都可以通过这个脚本便捷的部署。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/bin/bash
</span><span class='line'>#Program:
</span><span class='line'>#    Put the dirctory into all nodes of the cluster as the same path.
</span><span class='line'>#Description:
</span><span class='line'>#2013/5/10     biaobiaoqi     First Release
</span><span class='line'>if [ $# -lt 1 ]; then
</span><span class='line'>   echo "Usage $0 DIR_PATH"
</span><span class='line'>   exit 0
</span><span class='line'>fi
</span><span class='line'>
</span><span class='line'>for i in `cat slaveslist`
</span><span class='line'>do
</span><span class='line'>   ssh $i "rm ~/tmp -rf"
</span><span class='line'>   scp -r $1 $i:~/tmp
</span><span class='line'>   ssh $i "rm -rf $1;  mv ~/tmp $1"
</span><span class='line'>done
</span></code></pre></td></tr></table></div></figure>


<h5>4.配置hosts文件</h5>

<p>由于hadoop体系在处理节点时，是使用的hostname，而非IP，所以必须先配置好hostname和IP的关系。
在一台机器上修改<code>/etc/hosts</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#/etc/hosts
</span><span class='line'>127.0.0.1     localhost
</span><span class='line'>192.168.108.128     T3
</span><span class='line'>192.168.108.129     T2
</span><span class='line'>192.168.108.130 T
</span><span class='line'>192.168.108.131 T4</span></code></pre></td></tr></table></div></figure>


<p>然后使用统一执行脚本，将它发布到所有节点上。</p>

<p>值得注意的是，在<code>/etc/hostsname</code>中修改了host name之后，如果不同步的修改<code>/etc/hosts</code>中的相关信息，则在sudo操作时出现 <code>sudo: unable to resolve host</code>  的提示。原因是机器无法解析主机名。</p>

<p>修改<code>/etc/hosts</code>时也要特别注意，如果改成<code>127.0.0.1 localhost HOSTNAME</code> (其中HOSTNAME是主机名)的形式，在开启hadoop集群时，会出现datanode无法正常访问namenode，算是个小bug吧。所以得把hosts文件写成如上的形式。</p>

<h5>5.配置Java环境</h5>

<p>Hadoop需要Java1.6或更高版本，记住Java的安装目录，之后需要在hadoop配置过程中用到。</p>

<h2>安装Hadoop</h2>

<h5>1.下载Hadoop</h5>

<p>从官网下载<a href="http://www.apache.org/dyn/closer.cgi/hadoop/common/">Hadoop发布版</a>（博主使用的是较早的稳定版0.20.2）</p>

<p>关于版本选择，推荐阅读：<a href="http://dongxicheng.org/mapreduce-nextgen/how-to-select-hadoop-versions/">Hadoop版本选择探讨</a></p>

<h5>2.部署</h5>

<p>解压下载好的Hadoop，后放到合适的目录下。这里假定放置在/home/USER/ 的目录下</p>

<p>在<code>/home/USER/.bashrc</code>(其中USER为集群的用户名)文件中，增加如下语句，设定Hadoop相关的路径信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>export JAVA_HOME=/usr/lib/jvm/java-6-openjdk
</span><span class='line'>export HADOOP_HOME=/home/hadoop/Hadoop
</span><span class='line'>export HADOOP_CONF=$HADOOP_HOME/conf
</span><span class='line'>export HADOOP_PATH=$HADOOP_HOME/bin
</span><span class='line'>export PATH=$HADOOP_PATH:$PATH
</span><span class='line'>export CLASSPATH=.:$JAVA_HOME/bin:$PATH:$HADOOP_HOME:$HADOOP_HOME/bin</span></code></pre></td></tr></table></div></figure>


<h6>Hadoop核心配置修改</h6>

<p>配置文件在<code>$HADOOP_HOME/conf</code>目录下，其中基础配置比较重要的有三个：core-site.xml, hdfs-site.xml, mapred-site.xml。（当然，每个配置文件都有其细节作用，不过在初步实践hadoop时，理解这三个配置文件中的几个重要配置项就够了）</p>

<p>一般的，有三种可选模式。即本地模式、伪分布式模式和全分布式模式。前两种只是在单机环境下，后一种才是生产环境下的常用方式。《Hadoop权威指南》和《Hadoop实战》等书中都有讲到不同方式的配置，这里博主仅描述实验环境下4节点的全分布式配置。</p>

<p>core-site.xml整个hadoop的顶层配置</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;?xml version="1.0"?&gt;
</span><span class='line'>&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;
</span><span class='line'>
</span><span class='line'>&lt;!-- Put site-specific property overrides in this file. --&gt;
</span><span class='line'>
</span><span class='line'>&lt;configuration&gt; 
</span><span class='line'>    &lt;property&gt;
</span><span class='line'>         &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;
</span><span class='line'>         &lt;value&gt;/home/biaobiaoqi/UDMS/hadoop-data/tmp-base&lt;/value&gt;
</span><span class='line'>         &lt;description&gt;
</span><span class='line'>        存放临时目录的路径，默认也被用来存储hdfs的元数据和文件数据，值得注意的是，hadoop账户对所设定的本地路径是否有足够的操作权限。之后再hdfs-site.xml中设定的dfs.data.dir和dfs.name.dir也要注意同样的问题
</span><span class='line'>        &lt;/description&gt; 
</span><span class='line'>    &lt;/property&gt; 
</span><span class='line'>
</span><span class='line'>     &lt;property&gt;   
</span><span class='line'>          &lt;name&gt;fs.default.name&lt;/name&gt; 
</span><span class='line'>          &lt;value&gt;hdfs://T:9000/&lt;/value&gt;
</span><span class='line'>          &lt;description&gt;
</span><span class='line'>        默认文件系统的标记。这个URI标记了文件系统的实现方式。UIR的协议决定了文件系统的实现类，而后面的值决定了文件系统的地址、端口等信息。
</span><span class='line'>        &lt;/description&gt;
</span><span class='line'>     &lt;/property&gt; 
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&lt;/configuration&gt;
</span></code></pre></td></tr></table></div></figure>


<p>hdfs-site.xml存储HDFS相关的信息</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;?xml version="1.0"?&gt;
</span><span class='line'>&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;
</span><span class='line'>
</span><span class='line'>&lt;!-- Put site-specific property overrides in this file. --&gt;
</span><span class='line'>
</span><span class='line'>&lt;configuration&gt; 
</span><span class='line'>    &lt;property&gt;   
</span><span class='line'>          &lt;name&gt;dfs.replication&lt;/name&gt;   
</span><span class='line'>          &lt;value&gt;3&lt;/value&gt;   
</span><span class='line'>          &lt;description&gt;默认的块的副本数量。实际的副本数量可以在文件写入的时候确定，默认的副本数则是在没有指定写入副本时被使用。 &lt;/description&gt; 
</span><span class='line'>     &lt;/property&gt;
</span><span class='line'>    &lt;property&gt;
</span><span class='line'>         &lt;name&gt;dfs.name.dir&lt;/name&gt;
</span><span class='line'>          &lt;value&gt;/home/hadoop/hadoop-data/meta-data&lt;/value&gt;
</span><span class='line'>        &lt;description&gt;
</span><span class='line'>        设定hdfs的元数据信息存储地址。在namenode上。
</span><span class='line'>        &lt;/description&gt;
</span><span class='line'>     &lt;/property&gt;
</span><span class='line'>     &lt;property&gt;
</span><span class='line'>          &lt;name&gt;dfs.data.dir&lt;/name&gt;
</span><span class='line'>          &lt;value&gt;/home/hadoop/hadoop-data/data&lt;/value&gt;
</span><span class='line'>        &lt;description&gt;
</span><span class='line'>        设定hdfs的数据存储地址。在datanode上。
</span><span class='line'>        &lt;/description&gt;
</span><span class='line'>     &lt;/property&gt;
</span><span class='line'>
</span><span class='line'>&lt;/configuration&gt;
</span></code></pre></td></tr></table></div></figure>


<p>mapred-site.xml存储mapreduce作业相关配置</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;?xml version="1.0"?&gt;
</span><span class='line'>&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;
</span><span class='line'>
</span><span class='line'>&lt;!-- Put site-specific property overrides in this file. --&gt;
</span><span class='line'>
</span><span class='line'>&lt;configuration&gt; 
</span><span class='line'>    &lt;property&gt;   
</span><span class='line'>          &lt;name&gt;mapred.job.tracker&lt;/name&gt;
</span><span class='line'>          &lt;value&gt;T:9001&lt;/value&gt;   
</span><span class='line'>          &lt;description&gt; Mapreduce 的job tracker所在的节点和端口。&lt;/description&gt; 
</span><span class='line'>     &lt;/property&gt;
</span><span class='line'>&lt;/configuration&gt;
</span></code></pre></td></tr></table></div></figure>


<p>hosts文件存储了master节点</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>T</span></code></pre></td></tr></table></div></figure>


<p>slaves文件存储着所有的slaves节点</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>T2
</span><span class='line'>T3
</span><span class='line'>T4</span></code></pre></td></tr></table></div></figure>


<h2>启动集群</h2>

<h5>1.格式化namenode</h5>

<p>如果是第一次起动集群，需要先格式化HDFS。</p>

<p>namenode存放了HDFS的元数据，故可以看成是对HDFS的格式化。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$HADOOP_HOME/bin/hadoop namenode -format</span></code></pre></td></tr></table></div></figure>


<h5>2.启动守护进程</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$HADOOP_HOME/bin/start-all.sh </span></code></pre></td></tr></table></div></figure>


<p>等价于如下命令执行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># start dfs daemons
</span><span class='line'>$"$bin"/start-dfs.sh --config $HADOOP_CONF_DIR
</span><span class='line'>
</span><span class='line'># start mapred daemons
</span><span class='line'>$"$bin"/start-mapred.sh --config $HADOOP_CONF_DIR
</span></code></pre></td></tr></table></div></figure>


<p>如果成功，打开 http://T:50070 (T为集群master节点)，可以看到HDFS的运行情况，包括节点数量、空间大小等。这是Hadoop自带的HDFS监控页面；同样的，http://T:50030 是Mapreduce的监控界面。</p>

<p>如果没有成功，根据$HADOOP_HOME/logs目录下的日志文件信息debug。</p>

<h5>3.常见问题</h5>

<ul>
<li>namenode无法启动：</li>
<li><ul>
<li>删除掉本地文件系统中HDFS的目录文件，重新格式化HDFS。</li>
</ul>
</li>
<li><ul>
<li>HDFS目录的权限不够，更改权限设置等。</li>
</ul>
</li>
<li>namenode启动成功，datanode无法连接：检查hosts文件是否设置正确；检查各个配置文件中地址值是否使用了IP而不是hostname。</li>
<li>namenode启动成功，datanode无法启动：Incompatible namespaceIDs，由于频繁格式化，造成dfs.name.dir/current/VERSION与dfs.data.dir/current/VERSION数据不一致。</li>
<li>SafeModeException： 分布式系统启动时，会进入安全模式，安全模式下，hadoop是无法执行的。一般的等待一会儿，就可以正常使用了。如果是由于之前集群崩溃造成的无法自动退出安全模式的情况，则需要如下特殊处理了</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$/$HADOOP_HOME/bin/hadoop dfsadmin -safemode leave </span></code></pre></td></tr></table></div></figure>


<h2>初体验</h2>

<p>最简单的尝试就是使用Hadoop自带的wordcount程序了，参照<a href="http://www.cnblogs.com/xia520pi/archive/2012/05/16/2504205.html">这篇文章</a>，描述很详细。</p>

<p>其他的一些尝试： <a href="http://www.cnblogs.com/rilley/archive/2012/02/13/2349858.html">动态增删节点</a> 、 <a href="http://www.cnblogs.com/ggjucheng/archive/2012/04/18/2454696.html">修改备份数量</a></p>

<h2>参考</h2>

<p><a href="http://hadoop.apache.org/docs/stable/cluster_setup.html">offical document: Cluster Setup</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[虚拟机中的网络配置]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/05/09/networking-in-virtual-machine/"/>
    <updated>2013-05-09T22:39:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/05/09/networking-in-virtual-machine</id>
    <content type="html"><![CDATA[<p>本文介绍三种虚拟机中常用的网络配置模式：NAT(网络地址转换模式)、Bridged nerworking（桥接网络模式）和Host-only（主机模式）。</p>

<h3>Network Address Translation (NAT)</h3>

<p>NAT模式使用了<a href="http://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2">NAT</a>服务来给虚拟网络提供网络连接。</p>

<p>这种模式下，虚拟机能访问外部网络，外部无法直接连接到内部网络，除非使用端口映射<a href="http://nxlhero.blog.51cto.com/962631/742140">port forwarding</a>。</p>

<!--more-->


<p>NAT一般与<a href="http://zh.wikipedia.org/wiki/DHCP">DHCP</a>一起使用，以动态分配虚拟机内网IP，无序手动配置内外部网络环境。当然，为了让虚拟机每次开机时拥有固定的IP，也可以关闭掉DHCP服务，转而自己配置虚拟机的网络。虚拟机是linux的情况下，可以通过修改/etc/network/interfaces实现开机固定IP，示例如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># This file describes the network interfaces available on your system
</span><span class='line'># and how to activate them. For more information, see interfaces(5).
</span><span class='line'>
</span><span class='line'># The loopback network interface
</span><span class='line'>auto lo
</span><span class='line'>iface lo inet loopback
</span><span class='line'>
</span><span class='line'>auto eth0
</span><span class='line'>iface eth0 inet static
</span><span class='line'>address 172.21.2.43
</span><span class='line'>netmask 255.255.0.0
</span><span class='line'>gateway 172.21.1.1
</span></code></pre></td></tr></table></div></figure>


<p>实现原理如图：</p>

<p><img src="http://dl.dropboxusercontent.com/u/64021093/network/2.jpg"></p>

<h3>Bridged networking(桥接)</h3>

<p>在桥接模式下，本地物理网卡和虚拟网卡通过虚拟交换机进行桥接（无需在host上再开启新的虚拟网卡），物理网卡和虚拟网卡在拓扑图上处于同等地位，虚拟机就像是一台真实主机一样存在于局域网中。</p>

<p>桥接模式无法与DHCP一起使用，需要手动的配置虚拟机的网络参数，包括IP、网关、子网掩码和dns。其中网关、子网掩码、dns都应该与host设置相同值。在linux虚拟机中的设置示例如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#设置ip、子网掩码
</span><span class='line'>$ifconfig eth0 172.21.2.43 netmask 255.255.0.0
</span><span class='line'>
</span><span class='line'>#设置默认网关
</span><span class='line'>$route add default gw 172.21.1.1
</span><span class='line'>
</span><span class='line'>#设置dns
</span><span class='line'>$sudo vim /etc/resolv.conf
</span><span class='line'>nameserver 172.21.1.1
</span></code></pre></td></tr></table></div></figure>


<p>实现原理如图：</p>

<p><img src="http://dl.dropboxusercontent.com/u/64021093/network/1.jpg"></p>

<p>相比NAT，桥接模式有一个前提条件，就是要获得另外一个host所在网段的IP。在内网环境中还很容易，如果是ADSL宽带就比较麻烦了，ISP一般是不会大方的多提供一个公网IP的，那种情况下，使用NAT或许是更好的选择。</p>

<p><a href="http://blog.chinaunix.net/uid-26212859-id-3051291.html">VMware的桥接网络配置</a></p>

<h3>Host-only networking(主机)</h3>

<p>以host为网关建立了新的虚拟网络，虚拟机无法访问外部网络，因此很安全。</p>

<p>和NAT一样，也使用了DHCP服务做虚拟网络内的IP自动分配。</p>

<p>另外，host-only模式下也可以进行扩展配置，让虚拟网络的机器也能访问到外网，比如自定制nat和dhcp的使用等等。</p>

<p>如图：</p>

<p><img src="http://dl.dropboxusercontent.com/u/64021093/network/3.jpg"></p>

<h2>参考资料</h2>

<ul>
<li><p><a href="http://networking.ctocio.com.cn/tips/110/8897610.shtml">解析虚拟VMware三种网络模式根本区别</a></p></li>
<li><p><a href="http://www.virtualbox.org/manual/ch06.html">virtualbox的网络模式详解</a></p></li>
</ul>


<p>图片引用自 ：<a href="http://networking.ctocio.com.cn/tips/110/8897610.shtml">解析虚拟VMware三种网络模式根本区别</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[根据前中后序和层序重建二叉树(PAT1020、PAT1043)]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/04/27/pat1020-pat1043-rebuild-binary-tree/"/>
    <updated>2013-04-27T22:33:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/04/27/pat1020-pat1043-rebuild-binary-tree</id>
    <content type="html"><![CDATA[<h2>背景</h2>

<p><a href="http://biaobiaoqi.github.com/blog/2013/04/27/travsal-binary-tree/">《二叉树的遍历（递归、非递归）分析》</a>总结了二叉树不同遍历方式的递归和非递归实现，本文则讨论如何针对不同遍历方式的组合重建二叉树。为了简化问题的考虑，假定二叉树中不会出现重复值。列入考虑范围的有前序、中序、后序、层序遍历这四种的组合。前中后序比较常见，而层序则相对特殊一点了。</p>

<p><a href="http://pat.zju.edu.cn/contests/pat-a-practise">PAT</a>的1043和1020题是遍历相关的模板题，正好派上用场。</p>

<!--more-->


<h2>中序+前序</h2>

<h5>算法描述：</h5>

<ul>
<li><p>初始：用前序遍历序列确定根节点，在中序遍历序列中找到该根节点，则左右子树分别为中序中该节点左右的序列。</p></li>
<li><p>迭代：对各个子树分别执行三步操作，1.在前序序列中找子树的根节点；2。在中序序列中找子树的根节点，并划分开根节点的左右子树；3.根据新生成的左右子树，在前序序列中划分开这些节点，从而得到了两颗子树的前序、中序序列。</p></li>
</ul>


<h5>练习：<a href="http://pat.zju.edu.cn/contests/pat-a-practise/1043">PAT1043:Is It a Binary Search Tree</a></h5>

<h5>题意：</h5>

<p>输入一个树的前序遍历序列，判定这个树是否是二叉搜索树或者BST的镜像树，如果是，则用后序序列输出。</p>

<h5>解题思路：</h5>

<ul>
<li><p>1.BST很特殊，实质上BST的所有节点的顺序排列就是中序遍历了。</p></li>
<li><p>2.要检查树是否是BST或者镜像BST，只需按照重建树的思路，在每次重建的过程中做适当检查即可。检查思路是：检查前序遍历序列中，根节点之后的节点排序是否符合BST的二分规则（即前一段都是小于根节点的，后一段都是大于根节点的）。</p></li>
<li><p>3.最后的输出是后序遍历。过程中其实并不用构建整个树，直接在处理过程中，按后序的方式存储节点到队列中即可。</p></li>
</ul>


<p>有了这些考虑，就可以写出代码啦。详细解题代码见链接<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/pat/advancedlevel/APAT1043.java">PAT1043</a></p>

<h2>中序+后序</h2>

<h5>算法描述：</h5>

<ul>
<li><p>初始：用后序遍历序列确定根节点，在中序遍历序列中找到该根节点，则左右子树分别为中序中该节点左右的序列。</p></li>
<li><p>迭代：对各个子树分别执行三步操作，1.在后序序列中找子树的根节点；2。在中序序列中找子树的根节点，并划分开根节点的左右子树；3.根据新生成的左右子树，在后序序列中划分开这些节点，从而得到了两颗子树的后序、中序序列。</p></li>
</ul>


<h5>练习：<a href="http://pat.zju.edu.cn/contests/pat-a-practise/1020">PAT1020:Tree Traversals</a></h5>

<h5>题意：</h5>

<p>输入为一棵二叉树的后序遍历序列和中序遍历序列。求树的前序遍历序列。</p>

<h5>解题思路：</h5>

<ul>
<li><p>1.有了中序和后序，就能重建树。</p></li>
<li><p>2.最后的输出是前序遍历。过程中其实并不用构建整个树。直接在处理过程中，按前序的方式存储节点到队列中即可。</p></li>
</ul>


<p>详细解题代码见链接<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/pat/advancedlevel/APAT1020.java">PAT1020</a></p>

<h2>中序+层序</h2>

<h5>算法描述：</h5>

<ul>
<li><p>初始：用层序遍历确定顶节点，在中序遍历中，利用顶节点划分出左右子树。</p></li>
<li><p>迭代：对各个子树分别执行三步操作，1.在层序序列中，找出子树节点集合中，最靠前的节点，这个节点即为子树的顶节点；2.在中序序列中找1中得到的顶节点，并划分开顶节点的左右子树；</p></li>
<li><p>跟（中序+前序）和（中序+后序）不同之处在于没有迭代的第3步，层序是无法直接划分得到左右子树的节点集合的。但这并不妨碍正常的处理。层序是用来找到子树的顶节点的，而顶节点即是所有子树的节点中，在层序遍历中最靠前的节点。</p></li>
</ul>


<h2><del>前序+后序</del></h2>

<p>这个组合是<strong>无法</strong>重建确定的二叉树的。</p>

<p>对于满二叉树，利用子树节点的排列顺序能区分开左右子树节点集合，构建是没有问题的。但一旦有单个叶子的节点存在，则无法确定叶子是左儿子还是右儿子。因为无论是前序还是后序序列，都无法体现单个儿子情况下，儿子的位置。前序会将左右子树的点置于节点之后，后序则是将左右子树的点置于节点之前。</p>

<ul>
<li>举个简单的反例：</li>
</ul>


<blockquote><p>给出如下的前序序列和后序序列：
preorder: A, B;
postorder: B, A</p>

<p>能构建的二叉树有两种可能，1.A是根节点，B是A左儿子； 2.A是根节点， B是A的右儿子。无法得到一个唯一的结果。</p></blockquote>

<h2><del>前序+层序</del></h2>

<p>这个组合也是无法重建确定的二叉树的。同样于后序+层序的情况。</p>

<p>道理跟（前序+后序）的道理一样，无论是前序、后序，还是层序，都是无法确定单个儿子节点情况下儿子节点的顺序。</p>

<h2>总结</h2>

<ul>
<li>中序遍历配合另外任何一个遍历，能重建二叉树。其他的任意两个序列的组合都不能唯一的确定重建的二叉树。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[二叉树的遍历（递归、非递归）分析]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/04/27/travsal-binary-tree/"/>
    <updated>2013-04-27T21:03:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/04/27/travsal-binary-tree</id>
    <content type="html"><![CDATA[<h2>背景</h2>

<p>二叉树是一种很基本的数据结构。很多地方能看到它的身影，比如大名鼎鼎的霍夫曼编码（好了，别问我再比如了，见识浅薄，真不知道更多了。。。）它的结构很简洁、巧妙。</p>

<p>本文讨论二叉树的常见遍历方式的代码实现（这里贴出的是Java），包括前序(preorder)、中序(inorder)、后序(postorder)、层序(level order)，进一步，考虑递归和非递归的实现方式。递归方法的实现相对简单，但递归的执行方式由于每次都会产生一个新的方法调用栈，如果递归层级较深，会消耗较大的内存，转化为非递归则没那么简单了，往往需要实现一个栈来保存状态信息。</p>

<!--more-->


<p>在此之前，先简单定义节点的数据结构：</p>

<p>二叉树节点最多只有两个儿子，并保存一个节点的值，为了实验的方便，假定它为int。同时，我们直接使用Java的System.out.print方法来输出节点值，以显示遍历结果。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class Node {
</span><span class='line'>      public int value;
</span><span class='line'>      public Node leftNode;
</span><span class='line'>      public Node rightNode;
</span><span class='line'>      
</span><span class='line'>      public Node(int i) {
</span><span class='line'>          value = i;
</span><span class='line'>      }
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<p>详细代码参见链接:<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/algorithm/tree/BinarySearchTree.java">BST及其各种便利的详细实现代码</a></p>

<h2>前序遍历</h2>

<ul>
<li>递归实现：递归实现很简单，在每次访问到某个节点时，先输出节点值，然后再依次递归的对左儿子、右儿子调用遍历的方法。代码如下</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void preOrderTrav(Node n) {
</span><span class='line'>  if (n != null) {
</span><span class='line'>      System.out.print(n.value + " ");
</span><span class='line'>      preOrderTrav(n.leftNode);
</span><span class='line'>      preOrderTrav(n.rightNode);
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>非递归调实现：</li>
</ul>


<p>1.第一种实现方式相对容易理解：</p>

<p>初始：维护一个栈，将根节点压入栈中。</p>

<p>循环：每次从栈顶读出一个节点信息，直接将节点值<strong>输出</strong>，同时将儿子节点按从左到右的顺序推到栈顶。</p>

<p>分析：跟递归调用的整体思路一样，不同的是，递归调用时是利用运行时系统所维护的程序调用栈来维护顺序，而这个非递归方法是用过自己维护的栈来保存信息。如此节省了调用栈的空间。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void preOrderTravNoRecur(Node n) {
</span><span class='line'>  Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();
</span><span class='line'>  stack.add(root);
</span><span class='line'>  while (!stack.empty()) {
</span><span class='line'>      Node t = stack.pop();
</span><span class='line'>      System.out.print(t.value + " ");
</span><span class='line'>      if (t.rightNode != null)
</span><span class='line'>          stack.add(t.rightNode);
</span><span class='line'>      if (t.leftNode != null)
</span><span class='line'>          stack.add(t.leftNode);
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>2.第二种实现方式更普遍（中序遍历的非递归使用了同样的思路）：</p>

<p>初始：维护一个栈S和一个节点变量N。节点变量赋值为根节点。</p>

<p>循环：将节点变量N的左儿子循环的<strong>输出</strong>，并推入栈S中，直到没有左儿子；推出栈S的顶节点，节点变量N赋值为栈S顶节点的右节点。</p>

<p>分析：不同于递归调用的思路。栈S用于实现对某节点的左边支递归值的存储，以便回溯；节点变量N则用于遍历某节点的右边枝（这些节点是从栈S顶读出的节点，依次做处理），由于右边枝是最后才会被访问到的，故在处理右边枝的时候，不需要存储右边枝的信息，依次处理即可。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void preOrderTravNoRecurII(Node n) {
</span><span class='line'>  System.out.println("No Recursive: ");
</span><span class='line'>  Stack&lt;Node&gt; s = new Stack&lt;Node&gt;();
</span><span class='line'>  while (n != null | !s.empty()){
</span><span class='line'>      while (n!=null ){
</span><span class='line'>          System.out.print(n.value + " ");
</span><span class='line'>          s.add(n);
</span><span class='line'>          n = n.leftNode;
</span><span class='line'>      }
</span><span class='line'>      n = s.pop();
</span><span class='line'>      n = n.rightNode;
</span><span class='line'>  }
</span><span class='line'>  System.out.println();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>中序遍历</h3>

<ul>
<li>递归实现</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void inorderTrav(Node n) {
</span><span class='line'>  if (n != null) {
</span><span class='line'>      inorderTrav(n.leftNode);
</span><span class='line'>      System.out.print(n.value + " ");
</span><span class='line'>      inorderTrav(n.rightNode);
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>非递归实现</li>
</ul>


<p>初始：维护一个栈S和一个节点变量N。节点变量赋值为根节点。</p>

<p>循环：将节点变量N的左儿子循环的<strong>输出</strong>，并推入栈S中，直到没有左儿子；节点变量N赋值为栈S顶节点的右节点。</p>

<p>分析：跟前序遍历的非递归实现方法二很类似。唯一的不同是输出的时机不同：前序遍历在入栈时输出，而中序遍历在出栈时输出。可以跟深刻的理解到，栈在这里是为了回溯而存在的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void inorderTravNoRecu(Node n) {
</span><span class='line'>  System.out.println("No Recursive: ");
</span><span class='line'>  Stack&lt;Node&gt; s = new Stack&lt;Node&gt;();
</span><span class='line'>  while (n != null | !s.empty()){
</span><span class='line'>      while (n!=null ){
</span><span class='line'>          s.add(n);
</span><span class='line'>          n = n.leftNode;
</span><span class='line'>      }
</span><span class='line'>      n = s.pop();
</span><span class='line'>      System.out.print(n.value + " ");
</span><span class='line'>      n = n.rightNode;
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>后序遍历</h3>

<ul>
<li>递归实现</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void preOrderTravNoRecurII(Node n) {
</span><span class='line'>      System.out.println("No Recursive: ");
</span><span class='line'>      Stack&lt;Node&gt; s = new Stack&lt;Node&gt;();
</span><span class='line'>      while (n != null | !s.empty()){
</span><span class='line'>          while (n!=null ){
</span><span class='line'>              System.out.print(n.value + " ");
</span><span class='line'>              s.add(n);
</span><span class='line'>              n = n.leftNode;
</span><span class='line'>          }
</span><span class='line'>          n = s.pop();
</span><span class='line'>          
</span><span class='line'>          n = n.rightNode;
</span><span class='line'>      }
</span><span class='line'>      System.out.println();
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<ul>
<li>非递归实现</li>
</ul>


<p>初始：1.维护一个栈S、一个节点变量N和一个标记数组。节点变量赋值为根节点，栈暂时存储便利到的节点，标记数组用于标记栈中的节点是否已经访问过右边节点。2.将根节点的所有左儿子压入栈中。</p>

<p>循环：依次处理栈中节点。如果节点有右儿子，且没有被处理过（通过标记数组判定），则将右子树的根节点及其左儿子全部压入栈中；如果已经处理过或者没有右儿子，则输出并出栈。</p>

<p>分析：与前序和中序的一个大的不同在于需要用标记数组标记节点的右子树是否已经访问过。对每个节点进行处理的时候，都保证已经处理完了左右子树（通过先压入左边儿子为主线，处理栈中的每个节点时，再压入右边儿子来实现）。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void postOrderTravNoRecu(Node n) {        
</span><span class='line'>      Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();
</span><span class='line'>      int[] flag = new int[max];
</span><span class='line'>      
</span><span class='line'>      while (n != null) {
</span><span class='line'>          stack.push(n);
</span><span class='line'>          flag[stack.size()] = 0;
</span><span class='line'>          n = n.leftNode;
</span><span class='line'>      }
</span><span class='line'>      
</span><span class='line'>      while (!stack.empty()) {
</span><span class='line'>          n = stack.peek();
</span><span class='line'>          while(n.rightNode != null && flag[stack.size()] == 0) {
</span><span class='line'>              n = n.rightNode;
</span><span class='line'>              flag[stack.size()] = 1;
</span><span class='line'>              while (n != null) {
</span><span class='line'>                  stack.push(n);
</span><span class='line'>                  flag[stack.size()] = 0;
</span><span class='line'>                  n = n.leftNode;
</span><span class='line'>              }
</span><span class='line'>              n = stack.peek();//TODO be careful about this
</span><span class='line'>          }
</span><span class='line'>          n = stack.pop();
</span><span class='line'>          System.out.print(n.value + " ");
</span><span class='line'>      }
</span><span class='line'>      
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<h3>层序遍历</h3>

<ul>
<li>无法使用递归方法</li>
</ul>


<p>层序遍历不同于其他的遍历。可以通过反证法证明：</p>

<p>如果能实现对A节点的层序递归，在对A节点处理的过程中，应该递归的对两个儿子B和C分别调用了层序遍历。在这种情况下，我们无法让B和C的同一个层级的儿子在集中的时间中被遍历到，换言之，B的第一层儿子在对B的调用中被遍历，而C的第一层儿子，则在对C的调用中遍历，这是分离开的。不成立，得证。</p>

<ul>
<li>非递归方法：</li>
</ul>


<p>分析：此方法类似于前序遍历的非递归方法的第一种。用一个栈维护信息。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void levelOrderTrav(Node n) {
</span><span class='line'>  System.out.print("Level OrderTrav: ");
</span><span class='line'>  
</span><span class='line'>  Queue&lt;Node&gt; q = new LinkedList&lt;Node&gt;();
</span><span class='line'>  q.add(n);
</span><span class='line'>  while (q.size() != 0) {
</span><span class='line'>      n = q.poll();
</span><span class='line'>      System.out.print(" " + n.value);
</span><span class='line'>      if (n.leftNode != null) 
</span><span class='line'>          q.add(n.leftNode);
</span><span class='line'>      if (n.rightNode != null)
</span><span class='line'>          q.add(n.rightNode);
</span><span class='line'>
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>总结</h2>

<p>非递归实现的代码相对来说没有递归实现的直观。其核心都是维护了一个栈来保存状态，避免了产生过多方法调用栈浪费内存空间。</p>

<p>本文中针对二叉树的几种遍历方式，描述了递归和非递归的解决方案。普遍意义的递归转非递归的方法和思想，将在另外一篇博文中介绍;)。欢迎交流。</p>
]]></content>
  </entry>
  
</feed>
