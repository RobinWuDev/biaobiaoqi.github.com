<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Biaobiaoqi的博客]]></title>
  <link href="http://biaobiaoqi.github.com/atom.xml" rel="self"/>
  <link href="http://biaobiaoqi.github.com/"/>
  <updated>2013-08-02T02:26:37+08:00</updated>
  <id>http://biaobiaoqi.github.com/</id>
  <author>
    <name><![CDATA[Biaobiaoqi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PAT 1031-1040 题解]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/08/01/pat-1031-1040-solutions/"/>
    <updated>2013-08-01T01:43:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/08/01/pat-1031-1040-solutions</id>
    <content type="html"><![CDATA[<p>早期部分代码用 Java 实现。由于 PAT 虽然支持各种语言，但只有 C/C++标程来限定时间，许多题目用 Java 读入数据就已经超时，后来转投 C/C++。浏览全部代码：<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/tree/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel">请戳</a></p>

<p>本文谨代表个人思路，欢迎讨论;)</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1031">1031. Hello World for U (20)</a></h2>

<h5>题意</h5>

<p>将给定的字符串打印出 U 型。</p>

<p>比如给定<code>helloworld</code>，打印出</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>h  d
</span><span class='line'>e  l
</span><span class='line'>l  r
</span><span class='line'>lowo
</span></code></pre></td></tr></table></div></figure>


<p>设定左边的字符个数为 n1,底边字符个数为 n2,右边字符个数为 n3。需要满足 n1 = n3 = max
{k|k &lt;= n2 for all 3 &lt;= n2 &lt;= N} with n1 + n2 + n3 -3 = N.</p>

<h5>分析</h5>

<p>简单模拟题。</p>

<!--more-->


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1032">1032. Sharing (25)</a></h2>

<h5>题意</h5>

<p>为了节省存储空间，单词使用链表实现。比如对于<code>loading</code>和<code>being</code>两个单词，有如下存储结构：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>word1 : -&gt; [l] -&gt; [o] -&gt; [a] -&gt; [d]  
</span><span class='line'>                                  \
</span><span class='line'>                                    [i] -&gt; [n] -&gt; [g] -&gt; null
</span><span class='line'>                                  /
</span><span class='line'>word2 : -&gt; [b] -&gt; [e] -------------
</span></code></pre></td></tr></table></div></figure>


<p>输入中，指定了两个单词的首字符的地址，并给出了 N (&lt;= 10<sup>5)个节点，每个节点包含：物理地址（5</sup> 位的正整数），实际存储的字符以及指向的下一个节点的地址。NULL 的地址是-1.
要求找到两单词的的公共后缀开始的地址，如果没有，则输出-1.</p>

<h5>分析</h5>

<p>既然是单词，它的长度应该是有限的，也就是链表不会出现环这种情况（实际上这里的处理方式对于有环无环都适用）。对第一个单词链表做遍历，对爬过的节点做好标记。第二个单词链表也同样做标记，一旦遇到已经标记过的节点，则该节点就是结果。</p>

<p>需要注意一点：直接使用 map 做节点的存储最后一个 case 会超时。而鉴于 5 位正整数的数据量，可以直接使用数组，用空间换时间。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1033">1033. To Fill or Not to Fill (25)</a></h2>

<h5>题意</h5>

<p>高速路从 A 地到 B 地，路途有许多加油站，每个加油站的油价不一样，要求计算一个最优方案，使得以最便宜的开销跑完全程。</p>

<h5>分析</h5>

<p>用贪心算法，理清贪心算法的策略：</p>

<ul>
<li>1.从 A 加油站出发，在能行走的最大范围内，如果有比 A 站汽油更便宜的 B 站，则保证在 A 站点的加油量刚好满足能到达 B 站点；如果没有比 A 站汽油更便宜的站，则在 A 加满车油行走到【从 A 能走出的范围内】油价【最便宜】的站上，再行计算。</li>
<li>2.从 A 加油站出发，在能行走的最大范围内，如果没有其他站点，则 A.dist + 一次最大的行走距离 为 impossible 情况下的最大站点。</li>
</ul>


<p> 注意有个陷阱：如果没有距离为 0 的加油站，则无法行驶。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1034">1034. Head of a Gang (30)</a></h2>

<h5>题意</h5>

<p>『gang』翻译过来是『一伙人』。gang 的定义是一群人，至少有 3 个人，这群人中每个人之间都通过通话相连，且整个群体的通话时长超过一个阈值。整个 gang 的团体中，拥有的电话时长最长的人就是头目了。</p>

<p>题目给定了 gang 的阈值 K，以及 N 个通话记录，每条记录包括主叫人、被叫人以及通话时间。要求计算出有几个 gang，并按照 gang 的头目的字母顺序排序输出头目和其中成员数量。</p>

<h5>分析</h5>

<p>本题使用 dfs 求解比较方便。dfs 能简单的实现状态值的记录，比如当前的 gang 的成员数量和权重，如果使用并查集，则相对复杂。</p>

<p>需要注意的坑点：如果建立邻接表时，每个通话记录都在两人头上计算了时间积累的，那么在判定 gang 的权重值是否低于阈值的时候，需要对阈值乘以 2。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1035">1035. Password (20)</a></h2>

<h5>题意</h5>

<p>给定多个字符串，按要求替换其中的某些特殊字符，并按原顺序输出。如果字符串中没有需要修改的字符，则不舒服该字符串。</p>

<h5>分析</h5>

<p>简单的 hash 实现。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1036">1036. Boys vs Girls (25)</a></h2>

<h5>题意</h5>

<p>输入是一批学生的成绩，要求找出其中男生最低的成绩和女生最高的成绩，求其间的差值。如果无法计算，则输出 NA.</p>

<h5>分析</h5>

<p>简单模拟题。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1037">1037. Magic Coupon (25)</a></h2>

<h5>题意</h5>

<p>背景是火星上的神奇的购物券购物策略：每张购物券上有一个整数，可正可负，商店里商品的标价也是一个整数，可正可负的。如果用正值购物券购买正值商品，则可获利两者之积；如果以负值购物券购买负值商品，也可获利两者之积；但其他情况，则会亏损。比如用面值为<code>2</code>的购物券购买面值为<code>3</code>的商品，获利<code>6</code>，用面值为<code>-5</code>的购物券购买面值为<code>-9</code>的商品，获利<code>45</code>，但如果用面值为<code>2</code>的购物券购买面值为<code>-3</code>的商品，则亏损<code>6</code>，</p>

<p>给定一组数量为 NC 购物券面值和一组数量为 NP 的商品面值，1&lt;= NC , NP &lt;= 10<sup>5，要求计算能获利的最大值。</sup></p>

<h5>分析</h5>

<p>同号相乘可获利，异号相乘会亏损。要使获利最大，使用贪心思想计算。实际上，不需要用完购物券或者买完商品，所以只需要将同号的数值乘积算出即可，没有更复杂的情况。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1038">1038. Recover the Smallest Number (30)</a></h2>

<h5>题意</h5>

<p>给定 N(&lt;= 10000)个不超过 8 位的非负整数，要求将其按某个顺序拼接为一个数，使其值最小。</p>

<h5>分析</h5>

<p>容易简单的以为使用字典序排列拼接，实际上有一个特殊的拼接情况需要考虑。</p>

<p>比如数据<code>32 321 3214</code>，这是按字典序排列的，但实际上这并不是最小的拼接方式，最小的拼接方式是：<code>321 3214 32</code>。</p>

<p>比较这个实例，不难找到最小拼接的排序规律：</p>

<ul>
<li>1.两个字符串做比较时，如果其中一个字符串(a)是另一个字符串(ab)的前缀串，则需要将较长字符串(ab)除去前缀串的部分(b)与较短字符串(a)继续递归比较。比如，321 和 32，需要拿 1 和 32 做比较。又比如 323 和 32 比较，第一次拿 3 和 32 比较，第二次拿 3 和 2 按字典序比较。</li>
<li>2.其他情况按字典序比较。</li>
</ul>


<p>另外需要注意的一个坑是：如果没有数据，则输出 0。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1039">1039. Course List for Student (25)</a></h2>

<h5>题意</h5>

<p>给出 K(&lt;=2500)门课程，每门课程有 Ni(&lt;=200)名学生，学生编号为四位字符串，前三位为小写英文字母，后一位是数字。另给出 N 个需要查询的学生编号。</p>

<p>要求列出对应查询编号学生的课程。如果有多个课程，需要按升序输出。</p>

<h5>分析</h5>

<p>这个题是个倒排索引的实现。不过在时间上卡的比较严。</p>

<p>使用最简单的思路：map&lt;string, vector<int> students 倒排索引，在没有输出排序的课程列表时最后一个 case 已经超时；优化：将学生姓名的 hash 为 int，减免了 string 的匹配过程，还是超时（map 本身用红黑树实现，效率并不是特别高，还需要对每组数据进行排序），只能改变使用 map 的方式。</p>

<p>最终 AC 的解法是：</p>

<ul>
<li>构建一个从学生编号字符串到 int 值的 hash 函数，在读入学生编号后，hash 到 int 值做处理。</li>
<li>不适用 map 结构，根据学生姓名的限制，设定一个<code>vector&lt;int&gt; st[26*26*26*10]</code>的数据结构，读入时直接倒排索引插入。</li>
</ul>


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1040">1040. Longest Symmetric String (25)</a></h2>

<h5>题意</h5>

<p>给定一个字符串，要求输出最长的连续对称子串的长度。比如给定字符串为<code>Is PAT&amp;TAP symmetric?</code>，其中最长对称子串为<code>s PAT&amp;TAP s</code>，所以输出结果 11.</p>

<h5>分析</h5>

<p>这个题就是典型的 Java 实现 timeout，而 Cpp 实现轻松过的类型。需要注意两点：</p>

<ul>
<li>1.有两种对称情况，一种形如<code>aba</code>，一种形如<code>abba</code>。</li>
<li>2.循环遍历的过程，以 index 为对称中心向两边扩散比较编码实现简单也更高效。</li>
</ul>


<p>另外，C 读入一整行数据到 char 数组的方法可以用<code>gets(s);</code>。</p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/08/01/pat-1031-1040-solutions/'>http://biaobiaoqi.github.com/blog/2013/08/01/pat-1031-1040-solutions/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PAT 1021-1030 题解]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/08/01/pat-1021-1030-solutions/"/>
    <updated>2013-08-01T01:43:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/08/01/pat-1021-1030-solutions</id>
    <content type="html"><![CDATA[<p>早期部分代码用 Java 实现。由于 PAT 虽然支持各种语言，但只有 C/C++标程来限定时间，许多题目用 Java 读入数据就已经超时，后来转投 C/C++。浏览全部代码：<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/tree/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel">请戳</a></p>

<p>本文谨代表个人思路，欢迎讨论;)</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1021">1021. Deepest Root (25)</a></h2>

<h5>题意</h5>

<p>无环连通图也可以视为一棵树，选定图中任意一点作为根，如果这时候整个树的深度最大，则称其为 deepest root。
给定一个图，按升序输出所有 deepest root。如果给定的图有多个连通分量，则输出连通分量的数量。</p>

<h5>分析</h5>

<p>算法实现的步骤如下：</p>

<ul>
<li>1.使用并查集判断图是否为连通的。</li>
<li>2.任意选取一点，做 dfs 搜索，选取其中一个最远距离的点 A，再做一次 dfs，找到的所有距离最远的点以及点 A 都是 deepest root。</li>
</ul>


<p>判定图是否连通使用 union-find set 即可。更关键的点在于找到 deepest root。实际上，使用两次 dfs 就可以实现。
证明之前，先介绍两个概念，一个是直径，树的 deepest root 到最远叶子的路径我们暂称直径，而 deepest root 和最远叶子节点则成为端点。
注明关键在于以下两点：</p>

<ul>
<li><p>从任意一个点 dfs 得到的最远点都是直径的端点。证明如下：</p>

<p>  任意选一点 A，做 dfs 查找距离 A 最远的点，因为是 dfs，所以肯定会经过某直径上的点 B，从 B 出发最远的点是直径上的端点 C。
  那么，这个端点 C 为何一定是 A 的最远居里点呢？可以反证证明，如果有一个点 D，A->D 不经过直径，且 length(A->D) > length(A->C)，
  那么，从 C 所在直径上构造出经过 D 的比原直径更长的直径，得证。</p></li>
<li><p>所有的树的直径都交于一点（或者公用段路径上的几点）。
于是，从 B 点 dfs 出发的所有最长距离的点即为 deepest root。证明如下：</p>

<p>  如果两条直径不相交，而树上任意两点肯定连通，则从两直径上，可以选取两点连通以组成更长的直径；如果三条直径相较于不同的两点，也可以根据相交截断的长度组合出更长的直径。</p></li>
</ul>


<!--more-->


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1022">1022. Digital Library (30)</a></h2>

<h5>题意</h5>

<p>给定 N (&lt;=10000) 本书的信息，包括 7 位 ID，最多 80 字符的书名，最多 80 字符的作者名，
多个最多 10 字符的关键词，最多 80 字符的出版商和属于 [1000, 3000]的出版时间。
另给出 M (&lt;=1000) 的查询请求，按照查询格式分为：</p>

<ul>
<li>1: 书名</li>
<li>2: 作者</li>
<li>3: 关键词</li>
<li>4: 出版商</li>
<li>5: 年份</li>
</ul>


<p>输出查询结果。如果有多个结果，按照书的 ID 的升序排列。</p>

<h5>分析</h5>

<p>简单模拟题。在使用 Map 结构来构建倒排索引的过程中，可以讨巧的避免根据不同查询类型使用两层 map，
直接通过在 key 中增加查询标记来实现。另外 C++的 priority_queue 支持对常规数据类型的最小堆实现：<code>priority_queue&lt;string, vector&lt;string&gt;, greater&lt;string&gt;&gt;</code>，方便了结果输出。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1023">1023. Have Fun with Numbers (20)</a></h2>

<h5>题意</h5>

<p>给出一个 20 位的正整数，要求计算其乘以 2 的值，并判定结果的数值是否是原数字所有位数打乱的结果。结果输出 Yes 或 No，以及乘以 2 以后的数字。</p>

<h5>分析</h5>

<p>判重使用 Hash 思想。过程如下：</p>

<ul>
<li>1.原数字按字符串读入，并在一个 int hash[10]的 hash 数组中标记每个数值出现的次数，比如如果出现了四次 1，则 hash[1]=4。</li>
<li>2.模拟实现乘以 2 的简单乘法过程，没计算出一位的值，在 hash[]中对应位置上减一。</li>
<li>3.最后通过判定 hash 是否全为 1 和最后结果是否有进位来做判定。</li>
</ul>


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1024">1024. Palindromic Number (25)</a></h2>

<h5>题意</h5>

<p>非回文数可以通过将它与它的倒转数相加，并不断迭代这一过程获得回文数的结果。比如 67 经过两次处理就得到了 484：
<code>67 + 76 = 143, and 143 + 341 = 484.</code></p>

<p>给定一个数和迭代的次数，判断能否在迭代次数内获得回文结果。</p>

<h5>分析</h5>

<p>简单模拟题，处理数字，做逻辑判断。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1025">1025. PAT Ranking (25)</a></h2>

<h5>题意</h5>

<p>以 PAT 考试为背景，给所有人做排名。给定的数据包括 N(&lt;=100)为赛区的数目，每个赛区的人数以及每个人的分数。
按照总排名、分区号、注册号的优先级排名。</p>

<h5>分析</h5>

<p>简单模拟题，使用 qsort()排序，注意相同分数的人应该拥有相同的排名。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1026">1026. Table Tennis (30)</a></h2>

<h5>题意</h5>

<p>乒乓球俱乐部有 K 张乒乓球桌，其中有 M 张是 VIP 桌。有很多人到俱乐部打球，如果桌子都满了，多余的人只能排队等待。</p>

<p>有一个特殊的 VIP 制度：如果有空的 VIP 桌，那么等待队列中的第一对 VIP 会员可以使用这张卓，
如果等待队列中没有 VIP 会员，那么一般会员也可以使用 VIP 桌。当轮到 VIP 上的时候，没有 VIP 桌子，那么 VIP 用户也可以使用一般的桌子。</p>

<p>另外，每张桌服务一对会员的时间最大限制在两个小时。</p>

<p>给定了乒乓球桌的数量 M(编号为 1-M)，其中 VIP 卓的数量 K，并指定是那几张桌子。给出来乒乓球俱乐部的 N 对会员的信息，每对会员有一个达到时间，
是否是 VIP 的标记以及打球的时间。要求计算出每对会员的等待时间，以及每张桌服务过的次数。</p>

<h5>分析</h5>

<p>排队模拟题。有两种思路：</p>

<ul>
<li>1.主体循环处理人。将乒乓球桌和人都当做资源，乒乓球桌对应记录了 available 的时间，每次取出 available 最早的时间，从等待队列中选
则最早的会员使用乒乓球桌。其中 vip 处理逻辑为：如果 available 并列最早的桌子中有 vip 桌，则看等待队列中有没有 vip 会员，
如果有则直接处理他，否则按照正常逻辑处理。每次将某会员安置到一个乒乓球桌上，则可以输出该会员的等待时间的结果信息，并将该乒乓球桌的
服务人数增加一。</li>
<li>2.主体循环是时间。这样需要模拟同一时刻所有的乒乓球桌以及等待队列，相对比较复杂。</li>
</ul>


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1027">1027. Colors in Mars (20)</a></h2>

<h5>题意</h5>

<p>给定三个十进制数，要求格式化输出其 13 进制表达。</p>

<h5>分析</h5>

<p>简单的数字处理和 hash 实现。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1028">1028. List Sorting (25)</a></h2>

<h5>题意</h5>

<p>模拟 Excel 中按列排序。N (&lt;=100000) 为数据条数，每条数据由三列组成：ID，姓名，成绩。C 可以等于 1,2,3，分别对应到按三列中的哪一列排序。
输出排序结果。</p>

<h5>分析</h5>

<p>简单排序题。两种思路：</p>

<ul>
<li>1.简单的直接使用 qsort()实现。</li>
<li>2.自己手写排序算法，比如二叉搜索树实现。</li>
</ul>


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1029">1029. Median (25)</a></h2>

<h5>题意</h5>

<p>给定两个已排序的整数序列，求出两组数的集合里中间大小的数。</p>

<h5>分析</h5>

<p>使用归并排序思路实现。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1030">1030. Travel Plan (30)</a></h2>

<h5>题意</h5>

<p>给定加权图，每条边有两种权值：一是路径长度，二是开销。要求求出给点两点间的最短路径，如果路径长度一样，则要求比较选择开销最小的路径。</p>

<h5>分析</h5>

<p>使用 Dijkstra 算法的变形，增加一个权重的判定，可以轻松解决。<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/08/01/pat-1021-1030-solutions/'>http://biaobiaoqi.github.com/blog/2013/08/01/pat-1021-1030-solutions/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PAT 1011-1020 题解]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/07/31/pat-1011-1020-solutions/"/>
    <updated>2013-07-31T23:41:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/07/31/pat-1011-1020-solutions</id>
    <content type="html"><![CDATA[<p>早期部分代码用 Java 实现。由于 PAT 虽然支持各种语言，但只有 C/C++标程来限定时间，许多题目用 Java 读入数据就已经超时，后来转投 C/C++。浏览全部代码：<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/tree/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel">请戳</a></p>

<p>本文谨代表个人思路，欢迎讨论;)</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1011">1011. World Cup Betting (20)</a></h2>

<h5>题意</h5>

<p>给定一个 3*3 的矩阵，找到每行的最大值，格式化输出一个运算结果。</p>

<h5>分析</h5>

<p>非常简单的模拟题。</p>

<!--more-->


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1012">1012. The Best Rank (25)</a></h2>

<h5>题意</h5>

<p>给定学生的学号和三个科目的分数，查询输出对应学生单门科目排名和总分排名中最高的那个排名。</p>

<h5>分析</h5>

<p>C 里 stdlib.h 中的 qsort()和 C++里 algorithm 中的 sort()函数都能实现快排，应对编程题中的排序一般比自己手写的要快。
分别为三个单科和总分做排序，并将 rank 值记录到 map 结构中去，便于之后的查找。</p>

<p>需要注意并列排名的情况。比如<code>1 2 2 4</code>，由于并列第 2 的都两人，那之后的那个人就是第 4 而不是第 3 了。</p>

<p>另外，由于有多个需要分别排序、排名的项，抽象出公共逻辑到一个函数里比较必要，否则代码分散难于 debug 和维护。
这里稍微特殊点的用法是使用了<a href="http://blog.csdn.net/dyx1024/article/details/7562786">函数指针</a>做参数。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1013">1013. Battle Over Cities (25)</a></h2>

<h5>题意</h5>

<p>给定一张图和指定几个点。针对给出的每个点，要求计算在图中除掉连接该点的路径的情况下，保证整个图连通需要添加几条边。</p>

<h5>分析</h5>

<p>计算保证整个图连通需要几个点，亦即求出图中有几个连通分量。两种思路：</p>

<ul>
<li>1.并查集</li>
<li>2.DFS</li>
</ul>


<p>针对每个点，执行算法的过程中，需要注意去除掉改点对应的所有通路。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1014">1014. Waiting in Line (30)</a></h2>

<h5>题意</h5>

<p>这道题是排队模拟题。银行有 N 个窗口，每个窗口允许排队 M 个人，如果 N 个窗口占满了排队的人，更多的人需要在黄线外等待。
每个人都会选择尽可能人少的窗口排队，如果有多个窗口等待队列一样长，则选择编号小的窗口。
前 N 个用户设定在 8:00 开始接受服务。给定了 K 个用户所需要接受服务的时间长度，要求在这个排队模型下，每个人的完成处理的时间点。</p>

<h5>分析</h5>

<p>相对另外几个队列模拟题，这个题是很简单的。没有达到时间的差异，只需要不断的从等待队列中取出人员即可。
当然，由于黄线内等待的每个窗口都有 M 人，所以必须单独的模拟每个窗口。
可以使用 queue 模拟每个窗口，循环遍历下次离开窗口的人，继而从等待队列中补上。
需要注意结束条件，如果 17:00 以后还没有开始接受服务，则不用再等待。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1015">1015. Reversible Primes (20)</a></h2>

<h5>题意</h5>

<p>Reversible Primes 是指在某个进制下，一个数本身和它翻转过来形成的新数都是素数。
题中给出多组数据，以负数结尾程序。每组数据包含一个数以及一个进制数。判定该数是否是 Reversible Primes.</p>

<h5>分析</h5>

<p>两个功能点实现：判定素数和特定进制下的数据倒转。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1016">1016. Phone Bills (25)</a></h2>

<h5>题意</h5>

<p>给出一天中每个不同的小时内的电话付费标准，给出一份分为打出和挂断两种记录的通话记录，包括记录发生的时刻和用户名字，
要求整理出当月有效用户的账单，输出格式中需要输出所有的通话记录，包括开始时刻和结束时刻，每次通话的话费以及总计的话费。</p>

<h5>分析</h5>

<p>模拟题。首先对输入的通话记录按照先姓名后时间做 qsort()排序，然后遍历排序后的记录，找到合适的匹配对，计算每次通话的时间，并进行统计和输出。</p>

<p>实现的难点主要有两个：</p>

<ul>
<li>1.在排序后的记录中，找到合适的配对。如果某人的通话记录为<code>1.on;2.on;3.off;</code>，则其中<code>1.on</code>将被抛弃，匹配到<code>2.on;3.off;</code>。
题中仅仅保证了所有记录中至少有一对有效记录，但并没有保证每个人都有有效通话记录，所以还需要做好过滤，
如果某人没有有效通话记录，则不输出。整体的控制流程需要谨慎。</li>
<li>2.由于不同时刻的话费不一样，计算一次有效通话的话费比较复杂。可以采用的方式是用起始时刻分阶段追赶结束时刻。追赶的过程分阶段，也就能计算好不同阶段的开销，
先将起始时间调整到跟结束时间为同一天，细节是先让分钟达到 0，再让小时迭代到 0，天进位，一直迭代到跟结束时间同天；再让起始时刻的小时数追平
结束时刻；最后让分钟追平。以此计算出最终话费。</li>
</ul>


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1017">1017. Queueing at Bank (25)</a></h2>

<h5>题意</h5>

<p>银行有 K 个窗口，所有到达银行的人都应该在黄线外等待，直到有窗口空余。
每个窗口对单个客人最多服务时间为 1 小时。N 个用户的到达时间和需要处理的时间给出。
8:00 到 17:00 接受服务，逾期不服务，也不计入统计数据。要求格式化输出用户的平均等待时间。</p>

<h5>分析</h5>

<p>又一道排队模拟题。相比 PAT1014，此题更复杂在于用户的到达时间是不确定的。
首先使用 qsort()按照到达时间对所有人排序。由于每个窗口同时只有一个人在处理，所以窗口之间没有差异，可以用 priority_queue 建立一个队列，
模拟所有 K 个窗口。
优先队列将结束时间最早的人放到队列的顶端，每次循环处理一个人的结束。然后步入一个黄线外等待的人。如果那个时刻，下一个人还没有达到，则可以将该人开始执行的时间记录为他的到达时间，并加入队列中。
还有一点需要注意的：HH:MM:SS 的时间格式，可以转换为累积秒数的时间，方便计算比较。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1018">1018. Public Bike Management (30)</a></h2>

<h5>题意</h5>

<p>以杭州的公用自行车站点管理为背景。每个站点是一个节点，每个节点上最多停放 Cmax 辆自行车，Cmax/2 为节点的最佳状态。不同节点间距离不同，整个构成了一张带权无向图。要求从起始点（公用自行车管理中心）出发，去目的地维护目的地节点的车辆状态，如果车辆低于 Cmax/2，则给它添加车辆到 Cmax/2 辆，如果多于 Cmax/2，则去除掉几辆车。同时，在去往目的地的过程中，也需要调整所有沿途站点的车辆（这里题目没有交代清楚，实际测试是只能在去往目的地的途中调整，回来的途上不可调整）。求到给定目的地的最短路径，如果有多条最短路径，则按照 1.从管理中心送出的车辆越少越好；2.拿回到管理中心的车越少越好的优先级找到结果。</p>

<h5>分析</h5>

<p>题目的大体框架是有权最短路径问题。步骤如下：</p>

<ul>
<li>1.使用 Dijkstra 找到最短路径，其中注意记录每个节点在最短路径中的【所有】前驱节点；</li>
<li>2.使用 DFS 的方法，得到所有的最短路径。</li>
<li>3.计算每条最短路径的带出和带回的车辆数量。</li>
</ul>


<p>其中 DFS 时，归纳所有答案的过程比较通用，需要掌握。</p>

<p>另外值得注意的是，类比到 PAT1003，该题采用了直接对每个节点增加状态记录的方式，直接得到最优解，而不是先找到最短路径，然后计算比较。本题是无法用这种方法实现的，需要送出和带回的自行车数量无法直接在 Dij 算法中每个节点的计算中体现，并不是前面的节点带回和送出的车辆越少，后面的节点就一定能得到更优解。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1019">1019. General Palindromic Number (20)</a></h2>

<h5>题意</h5>

<p>给定一个十进制数和一个进制，要求计算出在给定进制下的表达并判定是否为回文。</p>

<h5>分析</h5>

<p>简单的数字处理。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1020">1020. Tree Traversals (25)</a></h2>

<h5>题意</h5>

<p>根据二叉树的后序遍历和中序遍历，求层序遍历。</p>

<h5>分析</h5>

<p>具体实现方式：</p>

<ul>
<li>初始：用后序遍历序列确定根节点，在中序遍历序列中找到该根节点，则左右子树分别为中序中该节点左右的序列。</li>
<li>迭代：对各个子树分别执行三步操作，1.在后序序列中找子树的根节点；2。在中序序列中找子树的根节点，并划分开根节点的左右子树；3.根据新生成的左右子树，在后序序列中划分开这些节点，从而得到了两颗子树的后序、中序序列。</li>
</ul>


<p>有一个结论：中序遍历配合另外任何一个遍历，能重建二叉树。其他的任意两个序列的组合都不能唯一的确定重建的二叉树。具体分析参见博文<a href="../../../../2013/04/27/pat1020-pat1043-rebuild-binary-tree/">《根据前中后序和层序重建二叉树(PAT1020、PAT1043)》</a>。</p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/07/31/pat-1011-1020-solutions/'>http://biaobiaoqi.github.com/blog/2013/07/31/pat-1011-1020-solutions/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PAT 1001-1010 题解]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/07/31/pat-1001-1010-solutions/"/>
    <updated>2013-07-31T02:03:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/07/31/pat-1001-1010-solutions</id>
    <content type="html"><![CDATA[<p>早期部分代码用 Java 实现。由于 PAT 虽然支持各种语言，但只有 C/C++标程来限定时间，许多题目用 Java 读入数据就已经超时，后来转投 C/C++。浏览全部代码：<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/tree/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel">请戳</a></p>

<p>本文谨代表个人思路，欢迎讨论;)</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1001">1001. A+B Format (20)</a></h2>

<h5>题意</h5>

<p>格式化输出两数之和。</p>

<h5>分析</h5>

<p>理清输出逻辑即可。</p>

<!--more-->


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1002">1002. A+B for Polynomials (25)</a></h2>

<h5>题意</h5>

<p>给定两多项式，相加并格式化输出结果。</p>

<h5>分析</h5>

<p>两种思路</p>

<ul>
<li>1.采用链表的处理方式；</li>
<li>2.预设好 int[1005]的数组，用下标表示次方，数组中元素值表示对应系数。</li>
</ul>


<p>第一种方法某种程度上看能节省空间，实现上需要注意操作链表时，循环时的越界问题；
方法二用空间换取时间，且实现上更不容易出错。同时，由于浮点数本身精确位数不够，在判定两浮点数相加是否为 0 时，
需要对结果值取绝对值后，与 1e-6 做对比。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1003">1003. Emergency (25)</a></h2>

<h5>题意</h5>

<p>求两个城市之间的加权最短路径。在有多个最短路径记录的情况下，选择路径中所有节点的权重值之和最小的。</p>

<h5>分析</h5>

<p>Dijkstra 算法的变型实现。两种思路：</p>

<ul>
<li>1.计算最短路时，在每个节点上用链表 preList 记下所有最短路径的前节点。
完成计算后，对 preList 做 dfs 获得每条最短路径的权重值之和，比较后得到结果；</li>
<li>2.计算最短路径时，在节点上，除了记录最短路径中前一个节点 preNode 之外，还对应的记录当前的最短路径上所有节点的权重值之和，
这就不用在 Dij 完成之后再做 dfs 了，过程中已经找到了最优解。</li>
</ul>


<p>相比之下，方法 2 明显更简洁。当然，虽然方法 2 的思路很通用，还需要确定，这一加权的判定条件是能够迭代处理的。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1004">1004. Counting Leaves (30)</a></h2>

<h5>题意</h5>

<p>计算给定的树各个层级叶子节点的个数</p>

<h5>分析</h5>

<p>先构建树，鉴于题目的空间限制不严格，可以使用邻接矩阵的方式定义树结构。然后使用 dfs 遍历树的节点，并记录每层的叶子节点数量。
可以看到，时间空间的 trade-off 不仅仅是性能上的提升，也会影响带代码实现的复杂程度。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1005">1005. Spell It Right (20)</a></h2>

<h5>题意</h5>

<p>计算一个数（&lt;=10<sup>100）的各个位数之和，并用英语按位输出。比如</sup> 15 输出为 one five.</p>

<h5>分析</h5>

<p>简单题，输出的实现上实际上就用到了 Hash 思想。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1006">1006. Sign In and Sign Out (25)</a></h2>

<h5>题意</h5>

<p>每个人来到实验室和离开实验室的时间都有记录。找到其中最早来实验室和最晚离开实验室的时间。</p>

<h5>分析</h5>

<p>逻辑上很简单的一个题，遍历所有数据，找到其中最大和最小的值即可。稍微要处理的就是时间。
由于 input 中给出的是 HH:MM:SS 的格式，在比较时需要将其换算为 int 值。实际上，使用 C 语言读入更方便，<code>scanf("%d:%d:%d", &amp;h, &amp;m, &amp;s);</code>
然后计算出<code>time = 3600*h + 60*m + s</code>，时间比较就没有问题了。在最终的输出时再做对应的转换即可。
而在 Java 语言中，使用到了 String 的 split 方法划分子串和 Integer.parseInt()转 String 为 int。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1007">1007. Maximum Subsequence Sum (25)</a></h2>

<h5>题意</h5>

<p>给出一组由正负整数组成的序列，求出拥有最大和的连续子序列。</p>

<h5>分析</h5>

<p>最暴力的算法是两个循环的 O(n<sup>2)；进一步要使用分治的思想，可以得到</sup> O(n*logn)；更好的方法可以达到 O(n)，也可以将它看做分治思想。关键在于数学归纳的证明，编程实现非常简单：假定 [0, n-1]的最大连续子串已经求出了，要求 [0,n]的最大连续子串。</p>

<ul>
<li>1.如果 [0, n-1]中最大子串不包含最右的数字，则判定<code>原最大子串的和</code>与<code>包含最右点的最大子串 + a[n]的和</code>的大小。取大的那个作为 [0, n]的最大子串，并保持一个<code>包含最右点的最大子串</code>。</li>
<li>2.如果 [0, n-1]中最大子串包含最右的数字，则 [0, n]的最大子串为原最大子串+a[n]。</li>
</ul>


<p>实际上，算法的核心是维持了两个量的记录，即当前的<code>最大子串</code>，以及当前<code>包含最右点的最大子串</code>。</p>

<p>更多讨论参见博文<a href="../../../../2013/04/05/maximum-subsequence-sum/">《分治、时间空间的权衡:最大合的连续字串问题 (PAT 1007)
》</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1008">1008. Elevator (20)</a></h2>

<h5>题意</h5>

<p>给出电梯的行进路径，上下的速度和每层停留时间，计算总时间。</p>

<h5>分析</h5>

<p>简单的模拟题。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1009">1009. Product of Polynomials (25)</a></h2>

<h5>题意</h5>

<p>求两个多项式的乘积。</p>

<h5>分析</h5>

<p>参见 PAT1002，使用数组存储虽然空间占用稍大，但比链表实现要便捷很多。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1010">1010. Radix (25)</a></h2>

<h5>题意</h5>

<p>给定两个数，其中单个位置上的数值范围可以为 [0-z]。指定其中一个数的进制，试确定是否存在可能的进制让两数的实际值相等。</p>

<h5>分析</h5>

<p>此题没有交代清楚 input 中 radix 的取值范围以及对一位数有多重可能 radix 的情况如何输出，坑比较大。下面是需要注意的点。</p>

<ul>
<li>1.input 中两个数字可以是 10 位数，虽然没有告诉 radix 的范围，但在<code>9*10^10 10 1 200</code>这个示例中，可以看到结果的 radix 也可以是很大的。从这个角度看，代码中将 radix 和两个数值都设定为 longlong 是合适的选择。</li>
<li>2.在计算另一个数的 radix 时，简单的遍历 [2, 10<sup>18]会超时。单调的区间很自然想到使用二分查找。</sup></li>
<li>3.二分查找的上下界确定能减少耗时：下界选数字的所有位上的最大值+1；上界容易想当然的认为就是题中给定了 radix 的数的值。实际上，示例<code>11 b 1 10</code>就是一个反例，原因在于这个假设忽略了一位数的可能性，解决方案是在取给定 radix 的数值和下界中较大的那个数。</li>
<li>4.在二分查找时，不可直接计算出某个 radix 下数的值，因为可能会 longlong 溢出。于是需要用特定的 compare 函数，在累加的过程中判定是否大于另一个数。算是一种剪枝。</li>
<li>5.还有一个条件：当两个数都是 1 时，输出 2.当两个数相等且不为 1 时，输出题中给出的 radix。（这是从其他人的结题报告中看到的，完全不理解=。=）</li>
</ul>


<p>注意好这些方面，应该能 ac 了。保重。</p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/07/31/pat-1001-1010-solutions/'>http://biaobiaoqi.github.com/blog/2013/07/31/pat-1001-1010-solutions/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[终于算完了这道『1+1』]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/07/29/after-pat-practice/"/>
    <updated>2013-07-29T22:12:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/07/29/after-pat-practice</id>
    <content type="html"><![CDATA[<p>在<a href="http://weibo.com/redow7">@ReDow</a>、<a href="http://weibo.com/cloudbye">@麦迪的小腿</a>和<a href="http://weibo.com/linest">@lines</a> 等小伙伴的帮助下，终于断断续续的爬完了 <a href="http://pat.zju.edu.cn/">PAT</a> 的 Basic Level 和 Advanced Level，阶段性填补了自己惨白的算法短板。在 cs 的圈子里，说 PAT 是入门的『1 + 1』不为过。刚完成『1 + 1』，作为五年科班的人，确实不够光彩。不过现在能做的也只是尽力弥补本科时间里的虚度。</p>

<p>从亲手挖的坑里往外爬，需要付出比其他人更多的努力。没时间享受题目 ac 之后的快感（画外音：这么简单的题会有快感么=.=#），倒会时不时蹦出一股脑的蛋疼：『你当初干 XX 啥去了！』。</p>

<h2>当初&#8230;</h2>

<p>记得大一的时候，每天花好几个小时泡图书馆看各种 IT 杂志和技术书籍。在刚开始学 C 语言编程的时间里，我看着中间件、系统软件、终端融合、东软和用友金蝶之争等一系列摸不着头脑的东西，在对数据还没概念的时候，看着数据库的范式和 E-R 图…总之，就是一直在门外徘徊。</p>

<p>之后专业课多了起来，我又兴高采烈的混在工高大神的队伍里，早上集结同学每天早上五点多轮流爬起来去自习室占座，以看似端正实则不专注的令人发指的学习态度在 GPA 榜单上持续退步着。浑浑噩噩的搞过数模，无果。当然，以『学渣』的水平充着『学霸』也是有好处的，就是沾染了大神的精神气，比如记忆犹新的有在 CMU 念书的鑫磊大神的专注、冷静和每天 4 小时的睡眠。同时，我还风风火火的参加了 ASES 和求是强鹰，搀和着所谓的创业。大四在爱尔兰的交流，除了英语和专业课，其他的倒是学的挺多，比如烧饭，单反和旅游……本科唯一做的跟编程有关的说得出口的，也就写了个 Android 程序在比赛里获了个奖，不提也罢的那种。</p>

<h2>变</h2>

<p>在《<a href="http://book.douban.com/subject/1048007/">高效能认识的七个习惯</a>》里看过一个观点：每个人都有属于自己的『关注圈』和『影响圈』。影响圈是个人对外界产出的途径，关注圈则意味着个人对外界的期许。可以想见，关注圈大于影响圈。正确的成长方式是尽力扩大影响圈，以此催生关注圈的扩大。而我则是走在了相反的方向：一直致力于开发自己的关注圈，后果是影响圈不见长进。一度我开始注意遏制自己这方面的好高骛远，不过事实证明，我还是比较喜欢在学爬得时候看走路的教学视频。</p>

<!--more-->


<p>后来听闻了杨绛先生的一则小事。大概是说，一个年轻人写信给杨绛，说自己平时许多问题想不明白，想请教下怎么应对。杨绛回复说『是你看书太少，想的太多』。第一眼看到这个故事，我的想法就是：那不是在说的我么。对我而言，『书』指的更泛一些，理解为阅历或许更恰当。让可能性禁锢了思想，不值得，不如踏出去，自己去找答案。</p>

<p>研究生的一年又过去，很难说我这一年达到了自己的预期。不过也没怎样，世界变化这么快，也容不得静态的计划。至少，我渐渐的逼近了自己喜欢的生活节奏。</p>

<h2>信仰</h2>

<p>都说现在的国人根子里没有信仰，年岁越长也渐渐有些自己的体会。面对远超过 big-data 量级的选择，我时常彷徨，我不敢说自己有信仰。我只是一直在坚持找寻。</p>

<p>用乔老爷子著名的斯坦福演讲中的一句话结束：</p>

<blockquote><p>You can&#8217;t connect the dots looking forward. You can only connect them looking backwards, so you have to trust that the dots will somehow connect in your future. You have to trust in something&#8211;your gut, destiny, life, karma,whatever&#8211;because believing that the dots will connect down the road will give you the confidence to follow your heart, even when it leads you off the well-worn path, and that will make all the difference.</p></blockquote>

<h3>PS：</h3>

<p>据我所知网上的资料没有对 PAT 题型整体的把握和讲解。接下来的时间，我会整理下自己的代码和解题思路，将整理结果放到博客上来，也算自己的复习。链接都准备好了：<a href="../overcome-pat/">《PAT 综合题解》</a>。如果是 404Error，就请再耐心等待几天吧;)</p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/07/29/after-pat-practice/'>http://biaobiaoqi.github.com/blog/2013/07/29/after-pat-practice/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[阿里离线数据处理平台2013暑期学校]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/07/19/odps-in-alibaba/"/>
    <updated>2013-07-19T21:31:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/07/19/odps-in-alibaba</id>
    <content type="html"><![CDATA[<p>本周有幸参加了为期两天的<a href="http://102.alibaba.com/competition/dataSummer.htm">阿里离线数据处理平台 2013 暑期学校</a>的学习。</p>

<p>阿里的前辈们分不同的专题给大家介绍了飞天平台上的离线数据处理服务 ODPS（Open Data Processing Service）。
内容上主要分为两部分，一部分是平台架构，一部分是数据分析。来听课的同学也就分为了两部分，而像我一样关注系统层面的人是少数。</p>

<p>这也正常，用赵本山在『一代宗师』里的话来说，一个是面子，一个是里子。数据分析能直接产生表现层的数据，而系统平台则只是提供支持。
成功了，大家看得到的是分析出的数据，而一旦失败了，那么系统平台的责任就大了。
再者越贴近硬件层次的工作也注定越辛苦，深夜被吵醒也不是没有的事儿。好了，吐槽到此结束，下面是总结笔记整理出几页 slides：</p>

<script async class="speakerdeck-embed" data-id="e0022eb0d24d013089506e9621fcaf9a" data-ratio="1.33333333333333" src="http://biaobiaoqi.github.com//speakerdeck.com/assets/embed.js"></script>




<!--more-->


<p>ppt 下载链接：<a href="https://speakerdeck.com/biaobiaoqi/odps-learning-summary">请戳我</a></p>

<p>三巨头 BAT 都自主研发过大数据平台，另外两家在投入大量资金后面对困难最终关闭了项目，而阿里坚持了下来。通过了解 ODPS 的系统架构，可以看但工业界的系统和学术圈中提出的概念的差异。这也让我更清晰了之后自己的学习路线。</p>

<p>非常感谢阿里暑期学校给予的这次机会来接触飞天系统，非常感谢各位讲师的介绍，特别是杨少华大哥对我的疑惑的耐心解答。<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/07/19/odps-in-alibaba/'>http://biaobiaoqi.github.com/blog/2013/07/19/odps-in-alibaba/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[出栈序列的可能性判定（PAT1051）]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/07/16/verify-pop-sequence-for-stack/"/>
    <updated>2013-07-16T01:32:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/07/16/verify-pop-sequence-for-stack</id>
    <content type="html"><![CDATA[<h2>问题说明</h2>

<p><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1051">PAT1051</a>：给定 stack 的容量，给定数据的入栈顺序：从 1 开始的正整数序列，在允许随机的出栈操作的情况下，要求判断某出栈序列是否可能。</p>

<p>比如，告知 stack 容量为 5，入栈序列的最大值为 7。有两个序列需要判断合理性：</p>

<ul>
<li><code>1 2 3 4 5 6 7</code>： 这个序列是可能的，只需每次入栈时都做出栈操作。</li>
<li><code>3 2 1 7 5 6 4</code>： 这个序列是不可能的，其中前半部分<code>3 2 1</code>是合法的，先将<code>1 2 3</code>顺序入栈，然后三次执行出栈操作。而之后的<code>7 5 6</code>则是不可能的。</li>
</ul>


<p>要完成判定过程，常规思路是直接使用的 stack 数据结构模拟出栈序列做操作，然后判定是否会触犯条件。但考虑到 PAT1051 中时间限制只有 10ms，虽然常规方法是线性的，似乎也无法保障（事实证明是错误的，用常规方法也能在 PAT 上 AC），我想到从序列本身的特性入手，找规律，于是有了一种效率更高的判定逻辑。</p>

<h2>常规思路</h2>

<p>直接使用出栈序列指导 stack 模拟操作。判定条件有两条：</p>

<ul>
<li>1.栈中数据量不超过栈的容量。</li>
<li>2.出栈只能从栈顶取，不应该出现从固定的堆栈中取出其他数据的情况。</li>
</ul>


<p>算法描述如下：</p>

<p>用游标记录当前已知压栈的最大数据 cur。如果新的读入数据 tmp（即出栈序列中的某数据）大于 cur，则将 cur 到 tmp 之间的数据顺序压入栈中，更新 cur 并执行检查 1；如果新的读入数据 tmp 小于 cur，则一定是直接出栈获得的，执行检查 2。</p>

<p>如果能顺利完成就是合理的，如果操作过程违背了一些规则，则判定为不合理。C++实现代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include&lt;stdio.h&gt;</span>
</span><span class='line'><span class="cp">#include&lt;stack&gt;</span>
</span><span class='line'><span class="k">using</span> <span class="k">namespace</span><span class="o">::</span><span class="n">std</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">cur</span><span class="p">;</span>
</span><span class='line'><span class="kt">bool</span> <span class="n">flag</span><span class="p">;</span>
</span><span class='line'><span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d %d %d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">);</span>
</span><span class='line'>    <span class="k">while</span><span class="p">(</span><span class="n">k</span> <span class="o">--</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">flag</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>        <span class="n">cur</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>        <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;</span> <span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">cur</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">tmp</span><span class="p">;</span> <span class="o">++</span> <span class="n">j</span><span class="p">)</span>
</span><span class='line'>                    <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">)</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>                <span class="n">cur</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">()</span> <span class="o">!=</span> <span class="n">tmp</span><span class="p">)</span>
</span><span class='line'>                    <span class="n">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;YES</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="k">else</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;NO</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>更高效的判定逻辑</h2>

<p>实际上，在 PAT1051 的环境下，由于入栈序列数据由小到大排列非常特殊，要通过出栈序列判定可能性是存在简便思路的。</p>

<p>对比分析题中 Sample 给出的序列，结合上面提到的两条冲突条件入手分析：</p>

<ul>
<li><p>1.栈中数据量不超过栈的容量：</p>

<p>  只有在入栈时，才会需要考虑栈中数据是否超量。出栈序列中的每个数，都以为着在出栈操作之前，它刚入栈，那么当它入栈的时候能否判定是否超过栈容量呢？可以的，（当前的出栈数值 - 已经执行过的出栈操作数量）就是当前栈中元素的数量。</p></li>
</ul>


<!--more-->


<ul>
<li><p>2.出栈只能从栈顶取，不应该出现从固定的堆栈中取出其他数据的情况。</p>

<p>  根据观察分析发现，当某数据 m 出栈之后，比 m 小的数据如果在 m 之后出栈的，它们所组成的序列本身需要保持从大到小的顺序排列。距离如<code>3 2 1 7 5 6 4</code>这个序列，在<code>7</code>之后有<code>5 6 4</code>这个子序列，它们都大于<code>7</code>，但却没有保持一个递减的顺序，不合法。</p></li>
</ul>


<p>C++实现代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include&lt;stdio.h&gt;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">max</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">tmp</span><span class="p">;</span>
</span><span class='line'><span class="kt">bool</span> <span class="n">flag</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d %d %d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">);</span>
</span><span class='line'>    <span class="k">while</span><span class="p">(</span><span class="n">k</span> <span class="o">--</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">flag</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>        <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>        <span class="n">min</span> <span class="o">=</span> <span class="mi">1001</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">-</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">)</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>                <span class="k">else</span> <span class="n">max</span> <span class="o">=</span> <span class="n">min</span><span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span> <span class="n">tmp</span> <span class="o">&gt;</span> <span class="n">min</span><span class="p">)</span> <span class="n">flag</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>                <span class="k">else</span> <span class="n">min</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;YES</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="k">else</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;NO</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>总结</h2>

<p>在我的理解之中，经典的算法、数据结构是在面对编程问题的解决过程中所抽象出的通用模型。而生活是多变的，并不像考试卷一样简单的套用数学题所能解决，很多情况下，编程问题也是如此。那么除了这些经典的方法外，认真分析条件，并进行针对性的优化甚至重新设计就非常重要了。这里仅仅是一个小实践。</p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/07/16/verify-pop-sequence-for-stack/'>http://biaobiaoqi.github.com/blog/2013/07/16/verify-pop-sequence-for-stack/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给博客签上CC协议]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/07/10/cc-license/"/>
    <updated>2013-07-10T22:37:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/07/10/cc-license</id>
    <content type="html"><![CDATA[<p>大家都知道开源软件。通过开放源代码的方式，允许用户学习、修改、增进提高这些软件质量。软件界的开源协议很多，比如常见的 Apache，BSD，GPL 等等。这是一种充分利用网络的便利性，鼓励分享和创新的协议潮流。从这个层面上来说，Creative Commons 也是如此。</p>

<p>这是一个非营利性组织，也是一种创作的授权方式。简称 CC 协议，中国大陆正式名称为知识共享。次组织的主要宗旨是增加创意作品的流通可及性，作为其他人据以创作及共享的基础，并寻找适当的法律以确保上述理念。</p>

<h2>CC 协议的起源</h2>

<p>Creative Commons 最先是 2002 年的 12 月 16 号在美国首次发布的。这个协议最初是根据美国版权法设计出来的。技术的发展，网络的发展，出现了开放共享的需求，而传统的作品保护的模式，对作品的使用和内容的开放带来一些限制。怎么样满足这种需求，同时又尊重权利人的著作权？传统的保护模式不能实现这样的作用，它可能关注于保护的时候可能忽略了对公众的，尤其网络环境下对知识文化这样分享的需求。CC 协议的设计实际上是基于这样一种大的背景，在这样一个大的网络环境下应运而生，它是来倡导一种合法的分享。</p>

<h2>CC 协议内容</h2>

<p>CC 协议可以分为四个部分。每个部分对使用者有不同程度的限定。</p>

<ul>
<li><p>1.署名（BY）：作品上必须附有作品的归属。如此之后，作品可以被修改，分发，复制和其它用途。</p></li>
<li><p>2.非商业性使用（NC）：作品可以被修改、分发等等，但不能用于商业目的。</p></li>
<li><p>3.禁止演绎（ND）：这意味着你可以复制和分发它们，但你不能以任何方式修改它们，或基于它们进行二次创作。</p></li>
<li><p>4.相同方式共享（SA）：作品可以被修改、分发或其它操作，但所有的衍生品都要置于 CC 许可协议下。</p></li>
</ul>


<p>实际使用时，需要对这四种条件分别作出约束。不同的条件共有 16 种组合方式，其中有的组合方式互斥，简化后剩下了 6 种常用协议：</p>

<h5>署名（BY）</h5>

<p>此协议最为宽松，只需署名，其他无约束。</p>

<h5>署名（BY）-禁止演绎（ND）</h5>

<p>署名的同时，不得对作品进行改动。但可以用于商业或非商业用途。</p>

<h5>署名（BY）-非商业性使用（NC）</h5>

<p>署名的同时，可以修改作品，但不能用于商业用途。</p>

<h5>署名（BY）-非商业性使用（NC）-禁止演绎（ND）</h5>

<p>署名，且不得用于商业用途和修改。</p>

<h5>署名（BY）-非商业性使用（NC）-相同方式共享（SA）</h5>

<p>署名，不能商用，但可以演绎，且演绎后的内容必须是同样的共享方式。</p>

<h5>署名（BY）-相同方式共享（SA）</h5>

<p>署名，可以商用，可以演绎，但演绎后的作品必须是同样的共享方式。</p>

<!--more-->


<h2>国内的现状</h2>

<p>昨天，为了防止其他网站的不经允许无署名的转载行为，我刚给所有的文章末尾添加了原文链接信息。</p>

<p>实际上，在中国，这种侵犯著作权的行为非常泛滥。有的网站，甚至就致力于爬其他社区产生的优质数据，并直接复制到自己的网页上，以图在网络世界中获得更高的收益。在大数据的时代，越来越多的数据会在网络上产生，会很容易的在网络间流动。这种侵犯著作权的行为将破坏整个互联网信息流动的环境，阻碍社会进步。原有的著作权管理法定条纹相对守旧，面对互联网环境，本身也是水土不服的。CC 协议的重要性不言而喻。</p>

<h2>博客的实践</h2>

<p>我想在我的博客中采纳 BY-NC-ND 协议。其对应的许可协议网络版链接如下：<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh</a></p>

<p>只需要在在<a href="http://biaobiaoqi.github.com/blog/2013/07/10/decorate-octopress/">昨天的修改</a>基础上，替换 html 内容，即可得到一个签署了 BY-NC-ND 协议的展示结果。具体需修改<code>octopress/plugins/post_footer_filter.rb</code>文件：</p>

<p>1.在文件头加上 utf-8 编码标记，以支持中文。</p>

<p>2.搜索定位到<code>post.content + %Q</code>一行，将内容修改为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">post</span><span class="o">.</span><span class="n">content</span> <span class="o">+</span> <span class="sx">%Q[&lt;p class=&#39;post-footer&#39;&gt;&amp;nbsp;</span><span class="si">#{</span><span class="n">pre</span> <span class="ow">or</span> <span class="s2">&quot;原文地址：&quot;</span><span class="si">}</span><span class="sx">&lt;a href=&#39;</span><span class="si">#{</span><span class="n">post</span><span class="o">.</span><span class="n">full_url</span><span class="si">}</span><span class="sx">&#39;&gt;</span><span class="si">#{</span><span class="n">post</span><span class="o">.</span><span class="n">full_url</span><span class="si">}</span><span class="sx">&lt;/a&gt;&lt;br/&gt;&amp;nbsp;版权声明：自由转载-非商用-非衍生-保持署名| &lt;a href=&#39;http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh&#39;&gt;Creative Commons BY-NC-ND 3.0&lt;/a&gt;&lt;/p&gt;]</span>
</span></code></pre></td></tr></table></div></figure>


<h3>参考</h3>

<ul>
<li><a href="http://zh.wikipedia.org/zh-cn/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6">开源软件 wiki</a></li>
<li><a href="http://www.awflasher.com/blog/archives/939">五种开源协议的比较(BSD,Apache,GPL,LGPL,MIT) – 整理</a></li>
<li><a href="http://www.baike.com/wiki/CC%E5%8D%8F%E8%AE%AE">CC 协议互动百科</a></li>
<li><a href="http://creativecommons.net.cn/2009/11/30/prof-wang-interview-at-hudong/">王春燕教授做客互动百科谈 CC</a></li>
<li><a href="http://www.aqee.net/a-short-guide-to-open-source-and-similar-licenses/">开源软件许可协议简介</a></li>
</ul>


<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/07/10/cc-license/'>http://biaobiaoqi.github.com/blog/2013/07/10/cc-license/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[定制Octopress]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/07/10/decorate-octopress/"/>
    <updated>2013-07-10T01:53:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/07/10/decorate-octopress</id>
    <content type="html"><![CDATA[<p>在 github pages 上搭建好 octopress 博客之后，博客的基本功能就能使用了。如果想自己定制也是没问题的，octopress 有较详尽的官方文档，原则上有问题求助官方即可：<a href="http://octopress.org/help/">octopress-help</a>。官方没有包纳的也可以去询问 <a href="http://stackoverflow.com/questions/tagged/octopress">stackoverflow</a>。 当然，中文的看起来总会省事儿点。我做了如下一些总结;)</p>

<p>不会 ruby 的童鞋特别注意：配置_ config.yml 的过程中特别注意，配置项『:』后要留空格，否则会报错。</p>

<h2>1.装饰边栏</h2>

<p>以增加豆瓣展示框为例。参加正反反长大哥的博客 <a href="http://icodeit.org/2012/10/how-to-embed-douban-show-in-your-octopress-site/">How to Embed Douban-Show in Your Octopress Site</a></p>

<h2>2.增加国内的第三方评论</h2>

<p>虽然 octopress 内置的评论系统也很不错，但国内的第三方评论更接地气，将微博、人人等各方 SNS 都纳入旗下。比较出名的有友言、多说。</p>

<p>这里以唐巧大哥的博文<a href="http://blog.devtang.com/blog/2012/02/10/setup-blog-based-on-github/">《象写程序一样写博客：搭建基于 github 的博客》</a>为例，他使用的是友言。</p>

<h2>3.定制域名</h2>

<p>如果你拥有自己的域名，可以 CNAME 到 github pages 上。以我的配置为例（我的域名为<code>biaobiaoqi.me</code>）。</p>

<p>1.在 octopress 的 source 目录下创建 CNAME 文件，并输入新域名：biaobiaoqi.com</p>

<p>2.在域名管理中，创建或修改 A 记录，指向 207.97.227.245 这个地址。</p>

<p>3.创建 CNAME 记录，www.biaobiaoqi.com -> biaobiaoqi.github.com</p>

<p>这一过程可能需要好几天才能生效，请耐心等待:)</p>

<h2>4.让博客中连接在新窗口打开</h2>

<p>由于 markdown 不支持这一语法，如果要自己用 html 标签实现，又有些违背了 markdown 以内容为重的立意。</p>

<p>参考博文<a href="http://www.blogjava.net/lishunli/archive/2013/01/20/394478.html">《在 Octopress 中为 markdown 的超链接加上 target=&#8221;_blank&#8221;》</a>，可以通过将如下代码添加到 {OCTOPRESS_HOME}/source/_includes/custom/head.html 文件末尾来实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="o">&lt;</span><span class="nx">script</span> <span class="nx">type</span><span class="o">=</span><span class="s2">&quot;text/javascript&quot;</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kd">function</span> <span class="nx">addBlankTargetForLinks</span> <span class="p">()</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;a[href^=&quot;http&quot;]&#39;</span><span class="p">).</span><span class="nx">each</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
</span><span class='line'>
</span><span class='line'>      <span class="nx">$</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nx">attr</span><span class="p">(</span><span class="s1">&#39;target&#39;</span><span class="p">,</span> <span class="s1">&#39;_blank&#39;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="nx">$</span><span class="p">(</span><span class="nb">document</span><span class="p">).</span><span class="nx">bind</span><span class="p">(</span><span class="s1">&#39;DOMNodeInserted&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="nx">addBlankTargetForLinks</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="err">/script&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>5.列表的排版</h2>

<p>默认情况，所有文字的排头会对齐，但如果有列表项的情况下也如此，列表头就会冲出文章的主体区块了。</p>

<p>在 octopress/sass/custom/_layout.scss 文件中找到#$indented-lists: true 行，去掉#注释即可。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">$indented</span><span class="o">-</span><span class="nx">lists</span><span class="o">:</span> <span class="kc">true</span>
</span></code></pre></td></tr></table></div></figure>




<!--more-->


<h2>6.404ERROR 页面</h2>

<p>在 ocotopress/source 目录下，增加 404.markdown，并做出自定义的呃编辑。本博客使用了腾讯公益 404，推荐大家使用，为社会贡献一分正能量。<a href="http://www.qq.com/404/">公益 404</a></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="o">---</span>
</span><span class='line'>
</span><span class='line'><span class="nx">layout</span><span class="o">:</span> <span class="nx">page</span>
</span><span class='line'>
</span><span class='line'><span class="nx">title</span><span class="o">:</span> <span class="s2">&quot;404 Error&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="nx">date</span><span class="o">:</span> <span class="mi">2013</span><span class="o">-</span><span class="mi">4</span><span class="o">-</span><span class="mi">21</span> <span class="mi">02</span><span class="o">:</span><span class="mi">35</span>
</span><span class='line'>
</span><span class='line'><span class="nx">comments</span><span class="o">:</span> <span class="kc">false</span>
</span><span class='line'>
</span><span class='line'><span class="nx">sharing</span><span class="o">:</span> <span class="kc">false</span>
</span><span class='line'>
</span><span class='line'><span class="nx">footer</span><span class="o">:</span> <span class="kc">false</span>
</span><span class='line'>
</span><span class='line'><span class="o">---</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">script</span> <span class="nx">type</span><span class="o">=</span><span class="s2">&quot;text/javascript&quot;</span> <span class="nx">src</span><span class="o">=</span><span class="s2">&quot;http://www.qq.com/404/search_children.js&quot;</span> <span class="nx">charset</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="o">&gt;&lt;</span><span class="err">/script&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>7.在侧边栏增加标签云(tag cloud)</h2>

<p>octopress 默认只有分类，没有标签。这对于博文的组织和管理很不友好。有人开源出了自己定制的 tag 生成和 tag cloud 展现的代码，可以引入到自己的博客中来。</p>

<p>详细操作参见博文：<a href="http://codemacro.com/2012/07/18/add-tag-to-octopress/">《为 octopress 添加 tag Cloud》</a>。不过博文中没有讲解标签云的 UI 配置参数的使用，为了让 UI 适应页面，请参考原作者的官方说明:<a href="https://github.com/robbyedwards/octopress-tag-cloud">octopress-tag-cloud</a>。我所实践出的较合理的参数值如下</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1">#注意，下面一行的 escape 反斜杠在正常使用时需要去掉</span>
</span><span class='line'><span class="p">\{\</span><span class="o">%</span> <span class="n">tag_cloud</span> <span class="n">font</span><span class="o">-</span><span class="ss">size</span><span class="p">:</span> <span class="mi">70</span><span class="o">-</span><span class="mi">180</span><span class="sx">%, limit: 15,</span> <span class="ss">order</span><span class="p">:</span> <span class="nb">rand</span><span class="p">,</span> <span class="ss">style</span><span class="p">:</span> <span class="n">para</span>  <span class="p">{</span> <span class="o">&amp;</span><span class="n">nbsp</span> <span class="p">}\</span><span class="o">%</span><span class="p">\}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果想将文章分类（category）也放在侧边栏，可以参考这篇博文：<a href="http://paz.am/blog/blog/2012/06/25/octopress-category-list-plugin/">《Octopress - Category List Plug-in》</a></p>

<h2>8.在顶栏增加标签云页面 tab</h2>

<p>1.生成新网页</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">rake</span> <span class="n">new_page</span><span class="o">[</span><span class="s2">&quot;tag-cloud&quot;</span><span class="o">]</span> <span class="c1">#在 octopress/source/中将生成 tag-cloud/文件夹</span>
</span></code></pre></td></tr></table></div></figure>


<p>2.在顶栏增加新页面</p>

<p>修改<code>source/_includes/custom/navigation.html</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">&lt;</span><span class="n">ul</span> <span class="n">class</span><span class="o">=</span><span class="s2">&quot;main-navigation&quot;</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s2">&quot;/&quot;</span><span class="o">&gt;</span><span class="err">首页</span><span class="o">&lt;</span><span class="sr">/a&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s2">&quot;/blog/categories/tech/&quot;</span><span class="o">&gt;</span><span class="err">技术</span><span class="o">&lt;</span><span class="sr">/a&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s2">&quot;/blog/categories/life/&quot;</span><span class="o">&gt;</span><span class="err">生活</span><span class="o">&lt;</span><span class="sr">/a&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s2">&quot;/blog/categories/book/&quot;</span><span class="o">&gt;</span><span class="err">读书</span><span class="o">&lt;</span><span class="sr">/a&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s2">&quot;/tag-cloud/&quot;</span><span class="o">&gt;</span><span class="err">标签云</span><span class="o">&lt;</span><span class="sr">/a&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s2">&quot;/about&quot;</span><span class="o">&gt;</span><span class="err">关于</span><span class="o">&lt;</span><span class="sr">/a&gt;&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="sr">/ul&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>在需要的位置增加<code>&lt;li&gt;&lt;a href="http://biaobiaoqi.github.com/tag-cloud/"&gt;标签云&lt;/a&gt;&lt;/li&gt;</code>。如此一来，可以在网页顶栏看到『标签云』一栏了。不过此时，点击进入，页面为空。</p>

<p>3.修改标签云页面内容。</p>

<p>修改<code>octopress/source/tag-cloud/index.markdown</code>，增加标签云执行脚本。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">---</span>
</span><span class='line'><span class="ss">layout</span><span class="p">:</span> <span class="n">page</span>
</span><span class='line'><span class="ss">title</span><span class="p">:</span> <span class="s2">&quot;标签云&quot;</span>
</span><span class='line'><span class="ss">date</span><span class="p">:</span> <span class="mi">2013</span><span class="o">-</span><span class="mo">07</span><span class="o">-</span><span class="mi">10</span> <span class="mo">02</span><span class="p">:</span><span class="mi">53</span>
</span><span class='line'><span class="ss">comments</span><span class="p">:</span> <span class="kp">true</span>
</span><span class='line'><span class="ss">sharing</span><span class="p">:</span> <span class="kp">true</span>
</span><span class='line'><span class="ss">footer</span><span class="p">:</span> <span class="kp">true</span>
</span><span class='line'><span class="o">---</span>
</span><span class='line'>
</span><span class='line'><span class="c1">#注意，代码中的 escape 反斜杠在正常使用时需要去掉</span>
</span><span class='line'><span class="c1">#另外，这几个语句不能使用换行。在我的测试环境下，使用换行后，最终的页面上对换行进行了错误的解码，给增加了一个&lt;code&gt;标签，造成了错误的显示。</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">ul</span> <span class="n">class</span><span class="o">=</span><span class="s2">&quot;tag-cloud&quot;</span><span class="o">&gt;</span><span class="p">\{\</span><span class="o">%</span> <span class="n">tag_cloud</span> <span class="n">font</span><span class="o">-</span><span class="ss">size</span><span class="p">:</span> <span class="mi">90</span><span class="o">-</span><span class="mi">210</span><span class="sx">%, limit: 1000,</span> <span class="ss">style</span><span class="p">:</span> <span class="n">para</span> <span class="p">\</span><span class="o">%</span><span class="p">\}</span><span class="o">&lt;</span><span class="sr">/ul&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>9.博客末尾增加原文链接、版权等</h2>

<p>最近发现有其他小网站未经授权直接 copy 我的博客内容，在违章的末尾加上版权、原文链接变得很有必要了。</p>

<p>详情参见博客<a href="http://codemacro.com/2012/07/26/post-footer-plugin-for-octopress/">《为 octopress 每篇文章添加一个文章信息》</a>。</p>

<p>值得注意的是，插件代码中如下几行需要去掉缩进和换行符。原因跟第 8 节所讲一样，换行符引起了错误的解码，造成了错误的显示。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">post</span><span class="o">.</span><span class="n">content</span> <span class="o">+</span> <span class="sx">%Q[&lt;p class=&#39;post-footer&#39;&gt;</span>
</span><span class='line'><span class="sx">            </span><span class="si">#{</span><span class="n">pre</span> <span class="ow">or</span> <span class="s2">&quot;original link:&quot;</span><span class="si">}</span><span class="sx"></span>
</span><span class='line'><span class="sx">            &lt;a href=&#39;</span><span class="si">#{</span><span class="n">post</span><span class="o">.</span><span class="n">full_url</span><span class="si">}</span><span class="sx">&#39;&gt;</span><span class="si">#{</span><span class="n">post</span><span class="o">.</span><span class="n">full_url</span><span class="si">}</span><span class="sx">&lt;/a&gt;&lt;br/&gt;</span>
</span><span class='line'><span class="sx">            &amp;nbsp;written by &lt;a href=&#39;</span><span class="si">#{</span><span class="n">url</span><span class="si">}</span><span class="sx">&#39;&gt;</span><span class="si">#{</span><span class="n">author</span><span class="si">}</span><span class="sx">&lt;/a&gt;</span>
</span><span class='line'><span class="sx">            &amp;nbsp;posted at &lt;a href=&#39;</span><span class="si">#{</span><span class="n">url</span><span class="si">}</span><span class="sx">&#39;&gt;</span><span class="si">#{</span><span class="n">url</span><span class="si">}</span><span class="sx">&lt;/a&gt;</span>
</span><span class='line'><span class="sx">            &lt;/p&gt;]</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后，kevin 没有提及的是，为了做好美化，还需要增加一段针这块区域的 css：</p>

<p>编辑<code>sass/custom/_style.scss</code>，在末尾增加如下内容：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nc">.post-footer</span><span class="p">{</span><span class="k">margin-top</span><span class="o">:</span><span class="m">10px</span><span class="p">;</span><span class="k">padding</span><span class="o">:</span><span class="m">5px</span><span class="p">;</span><span class="k">background</span><span class="o">:</span><span class="k">none</span> <span class="k">repeat</span> <span class="k">scroll</span> <span class="m">0pt</span> <span class="m">0pt</span> <span class="m">#eee</span><span class="p">;</span><span class="k">font-size</span><span class="o">:</span><span class="m">90</span><span class="o">%</span><span class="p">;</span><span class="k">color</span><span class="o">:</span><span class="nb">gray</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样，原文链接和版权信息就能很好的和正文内容分离开了。</p>

<h2>10.给中英文之间加空格</h2>

<p>参见博文<a href="http://xoyo.name/2012/04/auto-spacing-for-octopress/">《给中英文间加个空格》</a>。</p>

<p>特别注意 ruby 文件的编码：复制博文中的代码时，需要去掉前几行的描述性注释，让<code>#encoding:UTF-8</code>语句暴露在.rb 文件的第一句。否则，<code>rake generate</code>时，会报错无法识别<code>\p{Han}</code>。</p>

<h2>Tips</h2>

<p>既然是个博客站点，就算是 web 产品啦，可以考虑下 SEO。推荐博文<a href="http://codemacro.com/2012/09/06/octopress-seo/">《Octopress 中的 SEO》</a><p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/07/10/decorate-octopress/'>http://biaobiaoqi.github.com/blog/2013/07/10/decorate-octopress/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《俞敏洪口述》]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/07/07/yuminhong/"/>
    <updated>2013-07-07T23:53:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/07/07/yuminhong</id>
    <content type="html"><![CDATA[<h2>质朴、诚恳和坚韧</h2>

<p>这本书是某次在 Amazon 上购书『满 100 送书一本』时挑的。放在抽屉里有段日子了。</p>

<p>一直挺崇拜俞敏洪老师。初次了解到他是高中的时候看的『赢在中国』，俞敏洪老师是嘉宾点评。而后混在考 T 的大流中去上了新东方的课程，几个老师讲得不错，比较可惜的是远离了老俞的时代。恰好前两天热映的『中国合伙人』，又把他拉回视野前沿。周日，趁着没心情码代码，忙里偷闲的读完了这本自传体的文字。</p>

<p>我不太喜欢读『活人』的传记。没有盖棺定论的事儿，或多或少掺杂些美华。但读这本书，却丝毫没有表现出浮夸，就像他的性格一般质朴、诚恳和坚韧。</p>

<p>或许在某些名人的传记里，永远不会看到他通过喝酒打通关系搞定了某个问题，而老俞有。书里多次的描述了他是怎样融入了这个『人情社会』。不可否认，他的本分和待人诚恳让他有人缘，这是他的优势。</p>

<p>他能在面对东方学校过河拆桥的举动下，沉住气，以和为贵，用合理的手段占据主动。</p>

<p>他能在北大读本科的阶段受众人嘲讽的环境下成长，不断学习，在毕业时，喊出『你们干十年成的我干二十年，你们二十年成的我干四十年。如果实在不行，我会保持心情愉快、身体健康，到八十岁以后把你们送走了我再走』。</p>

<p>凡此种种……</p>

<h2>世界观</h2>

<p>从每个成功的人的经历中，都能总结出数不清的箴言。成功的理由永远说不完。而这本书里，对我而言感触最深的无非是下面这些话：</p>

<blockquote><p>人生就是这样，你不受这个苦就会受那个苦。一个人如果从苦中能找到乐和幸福，那他就是幸运的。……我深刻的意识到什么也不做的痛苦比任何其他痛苦更加深刻，所以我一定要做事，做事的标准就是必须做对社会有好处的事情，以最大的努力在痛苦的世界中尽力而为。</p></blockquote>

<p>对我而言，这句话实在受用。我无法证明这些字在未来的时间里能对我造成的影响，却打在我最近几年来受困扰最多的点上。</p>

<p>乐观让人笑着面对生活。生活总归是有各种委屈、各种阻力，笑脸的背后，时常是受伤的心，区别在于受伤的心能埋得多深。我宁愿相信，乐观是因为能接受苦，能从苦中找到快乐，而不是没有苦。</p>

<p>时常的，我被不好的状态左右。那是种很奇怪的感觉，是面对压力的逃避、拖延，独自缩在没有人看得见的角落，在电脑屏幕前刷着网页，时间慢慢流走。然后心情越来越差，因为一事无成的颓废感。我是闲不下来的人。是的，『什么也不做的痛苦，比任何其他痛苦更加深刻』！</p>

<p>曾经在 ASES 的分享会上，听 dd 讲起过<a href="http://cuitianyi.com/blog/authentic-happiness-%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/">『积极心理学』</a>。其中有个观点是：『享乐是心灵资本的消费，而心流中的满足则是心灵资本的投资』。简单的讲，创造价值的事情会让我得到心流的满足，而简单的娱乐则会消费这种满足感。或许当两者之差为负的时候，我就感受到了那种空虚和煎熬，不止什么都不做，还消费了更多。</p>

<p>正是对社会责任的追求，老俞没有沉浸再新东方的飞速发展中。对他而言，现在的新东方的经营一切都要权衡公司的利益和教育理念。虽然他的新东方充满了实用主义和人文情怀，虽然他能让新东方尽到企业的社会责任，但这依然不是他想要的。他正在筹划办私立高校，用他的教育理念，给中国的教育发展贡献力量。这是中国的希望。</p>

<p>最后，以老俞的一句话结尾：</p>

<blockquote><p>人生的苦难肯定是没有尽头的，人要做的是在苦难中奋发起来，做自己能够做的和应该做的事儿，这就是我的世界观。</p></blockquote>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/07/07/yuminhong/'>http://biaobiaoqi.github.com/blog/2013/07/07/yuminhong/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《清单革命》]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/07/05/checklist-manifesto/"/>
    <updated>2013-07-05T00:54:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/07/05/checklist-manifesto</id>
    <content type="html"><![CDATA[<h2>应该叫『清单宣言』</h2>

<p>在 Amazon 上『满 100 送一本』的活动中随手挑到了它。鉴于其空洞的标题，被束之高阁半年多，最近关注个人管理方面的知识，才拍拍灰尘读起来。</p>

<p>书的英文原名是『The Checklist Manifesto: How to Get Things Right』，直译成『清单宣言』在我看来更贴切，而非充满噱头的『清单革命』。正如一个小功能难以做成独立的产品，一个方法改进也难以成就革命。『清单能大大的改善效率，降低失败概率』这一观点，在医生出生的作者手中翻来覆去的被各种事例证明着，案例的行业背景从医学到建筑，到航天，再到投资，实在乏味。当然，这不妨碍『清单』这一工具对生活工作的助力所带给我们的思考。</p>

<h2>三类问题</h2>

<p>清单作为处理问题的工具，需要从问题的分类谈起。问题大致可分为三类：简单问题、复杂问题和极端复杂的问题。</p>

<ul>
<li>简单问题，诸如洪培蛋糕，只需要知道流程，就可以独立完成，没有复杂的过程和细节。</li>
<li>复杂问题，比如火箭发射升空。通过耐心分解，复杂问题能划分成很多的简单问题，进而得到解决。这时候，需要借助集体的力量。</li>
<li>极端复杂的问题，比如子女的抚养。问题的领域极其宽广和复杂，充满了不确定性，理性的分析难以完全掌控。</li>
</ul>


<p>这三种类型的问题由简单到复杂的梯度递增。</p>

<h2>实践经验：清单</h2>

<p>实践领域的失败分为两种，一种是无知之错，俗话说得好，『不知者无罪』；另一种是无能之错，即按照知识储备，完全能成功解决问题，最终却因为各种原因失败了。随着社会的发展，后者的出现频率越来越高。造成这一现象的原因容易理解，社会复杂度越来越高，各种问题的实施难度加大，远超过个人能力的范围了。这个时候『清单』的重要性凸显了出来。</p>

<p>人脑有一个认知防护网，体现在如下认知缺陷上：</p>

<ul>
<li>记忆不完整</li>
<li>注意力不集中</li>
<li>惰性思维</li>
</ul>


<p>清单能帮助人处理问题：</p>

<ul>
<li>重压之下，人脑容易忽视某些细节。</li>
<li>人脑对于熟知的事实，思考时容易跳过一些事项。</li>
</ul>


<p>使用清单时，特别注意需要保证清单的简单、可测、高效。清单是给人用的，基于人脑局限性，复杂和模糊的认知难以帮助事情的发展。</p>

<blockquote><p>清单需要简单、可测、高效</p></blockquote>

<p>当然，清单也有显而易见的缺点：死板。它是一张纸条上的几行文字，不会知道水的冷暖。那么，当意外发生，需要应变的就是执行者本人。生活中，事物总是充满着变化，清单的控制也需要注意及时的应变。</p>

<blockquote><p>制定清单、执行清单的过程，也需要灵活应变。</p></blockquote>

<h2>用清单处理问题</h2>

<ul>
<li>简单问题： 简单的问题可以通过清单提高效率和成功率。</li>
<li>复杂问题： 可以拆分为许多的简单问题，分由多人管理和复杂，再辅以清单解决。另外，需要注意人与人之间沟通，这能降低出错的可能性，提高个人效率。</li>
<li>极端复杂的问题：更多的需要不断的试错、调整。</li>
</ul>


<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/07/05/checklist-manifesto/'>http://biaobiaoqi.github.com/blog/2013/07/05/checklist-manifesto/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给女朋友的礼物]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/06/11/gift-to-girl-friend/"/>
    <updated>2013-06-11T17:12:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/06/11/gift-to-girl-friend</id>
    <content type="html"><![CDATA[<h2>背景</h2>

<p>一个月前发现了 <a href="http://v2ex.com">V2EX</a> 这个网站，用创始人 <a href="http://www.v2ex.com/member/Livid">Livid</a> 的话来说，『这是一个主要关于做事儿的地方』。确实如此，我在这里收获了很多想法和灵感。</p>

<p>本文所记的，也是得益于某天的对<a href="http://www.v2ex.com/t/69145">某个主题</a>的浏览。帖子中，大家分享了很多给女朋友做的网页，说『技术宅改变世界』太过了，但拥有这样一个礼物，确实是一种属于程序员的快乐和程序员的女友的幸福。</p>

<p>快到我跟我妹子恋爱四周年的日子了，也正逢她本科毕业，无论如何都是个有趣的时间点。受了那个帖子的刺激，我也筹划着给女朋友做一个小网页，以示纪念。</p>

<p>遗憾的是，我自己从来没有写过网页，javascript 和 css 只知道概念，html 也只是知道一些简单的标签，这些可是完成一个小网页所必备的技能呢。技术能力直接阻碍了创造性成果出现的可能:(。于是，解决方案只能是搜集开源代码，然后自己做定制了。实际上，最后的产出，也就是三份代码的拼接。</p>

<h2>资料搜集</h2>

<p>通过各方搜寻，我找到了如下几个网页：</p>

<ul>
<li>1.<a href="http://love.hackerzhou.me/">复旦的学长 hackzhou 的爱心动画</a>，<a href="https://github.com/hackerzhou/Love">github 托管代码</a>。</li>
</ul>


<p>网页用到了 html5 的一些特性实现了动态的心形花的绘制和类似程序代码敲击的文字呈现形式。由于内容仅仅是文字的，可定制性强。如下图：
<img src="https://dl.dropboxusercontent.com/u/64021093/Pics/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202013-06-11%20%E4%B8%8B%E5%8D%888.12.01.png" title="hackerzhou's page" alt="hackerzhou's love project" /></p>

<ul>
<li>2.<a href="http://carfieldloverita.sinaapp.com/">一对异国情侣的 Google 地图应用</a>，<a href="https://github.com/wong2/lovegift">github 托管代码</a>。</li>
</ul>


<p>网页调用了 Google 地图的 API，可以定义聚焦的地理位置和坐标尺，显示照片，像日记一样记录了点点滴滴，有背景音乐。最后还以地点输入框的形式做了表白。很有创意！
<img src="https://dl.dropboxusercontent.com/u/64021093/Pics/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202013-06-11%20%E4%B8%8B%E5%8D%888.12.18.png" title="Googlemap app" alt="Google map app" /></p>

<ul>
<li>3.<a href="http://liumeijun.com/">v2ex 上某童鞋基于百度地图的应用</a>。</li>
</ul>


<p>跟 2 类似，调用了百度 API，配上『Lemon tree』的背景音乐，很有调调！
<img src="https://dl.dropboxusercontent.com/u/64021093/Pics/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202013-06-11%20%E4%B8%8B%E5%8D%888.16.00.png" title="baidumap app" alt="baidumap app" /></p>

<h2>定制计划</h2>

<p>限于没有前端的基础，开发效率会很低，只能硬顶着拿着前面的三个项目做混搭了。其中项目 1 和 2 都有在 github 上开源代码，而 3 则在 v2ex 的帖子里被作者授权直接查源码使用了。</p>

<p>我做了简单的混搭修改计划：</p>

<ul>
<li>1.以 hackzhou 的项目为基础，修改文字内容和基本布局。</li>
<li>2.添加加载等待过程，加载背景音乐。</li>
<li>3.加载完成后，出现开始按钮，按开始按钮播放背景音乐，进入动画效果。</li>
<li>4.增加全屏效果。</li>
</ul>


<h2>实施</h2>

<h5>1.项目启动</h5>

<p>我在 github 上 fork 了 <a href="https://github.com/hackerzhou/Love">hackerzhou 的代码</a>。(<a href="https://github.com/biaobiaoqi/Love">我 fork 的版本</a>)</p>

<p>clone 到本地，尝试阅读 js 代码，尝试做小改动，找到动画开始的调用。</p>

<h5>2.尝试添加背景音乐</h5>

<p>网上查资料，找到了<code>&lt;embeded&gt;</code>可以用来添加背景音乐，测试成功。但这个音乐播放无法支持同步的加载，不可控，在网络环境差的情况下，如果没有配乐动画过程会缺少表现力。放弃这种方案。</p>

<p>在 <a href="http://liumeijun.com/">v2ex 上某童鞋基于百度地图的应用</a>源码中找到了一个第三方音乐播放库：<a href="http://www.schillmania.com/projects/soundmanager2/">soundmanager2</a>。查看官方文档，确认能满足项目需求，于是加入到代码中。</p>

<p>为了让页面展现更加顺畅，需要音乐文件越小越好。我尝试了 MIDI 格式，但是很多浏览器并不支持，作罢。而 soundmanager 似乎对 wma 的支持有问题，于是只剩下 mp3 文件。我选择了 JJ 的『小酒窝』做背景音乐，在 mac 下使用 ocenaudio 将原来 3MB 的 mp3 文件截取了前一半，并导出为不同设定采样率的版本，经过测试，发现 56kb 采样率下，音质没有受到大的影响，且大小也足够小了，于是确定用这种格式的 mp3。最终 MP3 文件的大小为 500KB！</p>

<h5>3.加载逻辑和开始按键</h5>

<p>需求：加载过程需要隐藏前景内容，在音乐加载完成后，显示开始按钮，开始按钮能触发动画效果。</p>

<p>通过 Google 找到了使用 js 隐藏和显示内容的方式</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>document.getElementById('hint').style.display = "none"; //hide hint
</span><span class='line'>document.getElementById('start_btn').style.display = ""; //show start button</span></code></pre></td></tr></table></div></figure>


<p>虽然不是特别理解 js 引擎的单线程运作机制，但经过简单的试错、调试后，就完成了加载等待和开始按钮触发的原型。</p>

<p>之后是对按钮和加载提示配置 css。由于懒得理解 css 的一些细节，直接使用了<a href="https://github.com/wong2/lovegift">这份项目</a>中的 css 代码。</p>

<h5>4.部署</h5>

<p>github 为每个项目提供了静态网页展示的功能，应付这个项目的网页展示完全够了。具体操作流程参见<a href="http://www.worldhello.net/gotgithub/03-project-hosting/050-homepage.html#project-homepage">《GotGithub》3.5.2. 创建项目主页</a>。实际上，链接中介绍的几种创造干净的 gh-pages 分支的方法，在这个项目的发布里是不必的。因为项目主页的展示代码跟 master 分支里的代码本身就是一样的，那么需要做的就只是开启 gh-pages 分支，并提交代码了。</p>

<p>项目成果：<a href="http://biaobiaoqi.me/Love">请戳这里</a></p>

<h2>结语</h2>

<p>感谢 v2ex，感谢 hackerzhou、loo2k 和 wong2 童鞋，我参考了你们很多代码。</p>

<p>创造力需要靠技术手段实现。混迹在互联网上，没有自己建站的能力实在是很苦逼的一件事情。之后自己准备花些时间在 RoR 上。积累技术实力，努力做出好产品;)</p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/06/11/gift-to-girl-friend/'>http://biaobiaoqi.github.com/blog/2013/06/11/gift-to-girl-friend/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《写给大家看的设计书》]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/06/11/the-non-designers-design-book/"/>
    <updated>2013-06-11T13:58:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/06/11/the-non-designers-design-book</id>
    <content type="html"><![CDATA[<h3>从 iOS7 的扁平化谈起</h3>

<p>昨晚看了 WWDC2013 的直播，iOS7 以扁平化 UI 的方式展现在世人面前。于是接下来进入了微博吐槽时间。</p>

<p>大象要跳舞是很难的，这正是苹果面临的情况。现在无论是 Android 还是 Winphone，与 iOS 系统体验上的差异已经不是难以企及的，甚至有些方面更能为大众接受。于是 Ive 带领他的团队开始拥抱<strong> Flat Design</strong>。乔布斯子不知道会怎么想，他可是坚持了一辈子的拟物风格。当然，无论乔老爷子怎么想，时势如此，由不得苹果不变。</p>

<p>从微博疯狂的 iOS7 刷屏中挑出了些有价值的信息，关于扁平化和拟物化的：</p>

<ul>
<li><a href="http://www.zhihu.com/question/20881633">什么是扁平化设计（Flat Design）？扁平化设计是未来的趋势吗？</a></li>
<li><a href="http://www.inside.com.tw/2013/03/25/flat-design">UI 美學趨勢備忘錄─淺析扁平化設計</a></li>
<li><a href="http://www.oschina.net/translate/flat-design-principles">扁平化设计原则</a></li>
</ul>


<p>看完这些已经晕头了。人的思维总是有惰性的，倾向于接受自己头脑中已经有条理的思维结果。不情愿的说，这些略显专业的介绍已经超出了我对设计的思考范畴了，我看到的只是零散的观点，而找不到源头。</p>

<p>于是想起了《写给大家看的设计书》。作为非设计人员，这本书够接地气。一个多月前看完，让自己对设计的认识从一个完全的小白提升为一个略有喜好和观点的小白了。还是先聊这本书吧。</p>

<h2>设计的基本原则</h2>

<p>读这本书之前，在不同平台上看见它的好多推荐了。不过鉴于大多数设计类书都是『手把手教你画马』的效果（详情参见下图），一直不太感冒。</p>

<p><img src="https://dl.dropboxusercontent.com/u/64021093/Pics/307-12110Q62915932.jpg" title="画马" alt="怎样画马" /></p>

<p>后来码代码太烦躁，抱着试一试的态度在多看上下载了下来，一着眼便被吸引住了。书本本身的排版设计就透露着简洁明了的设计感，配色也恰到好处的清新。</p>

<p>全书循序渐进的从设计的四大基本原则讲起，结合丰富的案例分析，延伸到具体的主题设计技巧中。这部分是最让我觉得受益的部分。当然，不仅仅只是这些，还有涉及到颜色的运用、字体的设计等内容，本着『不要在意这些细节』的原则，它们被我匆匆略过。</p>

<p>可以这么夸张的说，设计的『四项基本原则』是我有自主意识以来觉得最受用的『条条框框』：</p>

<h3>原则一：亲密性</h3>

<p>亲密性的根本目的是组织性。还有个副产品，利用亲密性可以使空白更美观。</p>

<ul>
<li>将相关的项组织在一起。</li>
<li>物理位置的接近就意味着存在关联。</li>
</ul>


<h3>原则二：对齐</h3>

<p>对齐的根本目的是使页面统一而有条理。不论创建精美的、正式的、有趣的还是严肃的外观，通常都可以利用一种明确的对齐来达到目的。</p>

<ul>
<li>任何元素都不能在页面上随意安放。每一项都应当与页面上的某个内容存在某种视觉联系。</li>
<li>对齐的项会形成一个内聚的单元。</li>
<li>居中对齐显得正式、稳重，但一般不要用居中对齐。</li>
<li>一定要坚持页面上只使用一种文本对齐，避免混合使用多种文本对齐。</li>
<li>可以适时的打破规则，但在此之前得清楚什么是规则。</li>
</ul>


<h3>原则三：重复</h3>

<p>重复的根本目的是统一，并增强视觉效果。</p>

<ul>
<li>设计的某些方面需要在整个作品中重复</li>
<li>重复是一种全局的一致性，比如杂志每页的标题都使用同样的字体大小。这有利于信息的组织。</li>
<li>重复也一定程度给作品带来专业性和权威性。</li>
<li>要避免太多的重复，重复太多会让人厌烦。注意对比的价值</li>
</ul>


<h3>原则四：对比</h3>

<p>根本目的有两方面。一个目的是增强页面效果，如果一个页面看起来很有意思，往往更有可读性；另一个目的是有助于信息的组织。</p>

<ul>
<li>如果两项不完全相同，就应当使之不同，而且应当是截然不同。</li>
<li>对比一定要强烈。</li>
</ul>


<h3>应用设计原则</h3>

<p>优秀的设计就这么容易：</p>

<ul>
<li>1.学习 4 大基本原则;</li>
<li>2.认识到自己没有运用这些原则；</li>
<li>3.应用基本原则。</li>
</ul>


<p>这四个基本设计原则是相互关联的，只应用某一个原则的情况很少。当对应着一个个的举例体验过四条基本原则的威力后，接下来就是在自己身边实践这些原则了。</p>

<p>一方面，可以观察四项原则在现有设计中的应用：比如当前所打开的网页，是否足够清晰、明确的展示了它所要表达的意图；手头的书本，排版是否跟内容在情感上吻合。</p>

<p>另一方面，时常会有些文档、写报告、为展示写 slides 的需求，自己在创作的过程中，也可以应用起这四条原则，慢慢体会，慢慢修炼。</p>

<h2>体会</h2>

<p>歌德在《浮士德》中提到过这么一句话：『理论是灰色的，生活之树常青』。在我看来，所有的事物都是如此，人性使然。抛开这四条原则本身，它们归结起来都是要实现意图的传递：</p>

<blockquote><p>将信息从设计者准确无误的传递给目标用户</p></blockquote>

<p>设计作为一种原始信息的载体，本身的形式上会带来附加的信息量，如何让这些设计自身的附加量不混淆了核心的原始信息，是设计好坏的根本。更进一步，设计的更高层次应该是让设计的附加量起到正相关的增益效果。《写给大家看的设计书》中的四个原则正是最基础的实践。</p>

<p>现在是信息的时代，信息量的暴增让信息的简洁展示和选择变得越发关键。前文提到的扁平化的设计风格的崛起，就是一个例证:</p>

<p>『扁平化设计具有一种给你让人心醉的美丽，没有大量的修饰，它能以一个简单直白的方式传达一个信息或者帮助一个产品以及思想变得更加深入人心……扁平化设计正是通过放弃任何附加效果的方式，创建一个「零」3D 属性的设计方案。在这里，没有阴影效果、斜角、浮雕、渐变等其他方法来帮助元素产生相对于屏幕的凹凸效果。不带有羽化边缘以及阴影效果的图标和 UI 元素也都看起来非常鲜明。』</p>

<p>相对而言，乔布斯推崇的拟物风格中，所秉承的是让所有用户能快速的学会如何使用它。而随着时代的发展，这种降低学习成本的方式渐渐的不是必须，数码产品充斥着生活，大多数人已经有足够的经验来应对新的操作体验。从这个角度讲，扁平化在现阶段或许是更有好的选择。</p>

<p>不管怎么样，WWDC 以后，苹果股价已经持续下跌了，祝福苹果吧，希望 Ive 不要成为苹果的罪人，据说他是最懂乔布斯的人呢。</p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/06/11/the-non-designers-design-book/'>http://biaobiaoqi.github.com/blog/2013/06/11/the-non-designers-design-book/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac的GUI哲学]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/06/09/something-about-mac-gui/"/>
    <updated>2013-06-09T01:00:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/06/09/something-about-mac-gui</id>
    <content type="html"><![CDATA[<h2>GUI 哲学</h2>

<p>前些日子，看了 Tinyfool 老师的一篇文章<a href="http://blogread.cn/it/article/1089?f=wb">《开发人员为何应该使用 Mac OS X 兼 OS X 小史》</a>，才恍然 Mac 系统可不仅仅是 UI 上与 Windows 大相径庭，而是自底而上的区别。这种区别渗透到了整个系统框架的设计理念中。</p>

<p>简单概括下我的认识：相比 Windows 和 Linux 两大阵营，Mac OS X 除了『品味』上的优势之外，最重要的两点是：1.对 GUI 应用程序脚本化的有力支持；2.能实现 GUI 程序之间快捷的进程间通信。</p>

<h4>GUI 程序之间的进程间通信</h4>

<p>IPC 对于多用户分时系统的重要性不言而喻。其中从用户视角来看，如何让多个程序之间能更友好的交互是非常重要的。C++语言虽然面向对象，但在底层来看，其实依旧是冷冰冰的汇编代码，没有更整体的对象环境支撑，而以此构建的 Linux 也无法对进程间通信形成强力的支持。相比之下，乔布斯的团队借助于 SmallTalk 的消息传递机制创造了 Objective-C，并搭建了自己的运行时和类库框架 Cocoa，让系统无论从自身的迭代开发还是应用开发，得到了很大提升。值得一提的是，Objc 虽然最近才由于 iOS、Mac 平台的开发的火热进入热门编程语言的行列，其实它比 Java 还早十年出生。像最近由于 Rails 框架而火爆起来的 Ruby 和持续坚挺的 Java，都从 SamllTalk 中吸收了很多设计理念，就别提 C#了。</p>

<h4>GUI 应用程序的脚本化</h4>

<p>图形的交互方式确实人性化，但应用程序脚本化控制的方式在一些特定的场景里也可以大大提高生产效率。比如微软 Office 的 VBScript。即使是一般用户，不愿意自己写脚本，脚本化的方式也能让开发人员更方便快捷的开发出新颖的功能和产品。</p>

<p>让应用全部统一开放脚本很难，特别是从市场的层面而言，如果没有一直贯彻这一战略，造成平台很多应用不支持这一功能，则很难推广。苹果九十年代已经开始积累这方面的基础，有先见之明。</p>

<h2>GUI 工具</h2>

<p>下面是我接触过的一些 Mac 下的 GUI 工具。它们大都散发着对开发者的自由开放的态度:)</p>

<h3>Quicksilver</h3>

<p>『为了不把 Mac 当 Windows 用』，可以从 <a href="http://qsapp.com/">Quicksilver</a> 入手。它能将双手从触摸板中解脱出来，或许这是很多开发者的梦想吧;)。只需用热键激活输入框，输入简单的匹配字符串，就可召唤出某个应用，或者执行某些搜索、查找任务，快哉！</p>

<p>简单说说配置和使用方式：</p>

<ul>
<li>1.安装好后，在 preference -> command 中可以设置 HotKey（唤醒的虚拟按键），我的习惯设置是<code>control+enter</code>。preference -> application 可以设置是否需要在 dock 中显示，以及登入时自动启动。</li>
<li>2.基本功能：快捷打开应用。按下 Quicksliver 的 HotKey（我的是<code>control+enter</code>）,在弹出的输入框中输入所需应用的头几个字母或者缩写，Quicksliver 会自动匹配最可能的应用，并显示出来，如果不是自己想要的，可以移动「上下光标」打开下拉菜单选择。选中后回车即可，如图。</li>
</ul>


<p><img src="https://dl.dropboxusercontent.com/u/64021093/Pics/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202013-06-09%20%E4%B8%8B%E5%8D%881.23.22.png" title="Quicksilver 示例" alt="Quicksilver" /></p>

<ul>
<li>3.还有很多其他的细节功能，通过 Quicksliver 的插件实现，可以根据自己的需求来定制。</li>
</ul>


<h3>Shortcat</h3>

<p><a href="http://shortcatapp.com/">shortcat</a> 是 Mac 下的快捷操作利器。相比 Quicksilver，Shortcat 有不同的定位：通过键盘定位到屏幕上某窗体内的某个位置。其官网的示例就是如何通过 Shortcat 使用键盘更改 DNS 设置，注意，是完全不用鼠标噢。有人可能会想那为什么卜直接使用 cmd 呢？我想答案是 Shortcat 就是基于 GUI 的解决方案，是 GUI 和键盘快捷键的完美组合，与 cmd 并不冲突。</p>

<p>下面简单的交代下 Shortcat 的使用方式：</p>

<ul>
<li>1.快捷键<code>Cmd+Shift+Space</code>用来激活输入框。使用关键字的定位方式类似于 Quicksilver。比如：如果目的是『Language &amp; Text』，那么输入『lt』、『lang』；『sa』代表 show all，显示所能用于文字定位的区域。『.』能展示出所有可控制区域，包括没有文字定位的区域。</li>
<li>2.输入了关键字后，界面中被匹配到的模块会被套上不同颜色的方框。接下来，可以使用<code>control+key</code>重定位到对应位置，其中 key 为对应的匹配上的模块的字符标识。</li>
</ul>


<p><img src="https://dl.dropboxusercontent.com/u/64021093/Pics/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202013-06-09%20%E4%B8%8B%E5%8D%881.42.39.png" title="Shortcat 示例" alt="Shortcat" /></p>

<ul>
<li>3.定位到合适的位置后，按下<code>enter</code>，可执行单击动作；对应的，双击<code>enter</code>为鼠标双击动作；如果需要配合其他按键的点击，比如<code>command+click</code>，执行<code>command+enter</code>即可；鼠标悬浮为<code>control</code>；双击<code>control</code>可实现聚焦。</li>
</ul>


<h3>GeekTool</h3>

<p><a href="http://projects.tynsoe.org/en/geektool/">GeekTool</a> 类似于 Windows 下的 widget，可以个性化的定制自己的桌面，添加插件，将 CPU、HDD 信息直接展示在桌面上，正如其名，Geek 而又文艺!如下效果图：</p>

<p><img src="http://bbs.dgtle.com/data/attachment/album/201111/10/011505943pmpmm68enxwwd.png" title="GeekTool 示例桌面" alt="GeekTool" /></p>

<p>详细配置可参考这篇文章<a href="http://www.dgtle.com/article-797-1.html">《教你装小清新—— Geektool &amp;&amp; Rainmeter 桌面皮肤推荐》</a></p>

<h3>Nocturne</h3>

<p><a href="http://code.google.com/p/blacktree-nocturne/downloads/detail?name=Nocturne.2.0.0.zip">Nocturne</a> 这是桌面颜色控制的工具，与 Quicksilver 同为 blacktree 公司的产品。</p>

<p>使用方式：下载 Nocturne2.0.0，解压后拖入应用程序文件夹，打开。在 preference 中可很直观的配置各项属性。其中，switch to night 功能可以将 Mac 界面切换到黑夜模式，很好玩;)。</p>

<h3>参考：</h3>

<ul>
<li><a href="http://ksmx.me/blog/2012/03/18/customize-mac-desktop/">矮矬穷 Mac 桌面美化得瑟教程</a></li>
</ul>


<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/06/09/something-about-mac-gui/'>http://biaobiaoqi.github.com/blog/2013/06/09/something-about-mac-gui/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SDN：软件定义网络]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/06/08/software-defined-network/"/>
    <updated>2013-06-08T00:39:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/06/08/software-defined-network</id>
    <content type="html"><![CDATA[<p>最近高级网络课的小组任务是在老师给定的范围内自选方向主题研究并做展示报告。我们组选了 sdn。原以为这东西会是工业界无人问津的概念化产品，Google 了一下却发现其实 sdn 挺火的，由于它可能带来的可扩展性，一些大互联网企业也在开始涉足相关的研发，比如 Google 呵 Facebook。这里简要的梳理下我对 SDN 概念性的认识。</p>

<h2>背景</h2>

<h3>虚拟化的大趋势</h3>

<p>近年来，大数据、云计算兴起，虚拟化技术的重要性越发突出。提到虚拟化，不得不提的是计算机行业里的一句老话：</p>

<blockquote><p>计算机世界的绝大部分问题都可以通过分层的方法来解决</p></blockquote>

<p>其实虚拟化也可以理解成一种分层的思想。就拿云计算这个应用场景来说，虚拟化的技术就是在原有的<code>硬件-操作系统-用户</code>层次中，增添了<code>虚拟机</code>这么一层，变成了<code>硬件-虚拟机-操作系统-用户</code>，用虚拟机来管理硬件资源，增加了动态调整硬件资源的语义。</p>

<p>纵观计算机的发展历程，各方面都可以看到通过增加类似的虚拟化层次来提高生产效率的案例。比如高级语言之于汇编，比如图形界面之于命令行。这种添加层次的解决方案，总是能让问题得到更清晰的解决。</p>

<h3>网络虚拟化</h3>

<p>网络经历了<a href="http://article.yeeyan.org/view/100437/70880">数十年的发展</a>，如今在人们的生产、生活中发挥着巨大的作用。全球的网络拓扑结构结构错综复杂，有许多的自制系统组成。数据包从中国的一台 PC 机发出，访问到美国的主机，需经过一系列的路由、转发，而经由的网络拓扑节点由层层网关、路由器支配，难于控制。一些组织，在架设自身的可扩展、大规模网络环境时，也同样遇到了拓扑结构复杂、难于维护的问题。</p>

<p>如果能剥离开网络的物理拓扑结构，将网络资源虚拟化，隐藏物理结构的复杂性，统一的进行逻辑层的管理控制，就能满足多变的网络需求了。</p>

<p>SDN 和 OpenFlow 就是一个这样的解决方案。</p>

<h2>OpenFlow 和 SDN</h2>

<p>OpenFlow 起源于斯坦福的 Ethane 项目。该项目试图通过一个集中式的控制器，让网络管理员可以方便地定义基于网络流的安全控制策略，并将这些安全策略应用到各种网络设备中，从而实现对整个网络通讯的安全控制。受到此项目的启发，斯坦福的老师和学生将 Ethane 的设计更一般化，将传统网络设备的数据转发(data plane)和路由控制(control plane)两个功能模块相分离，通过集中式的控制器(Controller)以标准化的接口对各种网络设备进行管理和配置。2008 年，他们提出了 OpenFlow 的概念。</p>

<p>这种分布式的实现方式，让控制平面可以和转发平面物理的分离开，控制平面完全可以运行在运算能力更强的服务器上，而不是路由器。OpenFlow 协议则是分离的两者之间的通信协议。关于 OpenFlow 的技术细节，<a href="http://network.51cto.com/art/201306/397443.htm">《虚拟化的逆袭：OpenFlow 和 SDN》</a>一文中有简明介绍。</p>

<p>基于 OpenFlow 为网络带来的可编程的特性，有研究人员提出了 SDN 即 Software Defined Network（2009 年）。在这个概念中，网络中所有的网络设备被视为被管理的资源，以此抽象出一个网络操作系统(Network OS)的概念，这个网络操作系统一方面抽象了底层网络设备的具体细节，同时还为上层应用提供了统一的管理视图和编程接口。SDN 的架构细节，参见<a href="http://network.51cto.com/art/201211/366278.htm">《SDN 是生意 OpenFlow 是技术》</a>。</p>

<p>SDN 和 OpenFlow 的关系，就像互联网之于 TCP/IP 协议栈。OpenFlow 是 SDN 的核心协议，用于控制转发面设备的控制转发。而 SDN 是上层的变成界面。</p>

<p>有观点认为，『OpenFlow 是技术，SDN 是生意』。最近对 SDN 唱衰的报道也证明了这桩『生意』的前途未仆。</p>

<h2>SDN 的发展</h2>

<p>在云计算飞速发展的同时，SDN 也喧嚣尘上。Google,Facebook 等大公司也结成了产业联盟，来推动其发展。</p>

<p>但其现状也并非一片明朗：</p>

<blockquote><p>根据 IDC 的研究结果显示，在 2013 年，整个企业网络行业的市场价值为 420 亿美元，其中将近一半来自 2-3 层网络交换机市场。SDN 只能产生约 37 亿美元的价值(8.8%)，而且要到 2016 年才能达到这个数字。与早前的预测相比，IDC 的预测数字有所增加，但从整个网络行业来看，SDN 仍然相去甚远。</p></blockquote>

<p>一方面，SDN 的性能还有待改善，另一方面，由于 SDN 的统一平台的思想，会带来硬件设备的同质化，威胁到厂商的利益，将会面临来自厂商锁定的阻力。<a href="http://www.csdn.net/article/2013-06-08/2815714">《理性看待 SDN》</a>一文中有较详细的解释。</p>

<p>虽然虚拟化能解放生产力，是大势所趋，但就像功耗更大的复杂指令集在市场上战胜了精简指令集一样，市场是残酷的。只能期待开源和开放的脚步不要停下。</p>

<h3>参考</h3>

<ul>
<li><a href="http://blog.sina.com.cn/s/blog_72628e9f0100yg3b.html">什么是 SDN(Software Defined Networking)？</a>
*</li>
<li><a href="http://blog.sina.com.cn/s/blog_5385c0b901010pu3.html">OpenFlow/SDN 本质论</a></li>
<li><a href="http://article.yeeyan.org/view/323168/358956">软件定义网络(SDN)：是什么，如何工作，为什么重要</a></li>
<li><a href="http://network.51cto.com/art/201305/394648.htm">SDN：仍处于起步阶段</a><p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/06/08/software-defined-network/'>http://biaobiaoqi.github.com/blog/2013/06/08/software-defined-network/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《Hadoop技术内幕》学习笔记——RPC和动态代理]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/06/08/ipc-in-hadoop/"/>
    <updated>2013-06-08T00:24:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/06/08/ipc-in-hadoop</id>
    <content type="html"><![CDATA[<p>本文是《hadoop 技术内幕——深入解析 Hadoop Common 和 HDFS 架构设计与实现原理》第 4 章的 1-3 节的学习笔记。内容为 Hadoop IPC 部分的基础知识介绍。</p>

<h2>知识框架</h2>

<p>由于 Hadoop 分布式环境需要一个更高效和正对性优化的 IPC 机制，传统的诸如 RMI 的解决方案无法满足这一要求，Hadoop 自己实现了一套 IPC 方法。</p>

<p>第 4 章第 1 节讲解了 RPC 的原理，包括 Stub-Skeleton 的架构等，进而用<code>RMI</code>举例（可以参考的<a href="">演示代码</a>）。RMI 的调用实现主要包括了服务器端的 registry 和客户端的 lookup。虽然 Hadoop 不是使用 RMI 做 IPC，但了解一下其调用方式对感性的认识到如何进行分布式环境下的远程调用还是有作用的。</p>

<p>接下来的 2,3 小节，简单的介绍了 IPC 过程所依赖的技术方法：Java 的动态代理方式和 NIO 的网络传输方式。</p>

<p>第 2 节讲<code>动态代理</code>，这里需要理解面向对象的代理模式和<em>动态</em>的原因。代理模式分很多种，这里用到的是简单的对行为的传递。动态代理的动态特性，则是因为框架能提供动态创建某个接口的实现的能力(可以参考的<a href="">演示代码</a>)。</p>

<p>更系统的看动态代理过程，分为两个阶段：</p>

<ul>
<li>1.代理接口的实现：静态方法 Proxy.newInstance()生成动态对象。</li>
<li>2.调用转发过程：InvocationHandler 实现</li>
</ul>


<p>第 3 节的<code>NIO</code>，跟传统的套接字(Socket)通信过程做了对比。需要了解 Socket 通信的特点：同步，阻塞，基于字节，理解这种特点带来的服务器端的线程闲置的压力。对应的，NIO 则是可异步的，非阻塞的，基于块的。具体的实现上，需要了解缓冲区(Buffer)的原理和使用方式，通道(Channel)和选择器(Selector)配合的使用方式。</p>

<p>我总结了一份 slides，如下：(挂在 speackerdeck 上，如果加载缓慢，请稍候:))</p>

<script async class="speakerdeck-embed" data-id="fbcb8590b1540130690c2e6f0be13e84" data-ratio="1.33333333333333" src="http://biaobiaoqi.github.com//speakerdeck.com/assets/embed.js"></script>


<p>slides 下载地址：<a href="https://dl.dropboxusercontent.com/u/64021093/slides/%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E5%92%8CNIO.pdf">请戳</a><p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/06/08/ipc-in-hadoop/'>http://biaobiaoqi.github.com/blog/2013/06/08/ipc-in-hadoop/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于毕业季照片分享的思考]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/05/25/some-ideas-about-using-bt-protocol-to-sync/"/>
    <updated>2013-05-25T22:47:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/05/25/some-ideas-about-using-bt-protocol-to-sync</id>
    <content type="html"><![CDATA[<h2>背景</h2>

<p>毕业季到了，女朋友跟班里同学们一起拍了很多照片。由于照片分散在不同的人的手机、相机里，她也无法立即给我传来她的照片。这个情景一年前我也遇到过，只是当时自己比较忙，加上考虑着还会在本校读研，也没太在意毕业季照片的手机这一需求，以至于到现在我的电脑里甚至没有一张我穿学士服的照片:-=。而现在，当我想看看 gf 的照片时，这个需求横亘在我面前，让我特别的想解决掉它。</p>

<p>让我们从事实出发，理清问题的思路。</p>

<h2>需求的产生</h2>

<p>大学生拍毕业季照的现状：</p>

<ul>
<li>1.大学生在毕业季拍照留念是刚需，几乎平日爱拍照、不爱拍照的所有人都会参与其中。</li>
<li>2.拍照一般以小团体为基本单元进行。多是班级、社团这种常见的凝聚力较强的团体。</li>
<li>3.随着科技的发展和生活水平的提高，越来越多的人具备了拍出高质量照片的设备和实力。</li>
</ul>


<p>由于这种以小团体为单位的照片的大量产生，每个团体中的照片会交叉散落在较多人手中。在这种分散的格局面前，单独挑选出自己的照片并保存的成本巨大，直接导致了大家最终需求的统一：</p>

<ul>
<li>将所有的照片分发到所有人手中。</li>
</ul>


<h2>原有解决方案</h2>

<p>现有的解决方案主要方案归纳为如下四种：</p>

<ul>
<li><p>1.用移动硬盘等设备人力拷贝</p>

<p>  这种方式太过古老和原始，缺点费时费力。</p></li>
<li><p>2.使用公邮、网盘、QQ 群共享等方式统一上传、下载</p>

<p>  主要缺点是外网网速限制；另外，网速的限制让用户上传和下载的门槛变高，影响了上传积极性，如果有人迟迟不上传，最终下载完整数据的时间也会一直拖延，带来消极的体验；如果注册一次性账号，这也不见得是环保的行为（或许这想法有点数据洁癖吧>&lt;），如果使用非一次性账号，那么权限管理将比较头疼。</p></li>
<li><p>3.使用内网 BT 资源站分别打包上传、下载</p>

<p>  优点是利用了内网网速的优势。缺点是每个人都打包做种，会让资源分散的很厉害，难于汇集。且做种等步骤对于部分用户而言，有操作门槛。</p></li>
<li><p>4.先使用 1 中方法，统一手机照片数据，然后按照 2 或 3 的方法发布数据</p>

<p>  这大概是最靠谱的方式了，缺点集中在需要有人费时费力的手机数据上。当然，如果班里有一个任劳任怨的好班长，这个问题就解决了。</p></li>
</ul>


<h4>总结：</h4>

<p>对于一个懒人而言，现有的解决方案都是蹩脚的。这些解决方案都不约而同的希望首先将数据聚合到一个外部空间中，然后再统一的分发给大家。这个步骤必要吗？实际上，我们只是需要每个人都方便、快捷的获得所有照片。</p>

<h2>一个简单的设计</h2>

<p>我将问题抽象为：</p>

<ul>
<li>完整的数据分散在 10 至 20 个数据拥有者手中，需要通过一定手段，让每个个体都不重复的拥有完整的数据。</li>
</ul>


<p>由于外网网速的限制，基于校园内网建立的工具就有了天然的优势。但如果使用内网，就不得不抛弃各大公司免费提供的邮箱存储空间、网盘存储空间。而校内的资源是有限的，没有自己的服务器，没有足够的空间存储大家的数据，这也就迫使我们考虑到了 p2p 的系统架构。于是，有了这样的解决方案，设定代号为 BBT：</p>

<ul>
<li>PC 机安装 BBT 工具软件后，可以设定<code>共享目录</code>和对应的<code>分享 ID</code></li>
<li>放入特定<code>共享目录</code>的文件，将使用基于 p2p 同步的方式，在拥有相同的<code>分享 ID</code>的<code>共享目录</code>间同步数据，目的是让所有人都获得到每个人的数据</li>
</ul>


<p>在跟阿豪童鞋的交流中，他建议为了进一步简化用户操作，可以尝试这样一种体验方式：</p>

<ul>
<li>班级内所有人在同一个链接下载工具软件。保证这一链接下载的软件能互相通信，实现数据同步。这杨就节省了用户自己设定相同的<code>分享 ID</code>的流程，而将这一过程转移到班长请求下载链接的过程中。</li>
</ul>


<p>确实够简洁，很赞，实现成本还需要调研。</p>

<h6>BitTorrent Sync</h6>

<p>在构思的过程中，突然想起前几天在 start up news 上看到了一个基于 BT 协议的同步软件 <a href="http://labs.bittorrent.com/experiments/sync.html">BitTorrent Sync</a>。</p>

<p><img src="http://labs.bittorrent.com/img/wide/sync.png" title="BitTorrent Sync" alt="BitTorrent Sync" /></p>

<p>它的实现方式大概是我们所需要的。可惜的是，由于它的功能全面，界面略显复杂。而同时，它并没有开放二次开发接口。</p>

<p>或许我需要自己搭建一个 p2p 的系统？</p>

<h6>PS:</h6>

<p>BT 的优势，在于利用了所有节点的存储和传输能力，节点数量越多，下载越快</p>

<p>BitTorrent  Sync 的优势，则在于能动态的集合分散在不同节点中的数据</p>

<p>感觉这种去中心化的分布式系统，前景大大的有啊;)<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/05/25/some-ideas-about-using-bt-protocol-to-sync/'>http://biaobiaoqi.github.com/blog/2013/05/25/some-ideas-about-using-bt-protocol-to-sync/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[KMP算法实现]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/05/25/kmp-algorithm/"/>
    <updated>2013-05-25T21:22:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/05/25/kmp-algorithm</id>
    <content type="html"><![CDATA[<p>本文描述了单模式的字符串匹配的经典算法 KMP 算法的实现。首先对字符串匹配算法做简单的介绍，然后是 KMP 算法的实现描述，最后推荐两道简单的 ACM 模板题做练手用。</p>

<h2>字符串匹配算法</h2>

<p>字符串匹配(String Matchiing)也称字符串搜索(String Searching)是字符串算法中重要的一种，是指从一个大字符串或文本中找到模式串出现的位置。一个基本的字符串匹配算法分类如下：</p>

<ul>
<li>单模式匹配：即每次算法执行只需匹配出一个模式串。</li>
<li>有限集合的多模式匹配：即算法需要同时找出多个模式串的匹配结果，而这个模式串集合是有限的。</li>
<li>无限集合的多模式匹配：如正则表达式的匹配。</li>
</ul>


<p>单模式匹配最容易理解，构造也非常简单。一个最朴素的思路就是从文本的第一个字符顺次比较模式串，不匹配则重新从下一个字符开始匹配，直到文本末尾。Java 实现代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'> <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">bruteforce</span><span class="o">(</span><span class="n">String</span> <span class="n">str1</span><span class="o">,</span> <span class="n">String</span> <span class="n">str2</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>         <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">!=</span> <span class="n">str1</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">)</span> <span class="o">{</span>
</span><span class='line'>               <span class="k">if</span> <span class="o">(</span><span class="n">str1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">str2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">j</span> <span class="o">++;</span>
</span><span class='line'>                    <span class="n">i</span> <span class="o">++;</span>
</span><span class='line'>                    <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">str2</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>               <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>                    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>               <span class="o">}</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>          <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>     <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是这种算法，有明显的效率黑洞。因为每次匹配失败后，都会回到原来的匹配起点的下一个字符开始匹配，这些步骤很多情况下，并不是必要的。</p>

<p>实际上这些字符很有可能已经被读入了一次。理论上，如果我们能对所有被读入过的字符有足够的了解，那就能判定是否能避免再次读入一遍做匹配运算了。经典的 KMP 算法正是基于这点思考，对原有的蛮力算法做出了优化。</p>

<h2>KMP 算法</h2>

<p>网络上关于 KMP 算法的描述很多，其中个人觉得阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">《字符串匹配的 KMP 算法》</a>对 KMP 的描述最为简明和清晰。图例展示的算法流程更容易让人接受和理解。这里仅记录我所认为重点的知识点。</p>

<h5>算法的思想</h5>

<p>相比蛮力算法，KMP 算法预先计算出了一个哈希表，用来指导在匹配过程中匹配失败后尝试下次匹配的起始位置，以此避免重复的读入和匹配过程。这个哈希表被叫做“部分匹配值表(<strong>Particial match table</strong>)”，它的设计是算法精妙之处。</p>

<h5>部分匹配值表</h5>

<p>要理解部分匹配值表，就得先了解字符串的前缀(prefix)和后缀(postfix)。</p>

<ul>
<li>前缀:除字符串最后一个字符以外的所有头部串的组合。</li>
<li>后缀：除字符串第一个字符以外的所有尾部串的组合。</li>
<li>部分匹配值：一个字符串的前缀和后缀中最长共有元素的长度。</li>
</ul>


<p>举例说明：字符串<code>ABCAB</code></p>

<ul>
<li>前缀：{A， AB， ABC， ABCA}</li>
<li>后缀：{BCAB， CAB， AB， B}</li>
<li>部分匹配值：2 （AB）</li>
</ul>


<p>而所谓的部分匹配值表，则为模式串的所有前缀以及其本身的部分匹配值。</p>

<p>举例如下：还是针对字符串<code>ABCAB</code>，它的部分匹配值表为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="n">A</span> <span class="n">B</span>
</span><span class='line'><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span>
</span></code></pre></td></tr></table></div></figure>


<p>这代表着：字符串<code>A B C A B</code> 中，子串<code>A B C</code>的部分匹配值为 0，而子串<code>A B C A</code>的部分匹配值为 1，诸如此理。</p>

<h5>算法实现</h5>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">next</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">kmp</span><span class="o">(</span><span class="n">String</span> <span class="n">str</span><span class="o">,</span> <span class="n">String</span> <span class="n">dest</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="c1">// i stands for index of str string, j stands for index in dest string.</span>
</span><span class='line'>  <span class="c1">// At the beginning of each loop process, j is the new position of dest</span>
</span><span class='line'>  <span class="c1">// taht should be compared.</span>
</span><span class='line'>  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="n">dest</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span>
</span><span class='line'>          <span class="c1">// This loop is to get a matching character recursively. Another</span>
</span><span class='line'>          <span class="c1">// stop condition is when particial match value meets end.</span>
</span><span class='line'>          <span class="n">j</span> <span class="o">=</span> <span class="n">next</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span><span class="c1">// As i in str and j in dest is comparing,</span>
</span><span class='line'>                          <span class="c1">// recomputing of j should be in the former</span>
</span><span class='line'>                          <span class="c1">// character substring, which is next[j-1]</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">dest</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span>
</span><span class='line'>          <span class="n">j</span><span class="o">++;</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">dest</span><span class="o">.</span><span class="na">length</span><span class="o">())</span>
</span><span class='line'>          <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">kmpNext</span><span class="o">(</span><span class="n">String</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="kt">int</span><span class="o">[]</span> <span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">()];</span>
</span><span class='line'>  <span class="n">next</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>  <span class="c1">// i stands for index of string, j is temporary for particail match</span>
</span><span class='line'>  <span class="c1">// values computing, at the beginning of each loop process, j is the</span>
</span><span class='line'>  <span class="c1">// particial match value of former character .</span>
</span><span class='line'>  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span>
</span><span class='line'>          <span class="c1">// This loop is to get a matching character recursively. Another</span>
</span><span class='line'>          <span class="c1">// stop condition is when particial match value meets end.</span>
</span><span class='line'>          <span class="n">j</span> <span class="o">=</span> <span class="n">next</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span><span class="c1">// j will be recomputed in the recursion. Take</span>
</span><span class='line'>                          <span class="c1">// care that next[j-1] is the particial match</span>
</span><span class='line'>                          <span class="c1">// value of the first j characters substirng.</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="c1">// If not in this case, j must</span>
</span><span class='line'>                                          <span class="c1">// meets end, equals to zero.</span>
</span><span class='line'>          <span class="o">++</span><span class="n">j</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">next</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">next</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>理解算法实现时，有几点特别需要注意：</p>

<ul>
<li>在生成部分匹配值数组的 kmpNext()方法中，第一层循环内，<code>i</code>是字符串的索引，而<code>j</code>则在每次循环开始时代表了<code>i</code>所指定字符之前的子串的部分匹配值。</li>
<li>kmpNext()方法的内层 while()循环，是为了迭代得到让<code>i</code>指定字符匹配到的情况。有另外一种实现方案：不有用这一层循环，而是直接使用一层循环，在大循环内部做 j 值变更的判定即可。</li>
<li>kmpNext()方法的 while()循环中，需要特别注意是<code>next[j -1]</code>，部分匹配值 j 对应到的是字符串中的第<code>j-1</code>个字符。</li>
<li>kmp()的循环代码和 kmpNext()部分匹配值表生成的循环代码很类似。两者使用了相同方式，在字符匹配失败后迭代获取新的可匹配情况，且都是利用了 next 数组。</li>
</ul>


<h2>其他</h2>

<p>KMP 算法虽然能达到 O(M+N)的算法复杂度，但在实际使用中，KMP 算法的性能并不如 <a href="http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html">BM</a> 算法强。</p>

<h2>模板题</h2>

<h4>基础模板题</h4>

<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2203">HDOJ 的 2203 题</a>是一个能检验算法正确性的模板题。Java 实现的答案代码<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/practice/hdoj/HDOJ2203.java">请戳这里</a>。</p>

<h4>延伸模板题</h4>

<p><a href="http://poj.org/problem?id=2406">POJ 的 2406 题</a>，对考察点做了巧妙的变形，对更深入的理解 KMP 中的部分匹配表（即 next 数组）很有帮助。Java 实现的答案代码<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/practice/poj/POJ2406.java">请戳这里</a>。</p>

<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1867">HDOJ 的 1867 题</a>也属于 kmp 的变形。要求对 kmp 利用 next 数组进行比较的过程有清晰的认识。Java 实现的答案代码<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/practice/hdoj/HDOJ1867.java">请戳这里</a>。</p>

<h3>其他参考资料：</h3>

<ul>
<li><p><a href="http://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm">wiki:Knuth–Morris–Pratt Algorithm</a></p></li>
<li><p><a href="http://en.wikipedia.org/wiki/String_searching_algorithm">wiki:String Searching Algorithm</a></p></li>
<li><p><a href="http://www.cppblog.com/converse/archive/2006/07/05/9447.html">《KMP 算法的实现》</a></p></li>
<li><p><a href="http://wangcong.org/blog/archives/2090">《Linux 内核中的 KMP 实现》</a><p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/05/25/kmp-algorithm/'>http://biaobiaoqi.github.com/blog/2013/05/25/kmp-algorithm/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《程序员的思维修炼》]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/05/22/pragmatic-thinking-and-learning-refactor-your-wetware/"/>
    <updated>2013-05-22T01:14:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/05/22/pragmatic-thinking-and-learning-refactor-your-wetware</id>
    <content type="html"><![CDATA[<h3>别鄙视方法论</h3>

<p>曾经很长时间里，我这么认为：方法论的东西没什么实际的用处，不过是其他人按照自己的喜好来处理事物的途径而已，何必照着他人的思路。比如，作为一只不靠谱的程序猴子，在一些偏颇的思维习惯的影响下，我甚至对许多图形化的东西比较反感，自以为文本信息已经足以表达清楚事实且更有效率，从而本能的回避能造成视觉冲击的事物。直到后来，发现自己每每定下的计划都无法完整实施，自然也是没有收到预期的效果。我开始关注到方法本身是否合理，寻找那把平衡效率和体验的钥匙。</p>

<p>这本书给出了一个很好的答案。</p>

<p>虽然标题上赫然是“程序员”几个大字，但其实并没有这么局限。这是一本谈论思维习惯的书，对所有想了解大脑认知过程以更好的发觉其潜能的读者而言，都是可以参考的。虽然自己只是看完了这本书，而没有长期实践的效果证明，但从以往的经验来看，它的观点总能让我信服。</p>

<!--more-->


<p>下面是我印象最深刻的观点的总结：</p>

<h2>德雷福斯模型（Dreyfus）</h2>

<p>技能获取领域的模型。这个模型针对于某个技能而言，是一个情景模型。他将技能的掌握分为 5 个阶段：</p>

<ul>
<li>新手 -> 高级新手 -> 胜任者 -> 精通者 -> 专家</li>
</ul>


<p>新手和专家最主要的区别在于【直觉】：新手需要与情景无关的规则让他们高效工作，而专家则相反，他们更多的使用【情景】相关的直觉。（我不觉得需要记住所有这五个阶段，只需要知道，这是一个不断积累知识、培养思维习惯的过程。）</p>

<h2>认识大脑</h2>

<p>大脑的配置是双 CPU，单主机总线的。</p>

<ul>
<li>线性模式的 L（左脑）：主要负责线性、【逻辑思维】和【语言处理】。它按部就班的处理指令，相对缓慢，使用了大脑中较少的一部分资源。</li>
<li>富模式的 R（右脑）：大脑的 Google，负责搜索、模式匹配。它是异步执行的，【非理性】的。可能某个想法几天后才突然跳出来。它不做任何语言处理，这意味着它的结果也不是语言能表达的。它的处理只能邀请，不能强制命令 。我们可以时常记录各种想法，让它运转，以激发它的活跃状态。</li>
</ul>


<p>这两个 CPU 共享通过内存核心的总线（意识），每次只有一个 CPU 可以访问内存。</p>

<p>值得注意的是，积极的情感对学习和创造性思维非常关键。处于“高兴”的状态可以扩展你的思维过程，激活更多的大脑物质。</p>

<p>理解了大脑的工作模式，以及它们的不同和对实际思考能力的作用，就大概知道了平时应该怎么使用它对自己而言更有效。</p>

<h2>充分利用右脑</h2>

<p>需要强调 R 的功能，因为它关系着【直觉】，而这正是成为专家的必经之路。</p>

<ul>
<li><p>多感官的输入，能获得更高的效率。比如软件工程中使用 CRC 卡片做设计，或者使用积木、乐高玩具做架构设计。</p></li>
<li><p>大脑善于适应变化的环境。因此，要定期改变环境，满足你的大脑。任何一种感官的参与都可能是有益的。（当年还强迫自己不间断的工作，既累又不讨好>&lt;…）</p></li>
<li><p>在学习技能时，可以用 R 型探路，掌握全局，而后用 L 型紧跟，两者配合好。（举例参见读书的 SQ3R 方法）</p></li>
<li><p>隐喻是一种激发创造力的强大技能，它能很好的沟通好 L 和 R 型处理能力。幽默感正是这种从不同的想法中创造新奇的联系的方式，幽默感可以建立更强大的隐喻。</p></li>
<li><p>大脑在处理不同的输入时，差别并不大。记忆不是永远不变的，每次提取记忆，也会重构记忆。我们可以通过提供给自己有益的暗示，来促进自身进步。</p></li>
<li><p>一切输入都会被存储。如果被存储的事物之间有好的区分度， 那就更容易在查询时被检索到。举个编程的例子，源代码的阅读次数远远多于它的编写次数，所以通常应该花更多功夫把代码变得适合阅读，让代码风格和注释更易于阅读，会事半功倍。</p></li>
<li><p>晨写和无目的的散步这种方式，能活跃右脑，增加 R 型工作的机会。</p></li>
</ul>


<h2>调试大脑</h2>

<p>大脑有一些固有的偏见，比如自以为是。我们需要对这些点予以关注。</p>

<ul>
<li><p>每个人个性倾向不同，处理事儿的方式也不相同。（推荐 <a href="http://www.apesk.com/mbti/">MBTI 测试</a>，这里是我的<a href="http://biaobiaoqi.me/blog/2013/05/12/mbti-test/">测试结果</a>。）</p></li>
<li><p>重要的是要认识到：在某种情况下，别人的反应行为和你所设想的不一样时，他们并不是疯了、懒惰或者非常难以相处。你也不是。</p></li>
<li><p>遇到问题，深呼吸，包托变味的空气。深深吸气。数到十。记住你是高级动物。让蜥蜴式的相应过去，请新大脑皮层来处理问题。</p></li>
<li><p>既然性格和技能水平各异，可能奖励措施也应该各式各样才对。否则奖励反而让获奖人感到不自在。</p></li>
<li><p>大脑会偷懒，很多时候，我们的看法是基于预测的。</p></li>
</ul>


<h2>主动学习</h2>

<h5>SMART 方法</h5>

<p>学习过程中，使用目标激励的方式会很有效（早年自己没目标，还老找借口说没目标自己也会不断努力的…汗颜）遵循 SMART 方法（这么多条，没必要全记住，核心就在用目标激励前进）：</p>

<ul>
<li>Specific：将目标具体化</li>
<li>Measurable：让目标能度量</li>
<li>Achievable：目标不能是空想，要能够实现</li>
<li>Relevant：要与自己足够相关，才能更大化其效益</li>
<li>Time-boxed：时间上可控，有最后期限</li>
</ul>


<h5>学习方式分类</h5>

<p>每个人对学习方式的敏感度不一样，学习者分三类：</p>

<ul>
<li>视觉型：需要看到学习资料和老师，对图片，图表，老师的肢体语言和面部表情敏感。</li>
<li>听觉型：需要听到学习材料，对讲座、研讨会、播客敏感</li>
<li>动觉型：通过活动和触摸来学习，需要亲身感受来学习材料</li>
</ul>


<p>每个人都有自己的默认属性，比如倾向于视觉型或者其他。有时候，尝试不同的学习类型，或许会带来灵感。</p>

<h5>SQ3R</h5>

<p>书面指令的传递一般是最无效的，大脑处理语言相关部分很小，除此以外，大脑整个剩余部分都不懂语言。常规的阅读方式效率很低，这里推荐一种主动阅读方式，大家可以按需参考。</p>

<p>SQ3R 主动看书法：</p>

<ul>
<li><ol>
<li>调查（Survey）：扫描目录和每章总结，得出总体看法。</li>
</ol>
</li>
<li><ol>
<li>问题（Question）：记录所有问题</li>
</ol>
</li>
<li><ol>
<li>阅读（Read）：阅读内容</li>
</ol>
</li>
<li><ol>
<li>复述（Recite）：总结</li>
</ol>
</li>
<li><ol>
<li>回顾（Review）：重读，拓展笔记，与同事讨论。</li>
</ol>
</li>
</ul>


<h5>思维导图</h5>

<p>思维导图是一种图表，显示各个主题和它们之间的关系。</p>

<ul>
<li><p>思维导图的颜色信息、形状信息大大增加了表达的丰富性，让人更容易接受，易于理解。</p></li>
<li><p>多次迭代思维导图图，可以充分利用起 R 型的思维。</p></li>
<li><p>当陷入没有明确思路的混沌状态时，思维导图有助于理清思路，指引方向。</p></li>
<li><p>另外，跟思维导图一样，记录文档也是不错的选择。或许文档不会有人看，但记录的过程，能促进思考。</p></li>
</ul>


<h2>经验</h2>

<ul>
<li><p>在最后期限面前，对 L 型活动可能有激励，但对 R 型活动是一种灾难。压力扼杀了认知。</p></li>
<li><p>我们是天生的模仿者，如果身边的人技能水平高，那么我们一般会潜移默化的向他们学习，继而提高自身水平。</p></li>
<li><p>语言描述不是一个最好的教学方式。人脑只有很少计算资源在做语言处理。用更多形象的，比如声音、图形、动过可以更好的促进学习。</p></li>
</ul>


<h2>注意力</h2>

<p>保持注意力的三点：</p>

<ul>
<li>1.学会安抚喋喋不休的 L 型思维。</li>
<li>2.主动在前进中思考和增强思想，即使是不成熟的。</li>
<li>3.明确情景切换的昂贵代价，尽可能避免。</li>
</ul>


<p>注意力修炼：冥想</p>

<ul>
<li>寻找一个安静的地方，舒适、清醒的坐着，挺直背</li>
<li>闭上眼睛，集中注意力到呼吸上</li>
<li>注意呼吸节奏，不要试图改变它，只是感觉。不要与自己交谈。每当发现自己在思考一些问题或与自己交谈，及时抛弃这些想法，轻轻将注意力回到呼吸上。</li>
</ul>


<p>查邮件等会打扰工作状态，这种打扰，会让之后的二十分钟甚至更长无法进入工作状态。这是一种情景切换，大脑不善于情景切换。</p>

<h2>超越专家</h2>

<p>做到有效的改变很难。以前的习惯依然存在在大脑里。当回到某个旧习惯时，不用懊恼。承认它，大脑就是这样工作的。当意识到它的出现时，重新回到正确的道路上去。</p>

<p>即使成为专家，也要意识到局限性：可能创新不足，过于相信意识等。</p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/05/22/pragmatic-thinking-and-learning-refactor-your-wetware/'>http://biaobiaoqi.github.com/blog/2013/05/22/pragmatic-thinking-and-learning-refactor-your-wetware/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《Facebook效应》]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/05/21/the-facebook-effect/"/>
    <updated>2013-05-21T00:23:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/05/21/the-facebook-effect</id>
    <content type="html"><![CDATA[<p>前两年风靡了一阵子的电影《社交网络》毕竟是电影，一种艺术的方式的表达。虽然无法完全的印证《Facebook 效应》一书中记载的正确性，但其细节足以给人启示。</p>

<p>电影中，主人公炫酷的人生经历能催生观者产生极强的代入感，不少同学看后可能就会想着自己在寝室特立独行的捣鼓几下，也来做出个震惊世界的产品。且慢。细读本书，就会了解到，成功并非像电影中所描述的那么轻松愉快和力所能及。</p>

<p>以下是我的一些总结。</p>

<!--more-->


<h2>团队</h2>

<p>先来看看扎克伯格的经历。</p>

<blockquote><p>“他几乎赢得了在高中时期能得到的所有荣誉和奖项，获奖科目中有数学、天文学、物理学甚至是古典文学，还是击剑队队长和最有价值队员，能读写发育、希伯来语、拉丁语和古希腊语”</p>

<p>“扎克伯格就读的飞利浦爱思特中学是一所精英云集的高中，哪里的学生能进入常春藤联盟的任何一所高等学府”</p>

<p>“扎克伯格不断创造出一些在网上运行的小程序，其中又一个能帮助他快速强记‘高古斯都时代的艺术’的考试内容”</p>

<p>“扎克伯格如今这样说，‘那一年我做了 12 个项目。当然，那个项目都不是我全权负责的‘，他说，大多数都是关于’发现人们如何通过相互参照建立联系‘’”。</p></blockquote>

<p>而之后的 TheFacebook，也并非一蹴而就的发展为如今的 Facebook，它的想法来自于当时常春藤名校之间关于在线花名册、照片的需求以及对社交、分享的一直以来的思考，而非电影中几杯啤酒、几个小时的 facemesh。实际上，扎克伯格也并非孤注一掷。一直到 2004 年夏天之前，他还只是将飞速发展的 Facebook 当做自己经手的一个项目，以规避自己所投入中存在的风险，他同时又与另一个天才程序员合作了另外一个项目 wirehog，甚至为它成立了公司，直到试运行失败后才收手。</p>

<p>另外，扎克伯格的各路圈子的朋友中不乏 IT 界精英，他们有着高智商，良好的教育背景或者传奇的过往经历和远大理想。他们可能在中学时就已经写出影响行业圈的软件，可能有各行业经营公司的职业背景、经历，可能精通文史、商业哲学。记得以前被老师告知了一句话，“一个人的收入约等于最亲密的六个朋友的收入的平均值”。可能扎克伯格做不到这一点了，他会是最高的吧=。=</p>

<h2>扎克伯格的性格</h2>

<ul>
<li>冷静、不善公开与人对抗</li>
</ul>


<p>成功者都是偏执的。扎克伯格不易动感情，热切他很少显露出情绪。这种表面平和的独特个人魅力，是他吸引人才投靠他的一个关键因素，同时也使人们对他恼火的一重要原因。</p>

<ul>
<li>扎克伯格善于听取各方面意见，然后做出自己的结论</li>
</ul>


<p>在 Facebook 发展到 06 年时，扎克伯格的角色开始发生变化，但他似乎没有控制好这个变化。在前期为他招揽人才的罗宾说“公司高管们的士气正在跌落，流言满天飞，而马克没有对任何人说明真正发生着什么。管理团队几乎准备要把扎克伯格拉下马”。这引起了罗宾的不满。扎克伯格对待罗宾的指责时，并没有抵触，而是欣然接受。这种气魄是他对产品本身追求大过对虚荣的提现。他善于倾听，吸取意见。他顺利的转变了 CEO 的角色。</p>

<ul>
<li>理想远大，目标明确</li>
</ul>


<p>他对 Facebook 的决策，从来都是为了让它在之后成为更伟大的产品，而不是为了一时的利益。因此一直以来都排斥一般形式的广告。他也一直坚持着对公司的控制权，让一切在他的掌握之下。</p>

<ul>
<li>坚韧</li>
</ul>


<p>大部分人会给自己设定里程碑，达到里程碑后，会稍作休息，从而获得征服感和满足感。扎克伯格不会。这大概是他的天赋吧。正常人就不要效仿了，反而会拖垮效率的。</p>

<h2>产品的演变</h2>

<p>Facebook 的发展过程中，并非是一直特立独行。与此同时的互联网世界，在社交范围内的公司也是层出不穷，不乏竞争对手。但经过不断的产品迭代创新，Facebook 达到了目前的高度。</p>

<ul>
<li>1.图片分享</li>
</ul>


<p>曾在 Facebook 上尝试 wirehog，一个多媒体分享工具，没有成功。之后，当发现用户对更换主页图片感兴趣后，Facebook 准备开发新的图片分享功能。而为了与挖掘出社交的能力，考虑到了以图片中的人名来设置标签，并相应的给标记的人发送消息通知。这是扎克伯格的理想中重要的一环，他以越来越广泛的理论来阐释了社交的意义。</p>

<ul>
<li>2.动态新闻</li>
</ul>


<p> 创造的是一种订阅朋友信息的方式，先例是 RSS（简易信息聚合）。</p>

<ul>
<li>3.开发注册到所有用户</li>
</ul>


<p>经过对全社会开发注册和动态新闻的两件事情的领导之后，扎克伯格作为一个领袖的声望在 Facebook 腾云直上。</p>

<ul>
<li>4.应用平台。</li>
</ul>


<p>成为其他应用程序在上面运行的软件平台是软件技术一行最为光荣的终极目标。Facebook 有着自传播力，这是平台的优势。</p>

<ul>
<li>5.定制式的广告系统</li>
</ul>


<p>精准的广告。相比 Google 按需求搜索广告，Facebook 则是希望利用人际关系网，为用户产生需求，让用户找到自己所想要的东西。桑德伯格的到来，让 Facebook 建立起了合理的商业模式。</p>

<ul>
<li>6.翻译</li>
</ul>


<p>利用用户产生翻译内容的自动化翻译工具。在世界扩张。</p>

<ul>
<li>7.Facebook 联谊会</li>
</ul>


<p>授权其他网站调用 Facebook 的资料等</p>

<ul>
<li>8.twitter 迅速发展</li>
</ul>


<p>twitter 迅速发展对 Facebook 形成了压力。Facebook 为此进行了改版。改版被不少用户反对，扎克伯格提出了公平投票的方式来决定。他把用户视作公民。</p>

<ul>
<li>9.开放信息流 API。</li>
</ul>


<p>Facebook 不怕流量因此被分流，他们希望 Facebook 成为一个基础架构。</p>

<h2>初期发展</h2>

<p>初期发展中，Facebook 的团队也会犯严重的错误，比如源代码被开放给所有用户，比如广告导引错误。但相信那种自由状态下的发展，是足够<strong>高效</strong>的。</p>

<blockquote><p>马克安德森支持扎克伯格：“一个快速成长的公司，是没有办法可以一直做出正确的决定的。更好的办法是，快速修正不可避免的错误决定。”</p></blockquote>

<p>虽然王淮描述工程师文化时说道，需要重复两遍以上的事儿，Facebook 都会开发出工具去自动化的实现。个人推论，这更多的是在公司获得千万投资，开始扩招员工以后的事情。在初期的发展阶段，即使是牛逼如扎克伯格、莫斯科为茨的人，也被快速发展的步伐所牵制。而当员工数量达到一定规模，有了足够多的人才后，才开始逐步形成了现在的 Facebook 的工程师文化。</p>

<h2>市场</h2>

<p>大学生市场是一块宝地。</p>

<p>大学生们不看电视，不看报纸，而他们将迎来第一张信用卡，第一个银行账户等等。名校更是拥有强大的号召力，优越感。早期 Facebook 发展时，没有对外开放，将各个学校一一增加到可注册用户范围内，用一种自己可以把控的节奏，维持了发展的平衡。避免了飞速发展带来的服务器端的巨大压力。</p>

<h2>Facebook 的定位</h2>

<p>社交需求的理论基础是馈赠型经济。更多介绍，参见<a href="http://biaobiaoqi.me/blog/2013/05/13/free-the-bit-economics/">《免费》中关于非货币市场章节描述</a></p>

<p>扎克伯格的梦想是赋予每个人权利，对于他自己来说，Facebook 能解决的最重要的问题就是给人们提供工具，让他们更好的交流。</p>

<p>Facebook 建立在一个激进的社会假说下，即认为现代社会在不可避免的逐步超公开透明的方向发展。扎克伯格说“这个世界的透明程度将不会再允许一个人拥有双重身份。换句话说，即使你希望把私生活和职场分开，你也不可能做到，因为关于你的信息正在互联网和其他各个地方传播。”</p>

<p>Facebook 希望最终成为一个基础架构。Facebook 只是其用户集体行动的表征，除此之外，它什么都不是，Facebook 上会发生什么完全取决于用户兴趣所在。但扎克伯格对无聊的应用感到失望，那确实很多用户的真实需求。</p>

<p>Facebook 不是浪费时间，而是帮助人们理解他们身边的世界。扎克伯格不希望人们太粘 Facebook，希望他们多花时间去找朋友，与他人交流互动。<em>所以 Facebook 的界面是中性的，没有表现出态度</em>。</p>

<p>有管理学家如是评价“历史上只有两个基本方法去集中和扩散人们的才能，它们就是<em>官阶体制</em>和<em>市场</em>。而在最近十年，增加了第三个——网络，他让我们能够协同工作对付一些棘手的问题，但也削弱了掌权者的力量，通常只有掌权者可以决定谁可以知道什么。”</p>

<h2>Facebook vs  Google：</h2>

<ul>
<li>Google 是针对于数据的，认为整合全世界的数据是最重要的事情，而 Facebook 是针对于人的。</li>
<li>Google 会收集到所有数据，而 Facebook 是在用户乐于分享的前提下，自己上传数据</li>
<li>Google：不作恶；Facebook ：别因为赚钱而做差劲的事儿。</li>
</ul>


<h2>争议：</h2>

<ul>
<li><p>在可靠的控制个人信息的愿望与不经意间的社会沟通之间，很可能存在着不可协调的矛盾。</p></li>
<li><p>Facebook 应该鼓励用户纰漏多少个人信息。有关这个话题的讨论一直贯穿了公司的整个发展历程。</p></li>
<li><p>身份识别系统可能妨碍公民的自由。</p></li>
<li><p>Facebook 为何有权利拥有大家的真实身份。</p></li>
<li><p>当 Facebook 打通了支付渠道，成为一个全球化的经济体，银行不高兴了</p></li>
</ul>


<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/05/21/the-facebook-effect/'>http://biaobiaoqi.github.com/blog/2013/05/21/the-facebook-effect/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
</feed>
