<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Biaobiaoqi的博客]]></title>
  <link href="http://biaobiaoqi.github.com/atom.xml" rel="self"/>
  <link href="http://biaobiaoqi.github.com/"/>
  <updated>2013-09-08T20:55:17+08:00</updated>
  <id>http://biaobiaoqi.github.com/</id>
  <author>
    <name><![CDATA[Biaobiaoqi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[对Java字符串的探究]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/09/08/string-interning/"/>
    <updated>2013-09-08T13:01:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/09/08/string-interning</id>
    <content type="html"><![CDATA[<h2>问题的出发点</h2>

<p>在网上看到一道题：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">String</span> <span class="n">str</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">&quot;abc&quot;</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>以上代码执行过程中生成了多少个 String 对象？</p>

<p>答案写的是两个。&#8221;abc&#8221;本身是一个，而 new 又生成了一个。</p>

<h2>&#8220;abc&#8221;是什么</h2>

<p>查看这句程序的字节码，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">NEW</span> <span class="n">String</span>
</span><span class='line'>    <span class="n">DUP</span>
</span><span class='line'>    <span class="n">LDC</span> <span class="s">&quot;abc&quot;</span>
</span><span class='line'>    <span class="n">INVOKESPECIAL</span> <span class="n">String</span><span class="o">.&lt;</span><span class="n">init</span><span class="o">&gt;(</span><span class="n">String</span><span class="o">)</span> <span class="o">:</span> <span class="kt">void</span>
</span><span class='line'>    <span class="n">ASTORE</span> <span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure>


<p>指令<code>ldc indexbyte</code>的含义：将两字节的值从 indexbyte 索引的常量池中的项中推到方法栈上。</p>

<p>指令<code>LDC "abc"</code>说明了&#8221;abc&#8221;并不是直接以对象存在的，而是存在于常量池的索引中。String 的构造函数调用命令实际使用的就是 String 类型作为参数，那么，栈上应该有一个 String 类型的索引。</p>

<p>由此我们得出，在字节码中，ldc 命令在常量池中找到了能索引到“abc”那个 String 对象的索引值。</p>

<h2>常量池</h2>

<p>常量池是类文件（.class）文件中的一部分，记录了许多常量信息，索引的字符串信息。</p>

<p>由于 Java 是动态加载的，类文件并没有包含程序运行时的内存布局，方法调用等无法直接记录出方法的物理位置，常量池通过索引的方法解决了这个问题。</p>

<!--more-->


<p>常量池中存着许多表，其中 Constant_Utf8_info 表中，记录着会被初始化为 String 对象的字符串的字面值（iteral）。
而在 String 的 java doc 中，有对 String 字面值的说明：</p>

<blockquote><p>All string literals in Java programs, such as &#8220;abc&#8221;, are implemented as instances of this class.</p></blockquote>

<p>在 Java 编译的过程中，确定下来的 String 字面值都先被优化记录在常量池中（那些双引号字符串，都是以 CONSTANT_utf8_info 的形式存储在常量池中的）。也就是说，Java 源代码文件中出现的那些诸如&#8221;abc&#8221;字符串，都已经被提前放在了常量池中。</p>

<p>可以使用如下代码验证这一点：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Program</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>       <span class="n">String</span> <span class="n">str1</span> <span class="o">=</span> <span class="s">&quot;Hello&quot;</span><span class="o">;</span>
</span><span class='line'>       <span class="n">String</span> <span class="n">str2</span> <span class="o">=</span> <span class="s">&quot;Hello&quot;</span><span class="o">;</span>
</span><span class='line'>       <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">str1</span> <span class="o">==</span> <span class="n">str2</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出结果是 true.说明&#8221;Hello&#8221;作为对象是被程序从同一个内存空间读取出来的。</p>

<p>常量池是编译时产生的，存在于类文件中（*.class 文件）。运行时，JVM 中每个对象都拥有自己的运行时常量池（run time constant pool）。</p>

<h2>字符串池</h2>

<p>我在 String 的 java doc 中又发现了一个有趣的 method：intern() ,我翻译如下：</p>

<blockquote><p>当 intern 方法被调用，如果池中已经拥有一个与该 String 的字符串值相等（即 equals()调用后为 true）的 String 对象时，那么池中的那个 String 对象会被返回。否则，池中会增加这个对象，并返回当前这个 String 对象。</p></blockquote>

<p>其中有介绍一个字符串池的东西：字符串池（String pool），初始是空的，由类私有的控制。</p>

<p>查看 java.lang.String 的源代码，发现 Intern()方法是一个 native 方法，即本地实现的方法，而不是一个 java 方法，这让我们不能直观的看到字符串池的实现细节。不过能够理解字符串池其实是类似于线程池的缓冲器，可以起到节约内存的作用。如下代码可以验证</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kn">package</span> <span class="n">biaobiaoqi</span><span class="o">.</span><span class="na">thinkingInJava</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">String</span> <span class="n">strA1</span> <span class="o">=</span> <span class="s">&quot;ab&quot;</span><span class="o">;</span>
</span><span class='line'>        <span class="n">String</span> <span class="n">strA2</span> <span class="o">=</span> <span class="s">&quot;c&quot;</span><span class="o">;</span>
</span><span class='line'>        <span class="n">String</span> <span class="n">strB1</span> <span class="o">=</span> <span class="s">&quot;a&quot;</span><span class="o">;</span>
</span><span class='line'>        <span class="n">String</span> <span class="n">strB2</span> <span class="o">=</span> <span class="s">&quot;bc&quot;</span> <span class="o">;</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">((</span><span class="n">strA1</span><span class="o">+</span><span class="n">strA2</span><span class="o">).</span><span class="na">intern</span><span class="o">()</span> <span class="o">==</span> <span class="o">(</span><span class="n">strB1</span> <span class="o">+</span> <span class="n">strB2</span><span class="o">).</span><span class="na">intern</span><span class="o">());</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出结果为 true。</p>

<p>现代的 JVM 实现里，考虑到垃圾回收（Garbage Collection）的方便，将 <a href="http://en.wikipedia.org/wiki/Java_Virtual_Machine#Heap">heap</a> 划分为三部分： young generation 、 tenured generation（old generation）和 permanent generation( permgen )</p>

<p>字符串池是为了解决字符串重复的问题，生命周期长，它存在于 permgen 中。</p>

<h2>总结</h2>

<p>编译 Java 源代码时，源文件中出现的双引号内的字符串都被收纳到常量池中，用 CONSTANT_utf8_info 项存储着。</p>

<p>JVM 中，相应的类被加载运行后，常量池对应的映射到 JVM 的运行时常量池中。其中每项 CONSTANT_utf8_info（也就试记录那些字符串的）都会在常量引用解析时，自动生成相应的 internal String，记录在字符串池中。</p>

<p>回过头来看看文章刚开始的那个问题。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">String</span> <span class="n">str</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">&quot;abc&quot;</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里确实是有两个 String 对象生成了。</p>

<p><code>new String("xxx")</code> 创建的 String 对象会在 heap 中重新生成新的 String 对象，绕过字符串池的管辖。而如果使用<code>String str = "xxx"</code>则先查看字符串池 是否已经存在，存在则直接返回 PermGen 中的该 String 对象，否则生成新的 String 对象，并将它加入字符串池中。</p>

<blockquote><p>尽量使用<code>String str = "abc";</code>，而不是<code>String str = new String("abc")；</code>用 new 的方法肯定会开辟新的 heap 空间，而前者的方法，则会通过 string interning 优化。</p></blockquote>

<h3>参考资料</h3>

<ul>
<li><a href="http://www.codeinstructions.com/2009/01/busting-javalangstringintern-myths.html">Busting java.lang.String.intern() Myths</a></li>
<li><a href="http://book.douban.com/subject/1788390/">Inside the JAVA2 virtual machine</a></li>
<li><a href="http://book.douban.com/subject/1610251/">Programming for the java virtual machine</a></li>
<li><a href="http://www.xyzws.com/Javafaq/what-is-string-literal-pool/3">What is String literal pool? How to create a String</a></li>
<li><a href="http://stackoverflow.com/questions/4918399/what-type-of-memory-heap-or-stack-string-constant-pool-in-java-gets-stored">What type of memory (Heap or Stack) String constant pool in Java gets stored?</a></li>
</ul>


<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/09/08/string-interning/'>http://biaobiaoqi.github.com/blog/2013/09/08/string-interning/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOP实践：java.lang.instrument的使用]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/09/08/custom-premain-method/"/>
    <updated>2013-09-08T13:01:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/09/08/custom-premain-method</id>
    <content type="html"><![CDATA[<h2>背景</h2>

<p>在 <a href="https://github.com/biaobiaoqi/rcjp">rcjp</a> 项目中，需要调用 ASM API（用于字节码处理的开源库）对字节码进行处理，目标是实现对 Java 程序运行时各种对象的动态跟踪，并进一步分析各个对象之间的关系。在此之前，需要考虑如何获取程序运行的入口。</p>

<p>首先，我考虑到了自定义类加载器（详情见参考资料），即在程序的 main 入口处，首先加载自定义的类加载器，然后通过反射技术使用这个类加载器加载并调用测试程序。这个方法缺点是：每次都必须先找到测试程序的入口类，而对于有的封装成 jar 的程序集合，这一点相对比较难控制。</p>

<p>于是，有了这里介绍的方法：通过 <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/instrument/package-summary.html">java.lang.instrument</a> 实现的 java agent 对象操作字节码，是一种 <a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">AOP</a> 的方法。</p>

<p>程序中，除了 ASMAgent 以外的所有类都是调用 ASM API 实现对测试程序中各个对象的构造、方法调用、属性赋值等操作行为的记录（其中对 Collection 子类的处理着实费了一番心血= =，字节码操作很细节，容易出错）。</p>

<!--more-->


<h2>原理</h2>

<p><a href="http://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html#N100A7">JVMTI（Java Virtual Machine Tool Interface）</a>是一套本地编程接口集合，它提供了一套『代理』机制，可以支持第三方工具程序以代理的方式连接和访问 JVM，并利用 JVMTI 提供的丰富的编程接口，完成很多跟 JVM 相关的功能。</p>

<p>java.lang.instrument 包的实现，也就是基于这种机制的：在 Instrumentation 的实现当中，存在一个 JVMTI 的代理程序，通过调用 JVMTI 当中 Java 类相关的函数来完成 Java 类的动态操作。</p>

<p>Instrumentation 的最大作用就是类定义的动态改变和操作。在 Java SE 5 及其后续版本当中，开发者可以在一个普通 Java 程序（带有 main 函数的 Java 类）运行时，通过 – javaagent 参数指定一个特定的 jar 文件（包含 Instrumentation 代理）来启动 Instrumentation 的代理程序。</p>

<h2>步骤</h2>

<h3>1.编写 java 代理类</h3>

<p>这个类中，premain 方法是关键，对比于一般的入口 main 一样，这里的 premain 是在 main 之前执行的。它会告诉 JVM 如何处理加载上来的 java 字节码。如下例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">premain</span><span class="o">(</span><span class="n">String</span> <span class="n">agentArgs</span><span class="o">,</span> <span class="n">Instrumentation</span> <span class="n">inst</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">Trace</span><span class="o">.</span><span class="na">BeginTrace</span><span class="o">();</span> <span class="c1">// it&#39;s important for trace files  </span>
</span><span class='line'>            <span class="n">inst</span><span class="o">.</span><span class="na">addTransformer</span><span class="o">(</span><span class="k">new</span> <span class="n">ASMAgent</span><span class="o">());</span>
</span><span class='line'>        <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>值得注意的是，addTransformer 实现了对字节码处理的方法的回调。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">inst</span><span class="o">.</span><span class="na">addTransformer</span><span class="o">(</span><span class="k">new</span> <span class="n">ASMAgent</span><span class="o">());</span>
</span></code></pre></td></tr></table></div></figure>


<p>类 ASMAgent 包含着实现对 java 字节码处理的方法：transform()。它来自于 ClassFileTransformer 接口。为了方便，这里将对 ClassFileTransformer 接口的实现跟 ASMAgent 类放在了一起。其中 classfileBuffer 是类文件加载时的原始的字节码，retVal 则是经过处理后的字节码。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">transform</span><span class="o">(</span><span class="n">ClassLoader</span> <span class="n">loader</span><span class="o">,</span> <span class="n">String</span> <span class="n">className</span><span class="o">,</span><span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">classBeingRedefined</span><span class="o">,</span>
</span><span class='line'>                                        <span class="n">ProtectionDomain</span> <span class="n">protectionDomain</span><span class="o">,</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">classfileBuffer</span><span class="o">)</span>
</span><span class='line'>            <span class="kd">throws</span> <span class="n">IllegalClassFormatException</span> <span class="o">{</span>
</span><span class='line'>            <span class="kt">byte</span><span class="o">[]</span> <span class="n">retVal</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span><span class="o">(</span><span class="n">isInstrumentable</span><span class="o">(</span><span class="n">className</span><span class="o">)){</span>
</span><span class='line'>                <span class="n">ClassWriter</span> <span class="n">cw</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ClassWriter</span><span class="o">(</span><span class="n">ClassWriter</span><span class="o">.</span><span class="na">COMPUTE_FRAMES</span><span class="o">);</span>
</span><span class='line'>                <span class="n">ASMClassAdapter</span> <span class="n">mca</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ASMClassAdapter</span><span class="o">(</span><span class="n">cw</span><span class="o">);</span>
</span><span class='line'>                <span class="n">ClassReader</span> <span class="n">cr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ClassReader</span><span class="o">(</span><span class="n">classfileBuffer</span><span class="o">);</span>
</span><span class='line'>                <span class="n">cr</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">mca</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
</span><span class='line'>                <span class="n">retVal</span> <span class="o">=</span> <span class="n">cw</span><span class="o">.</span><span class="na">toByteArray</span><span class="o">();</span>
</span><span class='line'>            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
</span><span class='line'>                    <span class="n">retVal</span> <span class="o">=</span> <span class="n">classfileBuffer</span> <span class="o">;</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">return</span> <span class="n">retVal</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>2.打包代理类</h3>

<p>只有合理打包并在 manifest 文件中记录下相应的键值对之后，才能正常执行 premain 的内容。
manifest 文件中需要添加的键值对是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Premain</span><span class="o">-</span><span class="n">Class</span> <span class="o">:</span> <span class="n">biaobiaoqi</span><span class="o">.</span><span class="na">asm</span><span class="o">.</span><span class="na">ASMAgent</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果对字节码的处理有应用到了其他的类，需要在 manifest 中增加路径。比如使用到了 asm-3.0.jar，则增加如下语句：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Class</span><span class="o">-</span><span class="nl">Path:</span> <span class="n">asm</span><span class="o">-</span><span class="mf">3.0</span><span class="o">.</span><span class="na">jar</span>
</span></code></pre></td></tr></table></div></figure>


<h3>3.执行</h3>

<p>执行测试程序时，添加“-javaagent:代理类的 jar[=传入 premain 的参数]”选项。</p>

<p>比如，对于博主的程序，就是</p>

<p><code>java -javaagent:ASMInstrument.jar   -jar XXXX.jar  xxxx</code></p>

<p>其中 ASMInstrument.jar 是第二步中打包的程序，  XXX.jar 是需要测试的程序， xxx 是 XXX.jar 执行时可能的命令行参数。</p>

<p>如果只是执行某.class 文件中的类，我们假设是在当前目录下的一个 XXXX 类，则是：
<code>java -javaagent:ASMInstrument.jar   -cp ./  XXXX xxx</code></p>

<p>其中 xxx 是可能的命令行参数。</p>

<h3>参考资料</h3>

<ul>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html">《Java SE 6 新特性: Instrumentation 新功能》</a></li>
<li><a href="http://biaobiaoqi.me/blog/2013/09/08/java-class-loader-in-practice/">《Java 类加载器编程实践》</a></li>
</ul>


<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/09/08/custom-premain-method/'>http://biaobiaoqi.github.com/blog/2013/09/08/custom-premain-method/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java构造方法中的执行顺序]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/09/08/strange-behavior-using-braces-in-java/"/>
    <updated>2013-09-08T12:58:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/09/08/strange-behavior-using-braces-in-java</id>
    <content type="html"><![CDATA[<p>这道题来自 <a href="http://stackoverflow.com/questions/8185780/strange-behavior-using-braces-in-java/8186881#8186881">stackoverflow</a>。</p>

<h2>问题描述：</h2>

<p>有如下代码，求其输出内容。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
</span><span class='line'>    <span class="n">Test</span><span class="o">(){</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;1&quot;</span><span class="o">);}</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">{</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;2&quot;</span><span class="o">);}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">static</span><span class="o">{</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;3&quot;</span><span class="o">);}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span> <span class="n">args</span><span class="o">[])</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="k">new</span> <span class="nf">Test</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>分析</h2>

<p>作为静态区段的语句，容易知道，3 是会最先出现的。容易弄错的一点是 到底是 1 和 2 的出现顺序。</p>

<p>我们可以参考字节码来分析。在 eclipse 中使用 ASM bytecode 插件，得到相应的字节码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">// class version 50.0 (50)  </span>
</span><span class='line'><span class="c1">// access flags 0x21  </span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
</span><span class='line'>  <span class="c1">// compiled from: Test.java  </span>
</span><span class='line'>  <span class="kd">static</span> <span class="o">&lt;</span><span class="n">clinit</span><span class="o">&gt;()</span> <span class="o">:</span> <span class="kt">void</span>
</span><span class='line'>    <span class="n">GETSTATIC</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span> <span class="o">:</span> <span class="n">PrintStream</span>
</span><span class='line'>    <span class="n">LDC</span> <span class="s">&quot;3&quot;</span>
</span><span class='line'>    <span class="n">INVOKEVIRTUAL</span> <span class="n">PrintStream</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">String</span><span class="o">)</span> <span class="o">:</span> <span class="kt">void</span>
</span><span class='line'>    <span class="n">RETURN</span>
</span><span class='line'>
</span><span class='line'>  <span class="o">&lt;</span><span class="n">init</span><span class="o">&gt;()</span> <span class="o">:</span> <span class="kt">void</span>
</span><span class='line'>    <span class="n">ALOAD</span> <span class="mi">0</span><span class="o">:</span> <span class="k">this</span>
</span><span class='line'>    <span class="n">INVOKESPECIAL</span> <span class="n">Object</span><span class="o">.&lt;</span><span class="n">init</span><span class="o">&gt;()</span> <span class="o">:</span> <span class="kt">void</span>
</span><span class='line'>    <span class="n">ALOAD</span> <span class="mi">0</span><span class="o">:</span> <span class="k">this</span>
</span><span class='line'>    <span class="n">BIPUSH</span> <span class="mi">10</span>
</span><span class='line'>    <span class="n">PUTFIELD</span> <span class="n">Test</span><span class="o">.</span><span class="na">a</span> <span class="o">:</span> <span class="kt">int</span>
</span><span class='line'>    <span class="n">GETSTATIC</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span> <span class="o">:</span> <span class="n">PrintStream</span>
</span><span class='line'>    <span class="n">LDC</span> <span class="s">&quot;2&quot;</span>
</span><span class='line'>    <span class="n">INVOKEVIRTUAL</span> <span class="n">PrintStream</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">String</span><span class="o">)</span> <span class="o">:</span> <span class="kt">void</span>
</span><span class='line'>    <span class="n">GETSTATIC</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span> <span class="o">:</span> <span class="n">PrintStream</span>
</span><span class='line'>    <span class="n">LDC</span> <span class="s">&quot;1&quot;</span>
</span><span class='line'>    <span class="n">INVOKEVIRTUAL</span> <span class="n">PrintStream</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">String</span><span class="o">)</span> <span class="o">:</span> <span class="kt">void</span>
</span><span class='line'>    <span class="n">RETURN</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[])</span> <span class="o">:</span> <span class="kt">void</span>
</span><span class='line'>    <span class="n">NEW</span> <span class="n">Test</span>
</span><span class='line'>    <span class="n">INVOKESPECIAL</span> <span class="n">Test</span><span class="o">.&lt;</span><span class="n">init</span><span class="o">&gt;()</span> <span class="o">:</span> <span class="kt">void</span>
</span><span class='line'>    <span class="n">RETURN</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>正如我们所想，3 是被放在类构造方法中，这是类的初始化函数，固然在类的初始化时出现。</p>

<!--more-->


<p>而在构造方法中先出现 2，之后才是 1。问题的核心集中到对象构造方法的指令顺序问题。实际上，在对象构造方法中，会先执行一些隐性的指令，比如父类的构造方法、{}区段的内容等，然后在执行显性的构造方法中的指令：</p>

<ul>
<li><ol>
<li>Java 编译时，对象构造方法里先嵌入隐式的指令，完毕之后，再执行 Java 源代码中显示的代码。</li>
</ol>
</li>
<li>2.那些隐式的指令，包括父类的构造方法、变量的初始化、{}区段里的内容，并严格按照这个顺序嵌入到对象的构造方法中。</li>
</ul>


<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/09/08/strange-behavior-using-braces-in-java/'>http://biaobiaoqi.github.com/blog/2013/09/08/strange-behavior-using-braces-in-java/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java类的实例化总结]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/09/08/initliate-objects-in-java/"/>
    <updated>2013-09-08T02:03:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/09/08/initliate-objects-in-java</id>
    <content type="html"><![CDATA[<p>java 类的实例化(instantiation)具有显性的和隐性的区别。</p>

<p>写 Java 代码时，我们所使用 new 的方法实例化最简单直接的显性实例化。而隐性的实例化则出现在 java 程序的整个生命周期中，包括 String、Class，StringBuffer 或者 StringBuilder 的实例化等等。</p>

<h2>显性的实例化</h2>

<h3>new 关键字实例化对象</h3>

<p>调用相应的构造函数完成实例化。（类中的非静态成员变量如果有初始化语句，都会被隐式的加入到构造函数中）代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span>  <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">String</span> <span class="n">strA</span> <span class="o">=</span> <span class="s">&quot;xyz&quot;</span><span class="o">;</span>
</span><span class='line'>    <span class="n">String</span> <span class="n">strB</span> <span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">Test</span><span class="o">(</span><span class="n">String</span> <span class="n">str</span><span class="o">){</span>
</span><span class='line'>        <span class="n">strB</span> <span class="o">=</span> <span class="n">str</span> <span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
</span><span class='line'>            <span class="n">Test</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Test</span><span class="o">(</span><span class="s">&quot;abc&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在 eclipse 中装了 <a href="http://asm.ow2.org/">ASM bytecode</a> 插件后，观察.class 文件中的构造函数对应的字节码如下：</p>

<!--more-->


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">INVOKESPECIAL</span> <span class="n">Object</span><span class="o">.&lt;</span><span class="n">init</span><span class="o">&gt;()</span> <span class="o">:</span> <span class="kt">void</span>
</span><span class='line'>   <span class="n">ALOAD</span> <span class="mi">0</span><span class="o">:</span> <span class="k">this</span>
</span><span class='line'>   <span class="n">LDC</span> <span class="s">&quot;xyz&quot;</span>
</span><span class='line'>   <span class="n">PUTFIELD</span> <span class="n">Test</span><span class="o">.</span><span class="na">strA</span> <span class="o">:</span> <span class="n">String</span>
</span><span class='line'>   <span class="n">ALOAD</span> <span class="mi">0</span><span class="o">:</span> <span class="k">this</span>
</span><span class='line'>   <span class="n">ALOAD</span> <span class="mi">1</span><span class="o">:</span> <span class="n">str</span>
</span><span class='line'>   <span class="n">PUTFIELD</span> <span class="n">Test</span><span class="o">.</span><span class="na">strB</span> <span class="o">:</span> <span class="n">String</span>
</span><span class='line'>   <span class="n">RETURN</span>
</span></code></pre></td></tr></table></div></figure>


<p>关键在于<code>LDC"xyz"</code>这条指令，明显可以看出，这是用于 strA 初始化的字符串。</p>

<p>由此我们可以归纳出，在没有调用本类中其他的构造函数的情况下，每次类的构造函数中都会按如下顺序进行：</p>

<ul>
<li>a)隐式（或显性）的调用父类的构造函数</li>
<li>b)然后执行写在构造函数外的成员变量的初始化赋值</li>
<li>c)最后再执行构造函数中的命令。</li>
</ul>


<p>如果是有显性的调用本类其他构造函数（必须是放在构造函数第一步执行），那么对于这个构造函数，处理过程就简单些了：</p>

<ul>
<li>a)调用那个构造函数。</li>
<li>b)执行之后的代码。</li>
</ul>


<h3>利用 java 反射机制</h3>

<p>反射机制是是 java 动态性中的关键之一，调用 java.lang.reflect.Constructor 的 newInstance()方法能创建对象。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span>  <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">Test</span><span class="o">(){</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Created by invoking newInstance()&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">Test</span><span class="o">(</span><span class="n">String</span> <span class="n">str</span><span class="o">){</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>
</span><span class='line'>                    <span class="kd">throws</span> <span class="n">ClassNotFoundException</span> <span class="o">,</span> <span class="n">InstantiationException</span> <span class="o">,</span>
</span><span class='line'>                    <span class="n">IllegalAccessException</span>  <span class="o">{</span>
</span><span class='line'>            <span class="n">Test</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Test</span><span class="o">(</span><span class="s">&quot;Created with new&quot;</span><span class="o">);</span> <span class="c1">//常规的方法  </span>
</span><span class='line'>            <span class="n">Class</span> <span class="n">myClass</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">&quot;Test&quot;</span><span class="o">);</span>  <span class="c1">//获得了对应于 Test 类的 Class 对象，如果没有加载，会先加载这个类，再返回。  </span>
</span><span class='line'>            <span class="n">Test</span> <span class="n">t2</span> <span class="o">=</span> <span class="o">(</span><span class="n">Test</span><span class="o">)</span><span class="n">myClass</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span> <span class="c1">//调用 newInstance()创建对象。  </span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>其他</h3>

<p>其他还有对象的 clone()方法，以及串行化后的解串行化过程。</p>

<h2>隐性的实例化</h2>

<p>隐性的实例化主要有如下几类：</p>

<ul>
<li>1.String 和 String 数组。main(String[] args)中拥有的 args 参数为 String 数组类型，这些 command line 参数将会首先被实例化。</li>
<li>2.Class 的实例化。由于类的加载过程中，会生成相应类的 Class 对象，这些也会被隐性的实例化。</li>
<li>3.JVM 在执行类加载的过程中，对常量池中的 CONSTANT_String_info 项会实例化出对应的 String 对象。这里涉及到常量池解析的知识。</li>
<li>4.在 String 的操作中，可能存在隐性的 StringBuffer 或者 StringBuilder 的实例化。</li>
<li>5.int 和 Integer 这些类型转化过程中的装箱、拆箱。</li>
</ul>


<p>比如如下代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span>  <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
</span><span class='line'>            <span class="n">String</span> <span class="n">str1</span> <span class="o">=</span> <span class="s">&quot;abc&quot;</span><span class="o">;</span>
</span><span class='line'>            <span class="n">String</span> <span class="n">str2</span> <span class="o">=</span> <span class="s">&quot;def&quot;</span><span class="o">;</span>
</span><span class='line'>            <span class="n">String</span> <span class="n">str</span> <span class="o">=</span> <span class="n">str1</span> <span class="o">+</span> <span class="n">str2</span> <span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在 eclipse 中装了 ASM bytecode 插件后，直接观察.class 文件对应的字节码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">NEW</span> <span class="n">StringBuilder</span>
</span><span class='line'>    <span class="n">DUP</span>
</span><span class='line'>    <span class="n">ALOAD</span> <span class="mi">1</span><span class="o">:</span> <span class="n">str1</span>
</span><span class='line'>    <span class="n">INVOKESTATIC</span> <span class="n">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">Object</span><span class="o">)</span> <span class="o">:</span> <span class="n">String</span>
</span><span class='line'>    <span class="n">INVOKESPECIAL</span> <span class="n">StringBuilder</span><span class="o">.&lt;</span><span class="n">init</span><span class="o">&gt;(</span><span class="n">String</span><span class="o">)</span> <span class="o">:</span> <span class="kt">void</span>
</span><span class='line'>    <span class="n">ALOAD</span> <span class="mi">2</span><span class="o">:</span> <span class="n">str2</span>
</span><span class='line'>    <span class="n">INVOKEVIRTUAL</span> <span class="n">StringBuilder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">String</span><span class="o">)</span> <span class="o">:</span> <span class="n">StringBuilder</span>
</span><span class='line'>    <span class="n">INVOKEVIRTUAL</span> <span class="n">StringBuilder</span><span class="o">.</span><span class="na">toString</span><span class="o">()</span> <span class="o">:</span> <span class="n">String</span>
</span><span class='line'>    <span class="n">ASTORE</span> <span class="mi">3</span>
</span></code></pre></td></tr></table></div></figure>


<p>实际上，这里 str1 和 str2 合并的过程，是使用了 StringBuilder 来间接完成的，首先以 str1 的值构造一个 StringBuilder，然后调用其中的 append()方法，将 str2 串联上来。</p>

<p>值得注意的是：老版本的 java 使用 StringBuffer 完成这一步，但 StringBuffer 是线程安全的，效率略低，于是在新版本 java 中出现了非线程安全的 StringBuilder，这类似于 Hashtable 和 hashset 的关系。<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/09/08/initliate-objects-in-java/'>http://biaobiaoqi.github.com/blog/2013/09/08/initliate-objects-in-java/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java类加载的延迟初始化]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/09/08/late-initialising-in-java/"/>
    <updated>2013-09-08T02:00:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/09/08/late-initialising-in-java</id>
    <content type="html"><![CDATA[<p><a href="http://biaobiaoqi.me/blog/2013/09/08/java-class-loading-linking-and-initialising/">《Java 类的装载、链接和初始化》</a>中提到，链接的最后一步是解析，即对符号引用的解析。但这不是必须的，可以等到相应的符号引用第一次使用时再解析。</p>

<p>而类的初始化是在链接之后的（注意了，根据不同 JVM 有不同的实现方式，在类初始化的时候，可能已经完成了所有的符号引用的解析，也可能没有），本文所写的就是类的初始化的时机问题。</p>

<p>Java 类的动态加载机制规定，在类被主动使用(active use)之前，必须已经完成类的初始化。既然有主动调用，那么就有被动调用了。这两者有哪些区别呢？</p>

<p>下面列出所有主动使用的情况，用以区分两者：</p>

<ul>
<li>1.创造该类的一个新的实例</li>
<li>2.调用这个类中的静态方法</li>
<li>3.获取类或者接口中的非常量的静态变量</li>
<li>4.利用反射调用方法</li>
<li>5.初始化该类的某子类</li>
<li>6.被制定为 JVM 开始运行时必须初始化的类</li>
</ul>


<p>注意，3 中为何是“非常量的静态变量”。如果是常量，即声明为 final 的话，并不会出现对类的构造，虽然调用时有类名出现，但实际调用会直接使用常量，绕过了类的限制（详情见相关常量池和运行时常量池的知识）。</p>

<p>只有当一个非常量的静态变量被显示的在类或接口中声明时，它的调用才属于主动调用。对于父类中某非常量静态变量的调用属于被动使用(positive use)。</p>

<!--more-->


<p>如下代码</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Parent</span> <span class="o">{</span>
</span><span class='line'>     <span class="kd">static</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">;</span>
</span><span class='line'>
</span><span class='line'>     <span class="kd">static</span><span class="o">{</span>
</span><span class='line'>            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Parent initiate&quot;</span><span class="o">);</span>
</span><span class='line'>     <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>     <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">func</span><span class="o">(){</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;func&quot;</span><span class="o">);</span>
</span><span class='line'>     <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Son</span> <span class="kd">extends</span> <span class="n">Parent</span><span class="o">{</span>
</span><span class='line'>    <span class="kd">static</span><span class="o">{</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Son initiate&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">static</span><span class="o">{</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Test initiate&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Son</span><span class="o">.</span><span class="na">i</span><span class="o">);</span>
</span><span class='line'>        <span class="n">Son</span><span class="o">.</span><span class="na">func</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>运行的结果是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Test</span> <span class="n">initiate</span>
</span><span class='line'><span class="n">Parent</span> <span class="n">initiate</span>
</span><span class='line'><span class="mi">10</span>
</span><span class='line'><span class="n">func</span>
</span></code></pre></td></tr></table></div></figure>


<p>虽然有出现 Son，但 Son.i 访问的是父类的非常量静态变量。于是没有对 Son 类进行初始化，而只是初始化了明确的声明静态变量的 Parent 类。</p>

<p>由此可见，一般的，我们在某个类中定义了其他类的成员变量引用，只要该变量没有 new 出一个新的对象，则 JVM 也不会初始化这个类，类此时只是被加载了而已，而没有链接和初始化。<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/09/08/late-initialising-in-java/'>http://biaobiaoqi.github.com/blog/2013/09/08/late-initialising-in-java/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[类加载器操作三原则[译]]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/09/08/three-principles-of-classloader-operation/"/>
    <updated>2013-09-08T00:42:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/09/08/three-principles-of-classloader-operation</id>
    <content type="html"><![CDATA[<p>（出自一本 J2EE 的教材中关于类加载器的介绍，原文已不知所踪。）</p>

<p>类加载的 bug，一旦在编程中遇到很难调试。好消息是，理解类加载的过程中，我们只需要牢记住三条基本原则。如果你能清晰的理解这三条基本原则，所有问题都迎刃而解。下面，我们开始介绍。</p>

<h2>委托原则(Delegation Principle)</h2>

<blockquote><p>如果一个类还没有被加载，类加载器会委托它的父亲加载器去加载它。</p></blockquote>

<p>这种委托会一直延续，直到到达委托层次的最顶层，由原始的类加载器加载完成该类。下图展示了这种情况。</p>

<p><img src="https://dl.dropboxusercontent.com/u/64021093/Java%20Classloader/classloader1.gif" alt="" /></p>

<p>Systm-ClassPath classloader 加载了 MyApp.MyApp，而这个类创造了一个 java.util.Vector。假设现在 java.util.Vector 还没又被加载。因为 System-Classpath classloader 加载了 MyApp 类，它首先请求它的父亲 extension classloader 来加载这个类（java.util.Vector）。而 extension classloader 又请求 Bootstrap classloader 尝试加载。因为 java.util.Vector 是 J2SE 类，bootstrap classloader 成功加载了它。</p>

<!--more-->


<p>考虑一个当略微不同的情况，如下图。</p>

<p><img src="https://dl.dropboxusercontent.com/u/64021093/Java%20Classloader/classloader2.gif" alt="" /></p>

<p>在这种情况中，MyApp 创造了一个新的用户自定义类的实例，MyClass。假设 MyClass 还没有被加载。像以往一样，当 System-Classpath classloader 接收到这个加载请求，它委托了它的父亲。最终这个委托传递到了 Bootstrap classloader。但是在 java 核心 API 里，找不到这个类。所以它的孩子加载器 Extensions classloader 尝试加载它。同样的，Extensions classloader 也没有找到它。最终，委托请求回到了 System-Classpath classloader 这里。它找到了这个类并加载成功。</p>

<h2>可见性原则（Visibility principle）</h2>

<blockquote><p>被父亲类加载器加载的类对于孩子加载器是可见的，但关系相反相反则不可见。</p></blockquote>

<p>这说明，一个类只能看见它自己的加载器或者这个加载器的父类加载器加载的类，反过来是不可以的。比如，被 ClassX 的父亲加载器加载的类是不能看见 ClassX 的。为了更清楚的理解，让我们来看一个例子，如下图。</p>

<p><img src="https://dl.dropboxusercontent.com/u/64021093/Java%20Classloader/classloader3.gif" alt="" /></p>

<p>图中展示了四个类加载器。类加载器 A 是最顶层的加载器，B 是它的孩子。类加载器 X 和 Y 是 B 的孩子。他们各自都加载了与自己同名的类。类加载器 A 能看见 A 类，类加载器 B 能看见 A，B 类。类似的，X 能看见 A，B，X，Y 能看见 A，B，Y。但兄弟、Y 之间的类是不可见的。</p>

<h2>独特性原则（Uniqueness Principle）</h2>

<blockquote><p>当一个类加载器加载一个类时，它的孩子加载器绝不会重新加载这个类。</p></blockquote>

<p>这是因为委托原则中，一个加载器总是会委托自己的父亲加载器加载类。当层次中的父亲加载器无法加载类的时候，孩子类加载器就会（或者尝试去）加载这个类。这样，类加载的独特性就得到了保障。当父亲和孩子加载器加载了同一个类，一个有趣的情况就出现了。你可能会想这怎么可能出现？这不是违反了独特性原则？</p>

<p>我们用可见性原则中的示例图来解释这个问题。我们假设没有任何类被加载到这些类加载器的层次结构中。假设 X 类被类加载器 X 加载，它强制性的用类加载器 X 加载 B 类。这可以通过像 Class.Name()这样的 API 来实现，代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'> <span class="kd">public</span> <span class="kd">class</span> <span class="nc">X</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>   <span class="kd">public</span> <span class="nf">X</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">ClassLoader</span> <span class="n">cl</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getClassLoader</span><span class="o">();</span>
</span><span class='line'>      <span class="n">Class</span> <span class="n">B</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="err">“</span><span class="n">B</span><span class="err">”</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="n">cl</span><span class="o">);</span>
</span><span class='line'>   <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在 X 的构造函数中，B 被显示的使用类加载器 X 加载。如果另一个被类加载器 B 加载的类需要访问 B 类，则无法实现，因为委托原则只能向父亲方向查询。如果类加载器 B 也加载了 B 类，当比较两个 B 类的实例时，如果一个实例来自于类加载器 X，一个来自于类加载器 B，则会抛出 ClassCastException 异常。</p>

<h2>总结</h2>

<p>这三个原则 是解决程序中遇到的类加载问题的关键所在。在实际的编程中，并不需要显示的调用到类加载器，它主要出现在一些框架的代码中。但对于每一个开发者、架构师而言，都必须理解类加载的层次结构，这样才能写出优雅的代码。</p>

<h3>PS</h3>

<p>注意，虽然 java 的加载实现中，对于 bootstrap classloader 、extensions classloader 和 system classloader 来说，他们的关系是 parent-first，也就是像原则一中所说的那样，需要向上委托，但用户自定义的 classloader 完全可以跳出这个圈子，自己实现 parent-lastclassloader。比如 Websphere 中就有相关配置。</p>

<p>更具体的类加载器编程实例，请见另外一篇博文：<a href="http://biaobiaoqi.me/blog/2013/09/08/java-class-loader-in-practice/">《Java 类加载器编程实践》</a><p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/09/08/three-principles-of-classloader-operation/'>http://biaobiaoqi.github.com/blog/2013/09/08/three-principles-of-classloader-operation/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java类的装载、链接和初始化]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/09/08/java-class-loading-linking-and-initialising/"/>
    <updated>2013-09-08T00:33:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/09/08/java-class-loading-linking-and-initialising</id>
    <content type="html"><![CDATA[<h2>加载(Loading)</h2>

<p>按如下三步执行</p>

<ul>
<li>1.通过类的全名产生对应类的二进制数据流。（注意，如果没找到对应类文件，只有在类实际使用时才抛出错误。）</li>
<li>2.分析并将这些二进制数据流转换为方法区(JVM 的架构：方法区、堆，栈，本地方法栈，pc 寄存器)特定的数据结构（这些数据结构是实现有关的，不同 JVM 有不同实现）。这里处理了部分检验，比如类文件的魔数的验证，检查文件是否过长或者过短，确定是否有父类（除了 Obecjt 类）。</li>
<li>3.创建对应类的 java.lang.Class 实例（注意，有了对应的 Class 实例，并不意味着这个类已经完成了加载链链接！）。</li>
</ul>


<h2>链接(Linking)</h2>

<p>链接的过程比加载过成复杂不少，这是实现 Java 的动态性的重要一步。分为三部分：验证，准备和解析。</p>

<ul>
<li><p>1.验证（verification）</p>

<p>  链接的第三部解析会把类中成员方法、成员变量、类和接口的符号引用替换为直接引用，而在这之前，需要检测被引用的类型正确性和接入属性是否正确（就是 public ,private 的的问题），诸如检查 final class 又没有被继承，检查静态变量的正确性等等。（注意到实际上有一部分验证过程已经在加载的过程中执行了。）</p></li>
</ul>


<!--more-->


<ul>
<li><p>2.准备(preparation)</p>

<p>  对类的成员变量分配空间。虽然有初始值，但这个时候不会对他们进行初始化（因为这里不会执行任何 Java 代码）。具体如下：</p>

<p>  所有原始类型的值都为 0。如 float: 0f, int: 0, boolean: 0(注意 boolean 底层实现大多使用 int)，引用类型则为 null。值得注意的是，JVM 可能会在这个时期给一些有助于程序运行效率提高的数据结构分配空间。比如方发表（类似与 C++中的虚函数表，参见另一篇博文<a href="http://biaobiaoqi.me/blog/2013/06/02/virtual-dispatch-and-method-table-in-java/">《Java：方法的虚分派和方法表》</a>）。</p></li>
<li><p>3.解析(Resolution)</p>

<p>  为类、接口、方法、成员变量的符号引用定位直接引用（如果符号引用先到常量池中寻找符号，再找先应的类型，无疑会耗费更多时间），完成内存结构的布局。</p>

<p>  这一步是可选的。可以在符号引用第一次被使用时完成，即所谓的延迟解析(late resolution)。但对用户而言，这一步永远是延迟解析的，即使运行时会执行 early resolution，但程序不会显示的在第一次判断出错误时抛出错误，而会在对应的类第一次主动使用的时候抛出错误！</p>

<p>  另外，这一步与之后的类初始化是不冲突的，并非一定要所有的解析结束以后才执行类的初始化。不同的 JVM 实现不同。详情见另一篇博文<a href="http://localhost:4000/blog/2013/09/08/late-initialising-in-java/">《Java 类加载的延迟初始化》</a>。</p></li>
</ul>


<h2>初始化类(Initialization)</h2>

<p>开发 Java 时，接触最多的是对象的初始化。实际上类也是有初始化的。相比对象初始化（参见博文 <a href="http://localhost:4000/blog/2013/09/08/initliate-objects-in-java/">Java 类的实例化</a>），类的初始化机制要简单不少。</p>

<p>类的初始化也是延迟的，直到类第一次被主动使用(active use)，JVM 才会初始化类。（参见博文<a href="http://localhost:4000/blog/2013/09/08/late-initialising-in-java/">《Java 类加载的延迟初始化》</a>）</p>

<p>类的初始化分两步：</p>

<ul>
<li>1.如果基类没有被初始化，初始化基类。</li>
<li><p>2.有类构造函数，则执行类构造函数。</p>

<p>  类构造函数是由 Java 编译器完成的。它把类成员变量的初始化和 static 区间的代码提取出，放到一个<clinit>的方法中。这个方法不能被一般的方法访问（注意，static final 成员变量不会在此执行初始化，它一般被编译器生成 constant 值）。同时，<clinit>中是不会显示的调用基类的<clinit>的，因为 1 中已经执行了基类的初始化。类的初始化还必须注意线程安全的问题。</p></li>
</ul>


<h3>PS：</h3>

<p>为什么接口不能定义成员变量，而只能定义 final static 变量。</p>

<ul>
<li>1.接口是不可实例化，它的所有元素都不必是实例（对象）层面的。static 满足了这一点。</li>
<li>2.如果接口的变量能被修改，那么一旦一个子类实现了这个接口，并修改了接口中的非 final 变量，而该子类的子类再次修改这个非 final 的变量后，造成的结果就是虽然实现了相同的接口，但接口中的变量值是不一样的。</li>
</ul>


<p>综上述，static final 更适合于接口。</p>

<p>参考：<a href="http://blog.csdn.net/a352193394/article/details/6844941">《通过类字面常量解释接口常量为什么只能定义为 static final,类加载过程&#8212;Thinking in java》</a></p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/09/08/java-class-loading-linking-and-initialising/'>http://biaobiaoqi.github.com/blog/2013/09/08/java-class-loading-linking-and-initialising/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java类加载器编程实践]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/09/08/java-class-loader-in-practice/"/>
    <updated>2013-09-08T00:33:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/09/08/java-class-loader-in-practice</id>
    <content type="html"><![CDATA[<p>文本通过实现自定义类加载器，实践 Java 类加载的流程。</p>

<p>阅读此文前，需要了解 Java 类加载的基本原理，参见如下两篇博文：</p>

<ul>
<li><a href="http://biaobiaoqi.me/blog/2013/09/07/java-classloader/">《Java 类加载器浅析》</a></li>
<li><a href="http://biaobiaoqi.me/blog/2013/09/08/three-principles-of-classloader-operation/">《Java 类加载器三原则》</a></li>
</ul>


<p>以上博文中所提及的 Java 类加载机制，都是 Java1.2 及以后的版本，而在最早的 Java1.1 中类加载器是没有父子关系的模式的。这里将分别对 Java1.1 和 Java1.2 及以后的类加载版本进行展示。</p>

<h2>Java1.1 中的实现</h2>

<h3>原理介绍</h3>

<p>Java1.1 的类加载机制相对单一，用户自定义加载器的重写比较复杂。</p>

<p>主要需要重写加载器中的 Class loadClass(String name)方法。</p>

<p>Class loadClass(String name)或 loadClass(String name , boolean resolve)方法是加载的核心。它根据类的全名（比如 String 类的全名是 java.lang.String）获得对应类的二进制数据，然后通过 Class defineClass(byte[] b) 将二进制数据加载到 JVM 的方法区，并返回对应类的 Class 实例，然后根据可选的参数 resolve 决定是否需要现在解析这个类。最后将这个 Class 实例作为 loadClass 方法的返回值。</p>

<p>如果无法加载和 defineClass，即无法通过本加载器直接加载类的情况，则使用 Class findSystemClass(String name) 将类加载任务委派给系统类加载器查找。如果能找到则加载，否则抛出 ClassNotFoundException 异常。</p>

<h3>编程实例</h3>

<p>以下用实例来展示这一过程：</p>

<!--more-->


<p>类 CompilingClassLoader 是一个自定义加载器，它能直接读取 Java 源文件实现类加载。CLL 类的 main 方法为程序入口，通过 ComplilingClassLoader 加载一个 Foo 类，使用反射机制调用 Foo 类的 main 方法。</p>

<p>CompilingClassLoader.java</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/* </span>
</span><span class='line'><span class="cm"> </span>
</span><span class='line'><span class="cm">A CompilingClassLoader compiles your Java source on-the-fly.  It </span>
</span><span class='line'><span class="cm">checks for nonexistent .class files, or .class files that are older </span>
</span><span class='line'><span class="cm">than their corresponding source code. </span>
</span><span class='line'><span class="cm"> </span>
</span><span class='line'><span class="cm">*/</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CompilingClassLoader</span> <span class="kd">extends</span> <span class="n">ClassLoader</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>  <span class="c1">// Given a filename, read the entirety of that file from disk  </span>
</span><span class='line'>  <span class="c1">// and return it as a byte array.  </span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">getBytes</span><span class="o">(</span> <span class="n">String</span> <span class="n">filename</span> <span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">// Find out the length of the file  </span>
</span><span class='line'>    <span class="n">File</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span> <span class="n">filename</span> <span class="o">);</span>
</span><span class='line'>    <span class="kt">long</span> <span class="n">len</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Create an array that&#39;s just the right size for the file&#39;s  </span>
</span><span class='line'>    <span class="c1">// contents  </span>
</span><span class='line'>    <span class="kt">byte</span> <span class="n">raw</span><span class="o">[]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[(</span><span class="kt">int</span><span class="o">)</span><span class="n">len</span><span class="o">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Open the file  </span>
</span><span class='line'>    <span class="n">FileInputStream</span> <span class="n">fin</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span> <span class="n">file</span> <span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Read all of it into the array; if we don&#39;t get all,  </span>
</span><span class='line'>    <span class="c1">// then it&#39;s an error.  </span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">fin</span><span class="o">.</span><span class="na">read</span><span class="o">(</span> <span class="n">raw</span> <span class="o">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">r</span> <span class="o">!=</span> <span class="n">len</span><span class="o">)</span>
</span><span class='line'>      <span class="k">throw</span> <span class="k">new</span> <span class="nf">IOException</span><span class="o">(</span> <span class="s">&quot;Can&#39;t read all, &quot;</span><span class="o">+</span><span class="n">r</span><span class="o">+</span><span class="s">&quot; != &quot;</span><span class="o">+</span><span class="n">len</span> <span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Don&#39;t forget to close the file!  </span>
</span><span class='line'>    <span class="n">fin</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// And finally return the file contents as an array  </span>
</span><span class='line'>    <span class="k">return</span> <span class="n">raw</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Spawn a process to compile the java source code file  </span>
</span><span class='line'>  <span class="c1">// specified in the &#39;javaFile&#39; parameter.  Return a true if  </span>
</span><span class='line'>  <span class="c1">// the compilation worked, false otherwise.  </span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">compile</span><span class="o">(</span> <span class="n">String</span> <span class="n">javaFile</span> <span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">// Let the user know what&#39;s going on  </span>
</span><span class='line'>    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span> <span class="s">&quot;CCL: Compiling &quot;</span><span class="o">+</span><span class="n">javaFile</span><span class="o">+</span><span class="s">&quot;...&quot;</span> <span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Start up the compiler  </span>
</span><span class='line'>    <span class="n">Process</span> <span class="n">p</span> <span class="o">=</span> <span class="n">Runtime</span><span class="o">.</span><span class="na">getRuntime</span><span class="o">().</span><span class="na">exec</span><span class="o">(</span> <span class="s">&quot;javac &quot;</span><span class="o">+</span><span class="n">javaFile</span> <span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Wait for it to finish running  </span>
</span><span class='line'>    <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">p</span><span class="o">.</span><span class="na">waitFor</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">catch</span><span class="o">(</span> <span class="n">InterruptedException</span> <span class="n">ie</span> <span class="o">)</span> <span class="o">{</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span> <span class="n">ie</span> <span class="o">);</span> <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Check the return code, in case of a compilation error  </span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">exitValue</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Tell whether the compilation worked  </span>
</span><span class='line'>    <span class="k">return</span> <span class="n">ret</span><span class="o">==</span><span class="mi">0</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// The heart of the ClassLoader -- automatically compile  </span>
</span><span class='line'>  <span class="c1">// source as necessary when looking for class files  </span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">Class</span> <span class="nf">loadClass</span><span class="o">(</span> <span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">resolve</span> <span class="o">)</span>
</span><span class='line'>      <span class="kd">throws</span> <span class="n">ClassNotFoundException</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Our goal is to get a Class object  </span>
</span><span class='line'>    <span class="n">Class</span> <span class="n">clas</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// First, see if we&#39;ve already dealt with this one  </span>
</span><span class='line'>    <span class="n">clas</span> <span class="o">=</span> <span class="n">findLoadedClass</span><span class="o">(</span> <span class="n">name</span> <span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//System.out.println( &quot;findLoadedClass: &quot;+clas );  </span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Create a pathname from the class name  </span>
</span><span class='line'>    <span class="c1">// E.g. java.lang.Object =&gt; java/lang/Object  </span>
</span><span class='line'>    <span class="n">String</span> <span class="n">fileStub</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span> <span class="sc">&#39;.&#39;</span><span class="o">,</span> <span class="sc">&#39;/&#39;</span> <span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Build objects pointing to the source code (.java) and object  </span>
</span><span class='line'>    <span class="c1">// code (.class)  </span>
</span><span class='line'>    <span class="n">String</span> <span class="n">javaFilename</span> <span class="o">=</span> <span class="n">fileStub</span><span class="o">+</span><span class="s">&quot;.java&quot;</span><span class="o">;</span>
</span><span class='line'>    <span class="n">String</span> <span class="n">classFilename</span> <span class="o">=</span> <span class="n">fileStub</span><span class="o">+</span><span class="s">&quot;.class&quot;</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">File</span> <span class="n">javaFile</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span> <span class="n">javaFilename</span> <span class="o">);</span>
</span><span class='line'>    <span class="n">File</span> <span class="n">classFile</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span> <span class="n">classFilename</span> <span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//System.out.println( &quot;j &quot;+javaFile.lastModified()+&quot; c &quot;+  </span>
</span><span class='line'>    <span class="c1">//  classFile.lastModified() );  </span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// First, see if we want to try compiling.  We do if (a) there  </span>
</span><span class='line'>    <span class="c1">// is source code, and either (b0) there is no object code,  </span>
</span><span class='line'>    <span class="c1">// or (b1) there is object code, but it&#39;s older than the source  </span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">javaFile</span><span class="o">.</span><span class="na">exists</span><span class="o">()</span> <span class="o">&amp;&amp;</span>
</span><span class='line'>         <span class="o">(!</span><span class="n">classFile</span><span class="o">.</span><span class="na">exists</span><span class="o">()</span> <span class="o">||</span>
</span><span class='line'>          <span class="n">javaFile</span><span class="o">.</span><span class="na">lastModified</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">classFile</span><span class="o">.</span><span class="na">lastModified</span><span class="o">()))</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">// Try to compile it.  If this doesn&#39;t work, then  </span>
</span><span class='line'>        <span class="c1">// we must declare failure.  (It&#39;s not good enough to use  </span>
</span><span class='line'>        <span class="c1">// and already-existing, but out-of-date, classfile)  </span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(!</span><span class="n">compile</span><span class="o">(</span> <span class="n">javaFilename</span> <span class="o">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">classFile</span><span class="o">.</span><span class="na">exists</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">throw</span> <span class="k">new</span> <span class="nf">ClassNotFoundException</span><span class="o">(</span> <span class="s">&quot;Compile failed: &quot;</span><span class="o">+</span><span class="n">javaFilename</span> <span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span> <span class="k">catch</span><span class="o">(</span> <span class="n">IOException</span> <span class="n">ie</span> <span class="o">)</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Another place where we might come to if we fail  </span>
</span><span class='line'>        <span class="c1">// to compile  </span>
</span><span class='line'>        <span class="k">throw</span> <span class="k">new</span> <span class="nf">ClassNotFoundException</span><span class="o">(</span> <span class="n">ie</span><span class="o">.</span><span class="na">toString</span><span class="o">()</span> <span class="o">);</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Let&#39;s try to load up the raw bytes, assuming they were  </span>
</span><span class='line'>    <span class="c1">// properly compiled, or didn&#39;t need to be compiled  </span>
</span><span class='line'>    <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1">// read the bytes  </span>
</span><span class='line'>      <span class="kt">byte</span> <span class="n">raw</span><span class="o">[]</span> <span class="o">=</span> <span class="n">getBytes</span><span class="o">(</span> <span class="n">classFilename</span> <span class="o">);</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1">// try to turn them into a class  </span>
</span><span class='line'>      <span class="n">clas</span> <span class="o">=</span> <span class="n">defineClass</span><span class="o">(</span> <span class="n">name</span><span class="o">,</span> <span class="n">raw</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">raw</span><span class="o">.</span><span class="na">length</span> <span class="o">);</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">catch</span><span class="o">(</span> <span class="n">IOException</span> <span class="n">ie</span> <span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="c1">// This is not a failure!  If we reach here, it might  </span>
</span><span class='line'>      <span class="c1">// mean that we are dealing with a class in a library,  </span>
</span><span class='line'>      <span class="c1">// such as java.lang.Object  </span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//System.out.println( &quot;defineClass: &quot;+clas );  </span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Maybe the class is in a library -- try loading  </span>
</span><span class='line'>    <span class="c1">// the normal way  </span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">clas</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">clas</span> <span class="o">=</span> <span class="n">findSystemClass</span><span class="o">(</span> <span class="n">name</span> <span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//System.out.println( &quot;findSystemClass: &quot;+clas );  </span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Resolve the class, if any, but only if the &quot;resolve&quot;  </span>
</span><span class='line'>    <span class="c1">// flag is set to true  </span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">resolve</span> <span class="o">&amp;&amp;</span> <span class="n">clas</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'>      <span class="n">resolveClass</span><span class="o">(</span> <span class="n">clas</span> <span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// If we still don&#39;t have a class, it&#39;s an error  </span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">clas</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'>      <span class="k">throw</span> <span class="k">new</span> <span class="nf">ClassNotFoundException</span><span class="o">(</span> <span class="n">name</span> <span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Otherwise, return the class  </span>
</span><span class='line'>    <span class="k">return</span> <span class="n">clas</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>CCLRun.java</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="cm">/* </span>
</span><span class='line'><span class="cm"> </span>
</span><span class='line'><span class="cm">CCLRun executes a Java program by loading it through a </span>
</span><span class='line'><span class="cm">CompilingClassLoader. </span>
</span><span class='line'><span class="cm"> </span>
</span><span class='line'><span class="cm">*/</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CCLRun</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>  <span class="kd">static</span> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span> <span class="n">String</span> <span class="n">args</span><span class="o">[]</span> <span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// The first argument is the Java program (class) the user  </span>
</span><span class='line'>    <span class="c1">// wants to run  </span>
</span><span class='line'>    <span class="n">String</span> <span class="n">progClass</span> <span class="o">=</span> <span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// And the arguments to that program are just  </span>
</span><span class='line'>    <span class="c1">// arguments 1..n, so separate those out into  </span>
</span><span class='line'>    <span class="c1">// their own array  </span>
</span><span class='line'>    <span class="n">String</span> <span class="n">progArgs</span><span class="o">[]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">[</span><span class="n">args</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
</span><span class='line'>    <span class="n">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span> <span class="n">args</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="n">progArgs</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">progArgs</span><span class="o">.</span><span class="na">length</span> <span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Create a CompilingClassLoader  </span>
</span><span class='line'>    <span class="n">CompilingClassLoader</span> <span class="n">ccl</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CompilingClassLoader</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Load the main class through our CCL  </span>
</span><span class='line'>    <span class="n">Class</span> <span class="n">clas</span> <span class="o">=</span> <span class="n">ccl</span><span class="o">.</span><span class="na">loadClass</span><span class="o">(</span> <span class="n">progClass</span> <span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Use reflection to call its main() method, and to  </span>
</span><span class='line'>    <span class="c1">// pass the arguments in.  </span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Get a class representing the type of the main method&#39;s argument  </span>
</span><span class='line'>    <span class="n">Class</span> <span class="n">mainArgType</span><span class="o">[]</span> <span class="o">=</span> <span class="o">{</span> <span class="o">(</span><span class="k">new</span> <span class="n">String</span><span class="o">[</span><span class="mi">0</span><span class="o">]).</span><span class="na">getClass</span><span class="o">()</span> <span class="o">};</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Find the standard main method in the class  </span>
</span><span class='line'>    <span class="n">Method</span> <span class="n">main</span> <span class="o">=</span> <span class="n">clas</span><span class="o">.</span><span class="na">getMethod</span><span class="o">(</span> <span class="s">&quot;main&quot;</span><span class="o">,</span> <span class="n">mainArgType</span> <span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Create a list containing the arguments -- in this case,  </span>
</span><span class='line'>    <span class="c1">// an array of strings  </span>
</span><span class='line'>    <span class="n">Object</span> <span class="n">argsArray</span><span class="o">[]</span> <span class="o">=</span> <span class="o">{</span> <span class="n">progArgs</span> <span class="o">};</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Call the method  </span>
</span><span class='line'>    <span class="n">main</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span> <span class="kc">null</span><span class="o">,</span> <span class="n">argsArray</span> <span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Foo.java</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Foo</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>  <span class="kd">static</span> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span> <span class="n">String</span> <span class="n">args</span><span class="o">[]</span> <span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span> <span class="s">&quot;foo! &quot;</span><span class="o">+</span><span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="n">args</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>执行 CLL 类，命令行传入 Foo 的类名。执行结果如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nl">CCL:</span> <span class="n">Compiling</span> <span class="n">Foo</span><span class="o">.</span><span class="na">java</span><span class="o">...</span>
</span><span class='line'><span class="n">foo</span><span class="o">!</span> <span class="n">arg1</span> <span class="n">arg2</span>
</span></code></pre></td></tr></table></div></figure>


<p>具体参见资料：<a href="http://www.ibm.com/developerworks/java/tutorials/j-classloader/index.html">IBM DeveloperWorks ： Understanding the Java ClassLoader</a>， 这是一篇 2001 年的文章，是早年 Java1.1 的实现方式。如今的 Java 已经变得更加人性化，多功能化，鲁棒性也更强了。</p>

<h2>Java1.2 以后的实现</h2>

<h3>原理介绍</h3>

<p>Java1.2 以后，类加载器实现了 parent-child 模型，能更好的控制安全性方面的问题。</p>

<p>由于 loadClass()方法中包含了 parent-child 的责任链模式逻辑，自定义类加载的自定义部分用策略模式从 loadClass()方法中剥离到了 findClass()中。对应的有一个 findLoadedClass()，这个方法用来实现查找当前加载器是否有加载该某类。</p>

<p>loadClass()：加载一个类时，先调 findLoadedClass()，如果没有找到，则调用父亲加载器的加载方法。如果父亲找到了该类，就返回 Class 实例，没有找到，则父亲加载器会抛出一个异常，捕捉到这个异常后，儿子加载器会自己调用 findClass()尝试实现对类的加载。如果依然没有成功加载，则再向外抛出一个异常。通过向父亲加载器迭代实现了 parent-first 的委托关系。</p>

<p>类加载的流程如图：这里显示了一个类未能成功加载所要经历的流程。（来自 <a href="http://stackoverflow.com/questions/3544614/how-is-the-control-flow-to-findclass-of">stackoverflow:how-is-the-control-flow-to-findclass-of</a>）</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>  <span class="n">A</span><span class="o">.</span><span class="na">loadClass</span><span class="o">()</span>
</span><span class='line'>       <span class="o">|</span>
</span><span class='line'>   <span class="o">(</span><span class="n">not</span><span class="o">-</span><span class="n">found</span><span class="o">?)</span> <span class="o">(</span><span class="n">by</span> <span class="n">findLoadedClass</span><span class="o">)</span>
</span><span class='line'>       <span class="o">|</span>
</span><span class='line'>  <span class="n">B</span><span class="o">.</span><span class="na">loadClass</span><span class="o">()</span>
</span><span class='line'>       <span class="o">|</span>
</span><span class='line'>   <span class="o">(</span><span class="n">not</span> <span class="n">found</span><span class="o">?)</span> <span class="o">(</span><span class="n">by</span> <span class="n">findLoadedClass</span><span class="o">)</span>
</span><span class='line'>       <span class="o">|</span>
</span><span class='line'><span class="n">systemclassloader</span><span class="o">.</span><span class="na">loadClass</span>  <span class="o">(</span><span class="n">Bs</span> <span class="n">parent</span><span class="o">,</span> <span class="n">also</span> <span class="n">can</span> <span class="n">be</span>
</span><span class='line'>       <span class="o">|</span>                  <span class="n">called</span> <span class="n">classpath</span> <span class="n">classloader</span><span class="o">)</span>
</span><span class='line'>       <span class="o">|</span>
</span><span class='line'>   <span class="o">(</span><span class="n">not</span> <span class="n">found</span><span class="o">?)</span> <span class="o">(</span><span class="n">by</span> <span class="n">findLoadedClass</span><span class="o">)</span>
</span><span class='line'>       <span class="o">|</span>
</span><span class='line'><span class="n">bootstrap</span> <span class="n">classloader</span><span class="o">.</span><span class="na">loadClass</span> <span class="o">(</span><span class="n">the</span> <span class="n">bootstrap</span> <span class="n">classloader</span><span class="o">,</span>
</span><span class='line'>       <span class="o">|</span>                   <span class="o">(</span><span class="k">this</span> <span class="n">has</span> <span class="n">no</span> <span class="n">parent</span><span class="o">)</span>
</span><span class='line'>       <span class="o">|</span>
</span><span class='line'>   <span class="o">(</span><span class="n">not</span> <span class="n">found</span><span class="o">?)</span>
</span><span class='line'>       <span class="o">|</span>
</span><span class='line'><span class="n">systemclassloader</span><span class="o">.</span><span class="na">findClass</span>  <span class="o">(</span><span class="n">on</span> <span class="n">system</span> <span class="n">classloader</span><span class="o">,</span>
</span><span class='line'>       <span class="o">|</span>                   <span class="n">will</span> <span class="k">try</span> <span class="n">to</span> <span class="s">&quot;find&quot;</span> <span class="kd">class</span> <span class="nc">in</span> <span class="s">&quot;classpath&quot;</span><span class="o">)</span>
</span><span class='line'>       <span class="o">|</span>
</span><span class='line'>   <span class="o">(</span><span class="n">not</span> <span class="n">found</span><span class="o">?)</span> <span class="n">ClassNotFoundException</span>
</span><span class='line'>       <span class="o">|</span>
</span><span class='line'>   <span class="n">B</span><span class="o">.</span><span class="na">findClass</span>
</span><span class='line'>       <span class="o">|</span>
</span><span class='line'>   <span class="o">(</span><span class="n">not</span> <span class="n">found</span><span class="o">?)</span> <span class="n">ClassNotFoundException</span>
</span><span class='line'>       <span class="o">|</span>
</span><span class='line'>   <span class="n">A</span><span class="o">.</span><span class="na">findClass</span>
</span><span class='line'>       <span class="o">|</span>
</span><span class='line'>    <span class="o">(</span><span class="n">not</span> <span class="n">found</span><span class="o">?)</span>
</span><span class='line'>       <span class="o">|</span>
</span><span class='line'>   <span class="n">ClassNotFoundException</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意，对于扩展类加载器，通过 getParent()方法返回的父亲加载器是 null，因为引导类加载器是本地实现的，并非 Java 实现。那么如何从扩展类加载器向上回溯呢？答案如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="k">try</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">parent</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>       <span class="n">c</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="na">loadClass</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>       <span class="n">c</span> <span class="o">=</span> <span class="n">findBootstrapClassOrNull</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ClassNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>   <span class="c1">// ClassNotFoundException thrown if class not found  </span>
</span><span class='line'>     <span class="c1">// from the non-null parent class loader  </span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
这是类加载器的源代码，对于父加载器为 null 的情况，会直接调用 findBootstrapClassOrNull()方法尝试用引导类加载器加载。通过源代码，能够很好的理解这里的 parent-child 模型了。</p>

<p>另注意，对于基于 parent-child 模型的类加载器实现，都需要定义一个以 parent 类加载器作为参数的构造函数，以指定父加载器。如果直接调用没有参数的构造函数，则默认制定的是 systemclassloader 作为 parent。</p>

<h3>编程实例</h3>

<p>下面的例子是我用来实现动态分析 Java 类关系的加载器代码。</p>

<p>具体逻辑是：调用 ASM 开源库的 API，在加载器加载类时，修改类文件中的字节码，插入相应的字节码语句，让对象在创建或执行相应指令时，在 log 文件中记录自己的行为。</p>

<p>在编码的过程中，我遇到的一个错误：将需要使用自定义加载器加载的类文件直接放在了 eclipse 工程中的 bin 目录下。而这个目录是可以通过系统类加载器找到路径并加载的。根据 parent-first 的实现，这些类直接被系统类加载器加载了，也就绕过了自定义加载器的处理机制。修改过路径以后没有出现相应问题了。</p>

<p>ASMClassLoader.java</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kn">package</span> <span class="n">biaobiaoqi</span><span class="o">.</span><span class="na">classLoader</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.objectweb.asm.ClassReader</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.objectweb.asm.ClassWriter</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="nn">biaobiaoqi.asm.*</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ASMClassLoader</span> <span class="kd">extends</span> <span class="n">ClassLoader</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="n">String</span> <span class="n">basePath</span> <span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**reference to System Classloader as the parent class loader </span>
</span><span class='line'><span class="cm">     * @param path &lt;br&gt; the path of .class files will be loaded </span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">ASMClassLoader</span><span class="o">(</span><span class="n">String</span> <span class="n">path</span><span class="o">){</span>
</span><span class='line'>        <span class="n">basePath</span> <span class="o">=</span> <span class="n">path</span> <span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/** </span>
</span><span class='line'><span class="cm">     * reference to parent as it&#39;s parent classloader </span>
</span><span class='line'><span class="cm">     * @param path </span>
</span><span class='line'><span class="cm">     * @param parent </span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">ASMClassLoader</span><span class="o">(</span><span class="n">String</span> <span class="n">path</span> <span class="o">,</span> <span class="n">ClassLoader</span> <span class="n">parent</span><span class="o">){</span>
</span><span class='line'>        <span class="kd">super</span><span class="o">(</span><span class="n">parent</span><span class="o">);</span>
</span><span class='line'>        <span class="n">basePath</span> <span class="o">=</span> <span class="n">path</span> <span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Class</span> <span class="nf">findClass</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ClassNotFoundException</span><span class="o">{</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;findClass&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="kt">byte</span><span class="o">[]</span> <span class="n">raw</span><span class="o">;</span>
</span><span class='line'>        <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">raw</span> <span class="o">=</span> <span class="n">getBytesFromBasePath</span><span class="o">(</span> <span class="n">name</span> <span class="o">);</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">ClassNotFoundException</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">byte</span><span class="o">[]</span> <span class="n">transformed</span> <span class="o">=</span> <span class="n">instrumentBtyeCode</span><span class="o">(</span><span class="n">raw</span><span class="o">);</span>
</span><span class='line'>        <span class="cm">/* </span>
</span><span class='line'><span class="cm">        try{ </span>
</span><span class='line'><span class="cm">            FileOutputStream file = new FileOutputStream( &quot;/home/biaobiaoqi/&quot; +name.replace( &#39;.&#39;, &#39;/&#39; )+&quot;.class&quot;); </span>
</span><span class='line'><span class="cm">            file.write( transformed); </span>
</span><span class='line'><span class="cm">            file.close(); </span>
</span><span class='line'><span class="cm">        } </span>
</span><span class='line'><span class="cm">        catch (IOException e) { </span>
</span><span class='line'><span class="cm">            e.printStackTrace(); </span>
</span><span class='line'><span class="cm">        } </span>
</span><span class='line'><span class="cm">        */</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">transformed</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">ClassNotFoundException</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="nf">defineClass</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">transformed</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">transformed</span><span class="o">.</span><span class="na">length</span> <span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">getBytesFromBasePath</span><span class="o">(</span> <span class="n">String</span> <span class="n">className</span> <span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">,</span><span class="n">ClassNotFoundException</span><span class="o">{</span>
</span><span class='line'>        <span class="n">String</span> <span class="n">fileStub</span> <span class="o">=</span> <span class="n">className</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span> <span class="sc">&#39;.&#39;</span><span class="o">,</span> <span class="sc">&#39;/&#39;</span> <span class="o">);</span>
</span><span class='line'>        <span class="n">String</span> <span class="n">classFileName</span> <span class="o">=</span> <span class="n">basePath</span> <span class="o">+</span><span class="n">fileStub</span><span class="o">+</span><span class="s">&quot;.class&quot;</span><span class="o">;</span>
</span><span class='line'>        <span class="n">File</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span> <span class="n">classFileName</span> <span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">long</span> <span class="n">len</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
</span><span class='line'>        <span class="kt">byte</span> <span class="n">raw</span><span class="o">[]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[(</span><span class="kt">int</span><span class="o">)</span><span class="n">len</span><span class="o">];</span>
</span><span class='line'>        <span class="n">FileInputStream</span> <span class="n">fin</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span> <span class="n">file</span> <span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">fin</span><span class="o">.</span><span class="na">read</span><span class="o">(</span> <span class="n">raw</span> <span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">r</span> <span class="o">!=</span> <span class="n">len</span><span class="o">)</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IOException</span><span class="o">(</span> <span class="s">&quot;Can&#39;t read all, &quot;</span><span class="o">+</span><span class="n">r</span><span class="o">+</span><span class="s">&quot; != &quot;</span><span class="o">+</span><span class="n">len</span> <span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">fin</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">raw</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">instrumentBtyeCode</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">raw</span><span class="o">){</span>
</span><span class='line'>        <span class="n">ClassWriter</span> <span class="n">cw</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ClassWriter</span><span class="o">(</span><span class="n">ClassWriter</span><span class="o">.</span><span class="na">COMPUTE_FRAMES</span><span class="o">);</span>
</span><span class='line'>        <span class="n">ASMClassAdapter</span> <span class="n">mca</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ASMClassAdapter</span><span class="o">(</span><span class="n">cw</span><span class="o">);</span>
</span><span class='line'>        <span class="n">ClassReader</span> <span class="n">cr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ClassReader</span><span class="o">(</span><span class="n">raw</span><span class="o">);</span>
</span><span class='line'>        <span class="n">cr</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">mca</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">cw</span><span class="o">.</span><span class="na">toByteArray</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Class</span> <span class="nf">loadClass</span><span class="o">(</span> <span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">resolve</span> <span class="o">)</span>
</span><span class='line'>        <span class="kd">throws</span> <span class="n">ClassNotFoundException</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;loadClass_resolve&quot;</span><span class="o">);</span>
</span><span class='line'>          <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">loadClass</span><span class="o">(</span><span class="n">name</span> <span class="o">,</span><span class="n">resolve</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Class</span> <span class="nf">loadClass</span><span class="o">(</span> <span class="n">String</span> <span class="n">name</span> <span class="o">)</span>
</span><span class='line'>        <span class="kd">throws</span> <span class="n">ClassNotFoundException</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;loadClass&quot;</span><span class="o">);</span>
</span><span class='line'>          <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">loadClass</span><span class="o">(</span><span class="n">name</span> <span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/09/08/java-class-loader-in-practice/'>http://biaobiaoqi.github.com/blog/2013/09/08/java-class-loader-in-practice/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java 类加载器]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/09/07/java-classloader/"/>
    <updated>2013-09-07T23:15:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/09/07/java-classloader</id>
    <content type="html"><![CDATA[<h2>背景知识</h2>

<p>Java 平台无关的特性是由 JVM(Java 虚拟机)支撑的。不同平台有不同的 JVM 支持。</p>

<p>计算机领域有这么一句话：</p>

<blockquote><p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。</p></blockquote>

<p>JVM 其实也可以看做是运行的 Java 程序和实际的硬件架构之间的一个新抽象层。</p>

<p>一个 Java 程序从编写到执行的流程一句话概括如下：首先将 Java 源代码（*.java 文件）编译成字节码（*.class 文件，字节码之于 Java 源码，类比于汇编代码之于 C 源码），然后由 JVM 运行那些字节码文件。</p>

<p>JVM 工作原理如下图</p>

<p><img src="https://dl.dropboxusercontent.com/u/64021093/Java%20Classloader/JVM%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.gif" alt="JVM framework" /></p>

<p>Java 中所有的类文件都需要由类加载器（Class Loader）装载到 JVM 中。可以简单的将 JVM 理解为一个工厂，类文件就是等待加工的原料，加载器则是装载货物的工人。Java 类被装载之后，才能进入到 JVM 的运行时机制中，开始运行。</p>

<h2>类加载器的作用</h2>

<p>顾名思义，Java 类加载器的作用是向 JVM 中装载类。</p>

<p>这种动态装载的技术是 Java 的一种创新，让类能够动态加载到 JVM 中执行（更详细的介绍参见 <a href="http://www.ibm.com/developerworks/java/library/j-dyn0429/">Java programming dynamics, Part 1: Java classes and class loading</a>）。</p>

<!--more-->


<p>而它的意义远非仅仅是加载类这么简单。实际上，类加载器对 Java 的沙箱模型具有重大意义。他和安全管理模块（负责对类文件中的字节码进行校验，防止恶意代码的攻击）一起保证了 JVM 运行的安全性。</p>

<h2>类加载机制</h2>

<p>大体上，每个 Java 应用使用了如下几种类型的类加载器:</p>

<ul>
<li><p>1.引导类加载器（bootstrap class loader）</p>

<p>  它由 C++编写（注意，它非常特殊，并非 Java 中的 ClassLoader 类的子类）。当 JVM 启动时，引导类加载器也随之启动，它负责加载 Java 核心类，如 JRE 的 rt.jar、charsets.jar 等。从 Java1.2 开始，它只加载 Java 核心 API 部分。</p>

<p>  因为这些类是系统信任的类，所以这里的装载，跳过了很多对字节码的验证过程。</p></li>
<li><p>2.扩展类加载器（extension class loader）</p>

<p> 它负责加载/lib/ext 中的 java 扩展类。</p></li>
<li><p>3.系统类加载器（System Class Loader）</p>

<p>这是很重要的一个加载器，加载 Java 的路径 classpath 下的类。应用程序的装载默认由它负责。</p></li>
<li><p>4.自定义类加载器</p>

<p> 由系统类加载器继承得到。它的存在让我们能定制出各种不同功能的加载器，增加了 Java 的可扩展性。自定义的类加载器如果没有显示的继承关系，则其父类默认为系统类加载器。</p></li>
</ul>


<p>一个 JVM，只拥有一个引导类加载器，同时可以拥有多个自定义类加载器，方便不同应用环境的用户定制。比如，自定义类加载器能够动态的修改字节码，让它能接收并加载从网上传来的类文件或 Jar 包，甚至是任何编码方式的压缩包。只要自定义类加载器能够正确识别并调用相应方法来实现类的加载和解析，一切都有可能。</p>

<p>四种加载器不是四个独立的部分，他们之间具有一种特殊的父子关系，每个类加载器都保持着他们的父加载器的应用，共同组成了一条父子关系链，被称作 parent-delegation 模式。如下图</p>

<p><img src="https://dl.dropboxusercontent.com/u/64021093/Java%20Classloader/java%20classloader%20hierachy.gif" alt="class loader hirerachy" /></p>

<p>类加载器按照如此树形排列。类加载的查找顺序是：</p>

<p>cache &#8211;> parent &#8211;> self</p>

<p>子类加载器需要加载某个类时，并不是直接加载，而是首先查看 cache（cache 可以理解为加载器已经加载过的类的记录）。如果没有，则向父加载器提出请求，查看是否存在于父加载器的 cache 中。如此往上，直到根部的引导类加载器。如果引导类加载器的 cache 也没有这个类，则它尝试直接加载这个类，如果无法成功，则请求儿子加载器加载，依次往下。</p>

<p>直接接受程序请求加载某类的加载器被称作初始类加载器（Initiating class loader），而最终加载了该类的加载器则成为定义类加载器（defining class loader）。</p>

<p>类加载器的<code>getParent()</code>方法可以获得加载器的父亲。下面的代码用于输出各个层级的类加载器。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ClassLoaderTest</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">ClassLoader</span> <span class="n">loader</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getContextClassLoader</span><span class="o">();</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;current loader:&quot;</span><span class="o">+</span><span class="n">loader</span><span class="o">);</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;parent loader:&quot;</span><span class="o">+</span><span class="n">loader</span><span class="o">.</span><span class="na">getParent</span><span class="o">());</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;grandparent loader:&quot;</span><span class="o">+</span><span class="n">loader</span><span class="o">.</span><span class="na">getParent</span><span class="o">().</span><span class="na">getParent</span><span class="o">());</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>显示的结果是</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">current</span> <span class="nl">loader:</span><span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">Launcher</span><span class="n">$AppClassLoader</span><span class="err">@</span><span class="mi">1</span><span class="n">c78e57</span>
</span><span class='line'><span class="n">parent</span> <span class="nl">loader:</span><span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">Launcher</span><span class="n">$ExtClassLoader</span><span class="err">@</span><span class="mi">5224</span><span class="n">ee</span>
</span><span class='line'><span class="n">grandparent</span> <span class="nl">loader:</span><span class="kc">null</span>
</span></code></pre></td></tr></table></div></figure>


<p>grandparent 显示的值是 null，并不意味着他没有 parent，而是因为它是由 C++编写的引导类加载器。他并不是 ClassLoader 类的子类，也就无法使用 getParent()方法获得返回了。</p>

<p>如此，parent class loader 总是拥有更高的加载优先级，这让想利用自定义加载器伪装加载某些重要类的恶意代码无法得逞。如果好奇，你可以尝试自己写 package java.lang 里的 String 类，加载执行试试～
另外，当类 A 调用另类 B 时，B 会由加载 A 的 class loader 加载，从而实现。</p>

<h2>加载类的流程</h2>

<p>类的装载大致可以分为三个步骤（如下图）：</p>

<ul>
<li>1.装载(loading)</li>
<li>2.链接(linking)</li>
<li>3.初始化(initialising)</li>
</ul>


<p><img src="https://dl.dropboxusercontent.com/u/64021093/Java%20Classloader/ClassLoaderProcess.gif" alt="class loader process" /></p>

<p>跟 C++或者 C 程序有很大的不同，编译过后的类文件中的字节码并没有设计好内存布局，这些需要等到加载之后的链接阶段，才会完成。这也是 java 可移植性中精彩的一笔！</p>

<p>关于类的加载、链接和初始化，请参见另一篇博文：<a href="http://biaobiaoqi.me/blog/2013/09/08/java-class-loading-linking-and-initialising/">《Java 类的装载、链接和初始化》</a></p>

<p>关于类加载器的编程实践，请参见另一篇博文：<a href="http://biaobiaoqi.me/blog/2013/09/08/java-class-loader-in-practice/">《Java 类加载器编程实践》</a></p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/09/07/java-classloader/'>http://biaobiaoqi.github.com/blog/2013/09/07/java-classloader/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android小游戏：功夫蛇 团队开发经验总结]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/09/06/kongfu-snake-project-summary/"/>
    <updated>2013-09-06T00:00:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/09/06/kongfu-snake-project-summary</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>曾经没有代码管理的习惯，不用回版本控制工具。这种陋习虽然让原来千穿百孔的代码远离了实现，但这种逃避未必就是一件好事吧;)。
于是从博客中挖出了原来的文章，并千辛万苦找到了最早的代码贴出来。</p>

<p>这篇文章是参加 Google 的 Android 应用开发大赛时，写的总结帖。主要从团队和设计两个方面进行了分析总结。虽然如今看来一些内容显得稚嫩和粗糙，
但没有功劳还是有苦劳的！还是那句话，我们要不断收集生活中的珠子，等到最后，才能串成一条链。</p>

<p>我同步的将代码贴到了自己的 <a href="https://github.com/biaobiaoqi/kongfusnake">github</a> 里。对于这份代码，或许以后有时间，可以重构下代码？又或者没有时间？
这都无所谓。能够让原来的脚印在路途中获得一席之地，也才有之后更好的旅程。</p>

<p>内容不做修改，这就是 12 年 1 月时，我的思维层次总结啦。</p>

<h2>原文</h2>

<p>此文从团队和设计两方面，进行了一些经验总结。没有涉及技术实现的讨论。</p>

<p>KongfuSnake，这是一款取材自贪吃蛇的 android 游戏。（弱弱的说，这个取材其实这是我最不敢说出口的，被大多数人评价为老套、
过时的创意>&lt;&#8230;但需要解释的是，我们确实做了很多“微创新”~）。</p>

<!--more-->


<p>下载链接：<a href="http://www.google.cn/university/androidchallenge/2011/gallery.html#tab=d1-13">KongfuSnake</a></p>

<h3>1.背景</h3>

<p>参加的 google 的 android 应用大学生挑战赛上个月已经画上了句号。</p>

<p>结果是幸运的，最终我们跟另外的 4 只队伍一起，获得了全国总决赛二等奖。当然，名次并不是最重要，重要的是经历了什么，学到了什么。于是，用心的敲下这些文字，给自己的旅途留下脚印，期望对以后的学习、生活有所助益。也算是认知盈余吧。</p>

<p>11 年 6 月份吧，大三下学期萌发参加比赛的念头。</p>

<p>当时的考虑是，自己由于时间安排的关系，无法参加暑期实习，而本科前三年重心一直不在编程上，想借暑假的空闲机会，体验一下比赛的乐趣，
也算见识下 android 的开发体系。而作为团队参加也可以积累些许技术沟通的经验，于是找到了同专业的一个同学，一起组队参赛。
后期，又邀请了工业设计专业的一位同学加入，为作品的 UI 润色，用足了比赛规定的最多三个名额的限定。</p>

<p>回过头来，那些小九九也算达到了一些～甚至还有当时没有考虑到的收获，比如对小游戏设计方面的浅显理解。</p>

<h3>2.团队</h3>

<p>这是一个三人的小规模学生团队，说我们小打小闹也罢，团队里的沟通交流总归是存在的。麻雀虽小，五脏俱全～</p>

<h4>2.1.团队的组成</h4>

<p>经历过以前一些团队作业，我觉得大学生团队最重要的问题就是是否每个人都有足够的时间。基于这个原则，我找到了 yzq 童鞋。</p>

<p>后期，我们发现必须找人润色 UI，又通过学校论坛征到了比我们低一级的 mqx 童鞋，这一步走的略显仓促，与项目早期自己的侥幸心理有关>&lt;&#8230;.
准备不周全。幸运的是，最终效果还不错。</p>

<p>值得反思的是，最初我在征 UI 设计时，没有与候选人沟通好具体的职责：
团队需要的是能尽可能的提供 UI 的整套解决方案，而不仅仅是按照程序开发者的意愿 P 几张图而已。
由于这一失误，mqx 童鞋后来的大多数时间里只是照着后半句在做，让我们编程人员力不从心>&lt;&#8230;.。
当然，另一个侧面，也算是培养了自己产品设计的一些理念吧。。</p>

<h4>2.2.团队沟通</h4>

<p>开发期间，由于暑假回家、之后我出国交流等原因，大家很多时间都不在一起。只是通过 QQ 进行交流的。交流的方式也比较随意。</p>

<p>由于项目小，我们没有使用到 svn、git 等版本控制工具。这些原始的沟通方式，虽然在小项目中负面影响不大，但相信随着项目规模的增大，
它们对效率的影响会显现出来，特别是版本控制方面。这里以后需要注意。</p>

<p>另外，在沟通技巧上，自己比较欠缺。由于专业不同的关系，我与负责 UI 的童鞋对某些设计的理解不尽相同，
而自己起初没有注意到这一点，让大家无谓的耗费了精力；每个人都会有不同的想法，在处理矛盾想法的解决时，作为项目发起人，
我的方式不够委婉。</p>

<h4>2.3.团队建设</h4>

<p>我有意识的提及一旦获奖，我们可以获得的收益，想借此激励大家的积极性。不过技巧性还需要提炼。</p>

<h3>3.设计</h3>

<p>评价一款手机游戏的优缺点，相对来说比较容易。但真的要做出决策如何设计一款游戏，则难了很多。</p>

<p>看过网上很多移动应用开发的设计指南，一条一条的罗列挺纷繁的，总结自己粗劣的设计经验，是如下两条：创新的想法和合理的取舍（trade-off）。</p>

<p>创新能挖掘出用户的需求，合理的取舍，能让众多创新的想法融合出一个完整的产品构图。</p>

<h4>3.1 关于创新</h4>

<p>不要被原来的设计需求禁锢。创新可以挖掘出新的需求。</p>

<p>刚开始的时候无法囊括所有的创新点，新的点子可能在之后的经历中又突然冒出，毫不犹豫的去尝试，不断迭代改进。</p>

<p>当然很多创新点可能在游戏的整体中不和谐，但这些层出不穷的创新只要有千分之一是可行的，就可能让产品脱颖而出，不再陈旧。</p>

<h4>3.2 关于取舍（trade-off）</h4>

<p>突出主题。</p>

<p>手机界面相对较小，视觉上容量本就不多。细小的图形元素容易造成蔓延昏花的效果。突出能抓住用户眼球的主题很重要
，必要的时候，需要适当舍弃可能造成混淆的元素。</p>

<p>增强元素的表现力和区分度。视觉、听觉、触觉（震动）等各个方面增强各个元素之间的区分度和表现力。</p>

<p>统一风格。每一个按键，每一个游戏元素，包括背景、布局、音效，都需要统一风格。</p>

<h3>另</h3>

<p>由于时间拖得比较久，没有及时的总结经验教训，感觉很多细节都已经离我远去了>&lt;&#8230;下次得注意了。</p>

<h3>另另</h3>

<p>由于代码写的比较搓，也就不公开放出了强奸大家的眼球了>&lt;&#8230;，要学的还有很多。<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/09/06/kongfu-snake-project-summary/'>http://biaobiaoqi.github.com/blog/2013/09/06/kongfu-snake-project-summary/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google Android应用开发大赛参赛记]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/09/05/google-android-challenge-2011/"/>
    <updated>2013-09-05T23:51:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/09/05/google-android-challenge-2011</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>大三结束的暑假，跟另外两个同学一起组队参加了 Google 第二届 Andoid 应用开发中国大学生挑战赛，有幸获得了<a href="http://www.google.cn/university/androidchallenge/2011/gallery.html#tab=d1-13">全国总决赛的前 6 名</a>。
虽然只是移动客户端的开发实践，但也第一次让我体验到了工程的魅力、团队协作的成就感和编码的快乐。</p>

<p>以下内容实际上是一份属于当时经验匮乏的团队的开发草稿，回头看来，满载的无知和丰腴的老土，姑且把它当做开发日志吧;)</p>

<p>不做内容删改（些许格式调整）,原文如下：</p>

<!--more-->


<h2>功夫蛇开发日志</h2>

<h3>2011-06-24</h3>

<p>转眼到大三了都。</p>

<p>说来惭愧，什么项目都没做过，课程的大作业都美认真完成的人，谈何项目呢- -#</p>

<p>技术是王道，其他的，GPA、社团都是浮云。</p>

<p>于是，想着，从现在开始，要做点什么了。觉得，这才是我的兴趣所在。</p>

<p>于是，看到了这个契机。Google Android 应用开发大赛~</p>

<p>于是找到了 yzq 童鞋作搭档。</p>

<p>现在是 6.24。比赛截止日期位 10 月 10。</p>

<p>计划执行的时间是 7 到 9 月两个月。</p>

<p>6.24 - 7.10 技术准备、定题设计。查阅技术资料（读源代码，向老师请教定题方向）</p>

<p>7.10 - 9 月 coding</p>

<p>9 月以后 精化。</p>

<p>于是，开始啦～～</p>

<h3>2011-07-01</h3>

<p>期末考试完毕，我们计划用两周的时间预热，查阅 android 开发知识，想参赛的 idea。</p>

<h3>2011-07-10</h3>

<p>在与 hhl 老师的讨论中，突然想到了一个不错的点子。一个以贪吃蛇为背景，以水果忍者为游戏模式，以重力感应球为操控的 android 游戏：</p>

<p>重力感应操控蛇前进的方向，蛇不会撞墙死、撞自己死。只是不停的吃果子得分，游戏定时计分，不同的果子得分不同。</p>

<p>具体细节待定。游戏拥有自然的物理模型，游戏时，蛇就像在自己的手机上移动。</p>

<p>这个 idea 被 hhl 老师无情的鄙视了，说很早在电视上就有如此实现的游戏。当然，他也安慰我说，没事，在游戏逻辑中做些微创新也是不错的。</p>

<p>犹豫了几天，没有更好的点子，于是决定就是它了。</p>

<p>分工：我负责游戏逻辑、游戏动画的开发（我的手机重力感应功能比较好，I9000 啊~非广告哈~）。yzq 负责游戏整体框架开发。</p>

<h3>2011-07-18</h3>

<p>从 APIDemo 中得 Snake 游戏入手，了解了 android 游戏的框架。</p>

<p>并改良实现了能用重力感应控制方向的经典贪吃蛇（游戏逻辑混乱，且蛇的移动不是连续动画的）。</p>

<h3>2011-07-23</h3>

<p>搭建完成了初步的游戏逻辑（增加了自创的 Round 机制增加游戏的多样性），实现了基本构想，但动画效果很一般。</p>

<p>在暑假短学期的最后的展示课上，向全班同学展示了我们现阶段的成果。在跟大家的交流过程中，萌生了增加 移动的果子 的想法。</p>

<p>在动画实现方面，自己觉得要是做成不连续动画的话，只要控制好游戏风格，倒无所谓。但 hhl 老师坚持实现流畅的动画效果。</p>

<h3>2011-07-29</h3>

<p>重新构建了游戏框架，用 surfaceview 取缔原先的 view，独创的用特殊 patheffect 的 path 实现了蛇体的形状。动画和交互的流畅性。</p>

<h3>2011-08-07</h3>

<p>由于下学期要去爱尔兰交流半年，暑假回家两周。开发暂停。</p>

<h3>2011-08-22</h3>

<p>回到学校，开始与 yzq 的模块拼接工作。</p>

<h3>2011-08-25</h3>

<p>完成拼接工作，开始详细讨论游戏的精华改进。（此时还没有像样的 UI）</p>

<p>定游戏主题为 Kongfu Snake &#8211; 功夫蛇。</p>

<h3>2011-08-27</h3>

<p>在学校的 CC98 论坛上，征到工业设计的 mdd 童鞋，为我们设计 UI。三人团队组建完成。</p>

<h3>2011-09-08</h3>

<p>经过不断的改进、测试，攻克了一些第一次开发中遗留的问题（特别是游戏状态保存的问题），经过几个几近通宵夜晚共同讨论，我们的 Kongfu Snake 终于拥有了自己主题的  UI 和相对完整的功能。</p>

<p>第二天我将踏上去爱尔兰的旅程。但开发并未终止。还有部分需要改进和善后的工作。</p>

<h3>2011-09-23</h3>

<p>由于 25 日有保研的远程电话面试，我和 yzq 最近搁置了手头的开发。祝我们好运。完事后继续最后的攻坚。</p>

<h3>2011-10-26</h3>

<p>已经提交了两周了，结果应该已经出了吧。下周二就有结果了。</p>

<p>bless 啊。</p>

<p>不过我自己感觉希望不大了。</p>

<p>华东赛区前 6 才能进全国决赛。而我们浙大华东赛区是评审单位，我已经看到一个工业设计的同学，做的一个 3D 的游戏，可玩读很不错，虽然细节方面有些 bug。自认为要是评选，他们会排在前面，而 android 应用，学校应该还潜伏着很多高手吧，毕竟，这个入手比较简单。估算从中再产生一个前 6，我想浙江大学作为主评的单位，从避嫌的角度也不会推上去太多明额，两个合适，三个最多了。唉，真担心我们的作品>&lt;&#8230;</p>

<p>只能期待奇迹发生了。</p>

<p>评委老师们要给力啊！</p>

<h3>2011-10-31</h3>

<p>最后一天了，突然觉得好紧张啊。明天就公布区域塞的结果了。</p>

<p>如果。。如果。。。</p>

<p>求 RP 啊。。。。。</p>

<p>唉，虽然说眼光放长远，学习知识最重要，但是还是想获得一些奖励作为 mark 啊～～</p>

<p>看明天吧</p>

<h3>2011-11-1</h3>

<p>i&#8217;m so glad that we&#8217;ve got the second prize in eastern China competition!!</p>

<p>And let&#8217;s moving on to the national competition!!!</p>

<p>I&#8217;ll turn to some friends who has some experience in user interaction to give some advice  about our android game,
and then make a plan to do a better work.
I think we will make it open source and put the game into the market finally, but not now, we should make it better first!<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/09/05/google-android-challenge-2011/'>http://biaobiaoqi.github.com/blog/2013/09/05/google-android-challenge-2011/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[biaobiaoqi的博客日志]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/09/01/blog-log/"/>
    <updated>2013-09-01T01:40:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/09/01/blog-log</id>
    <content type="html"><![CDATA[<p>鉴于友言的客服不搭理的态度和时而无法正常显示以及管理界面的难以使用，决定将评论系统切换到 disqus 上。</p>

<p>最近一直在更改博客的定制。就像一个人一样，产品也是由生命的，她的脚印就是她价值的体现。于是我萌生了将她的改变全部记录下来的想法，只恨没有在四个月前刚建起博客时就意识到这一点。</p>

<p>这就是本文的初衷了。</p>

<p>&#8211; 2013/9/1</p>

<h2>历史</h2>

<ul>
<li><p>2013/4 octopress 博客在 github 上成功搭建</p></li>
<li><p>2013/5 拟定了“首页”、“技术”、“生活”、“关于”的顶栏 tag 结构，增加了友言评论功能，jiathis 分享功能，侧边栏的微博秀和豆瓣秀。</p></li>
<li><p>2013/7 侧边栏增加标签云，并增加了“标签云”顶栏 tag。取消侧边栏微博秀。</p></li>
<li><p>2013/8 更换博客主题为 whitelake。</p></li>
</ul>


<!--more-->


<ul>
<li>2013/9/1 取消友言评论功能，采用 disqus 评论系统。</li>
</ul>


<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/09/01/blog-log/'>http://biaobiaoqi.github.com/blog/2013/09/01/blog-log/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[octopress第三方插件：博文同步工具syncPost]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/08/31/octopress-3rd-party-plugin-syncpost/"/>
    <updated>2013-08-31T19:30:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/08/31/octopress-3rd-party-plugin-syncpost</id>
    <content type="html"><![CDATA[<p>为了增加外链等考虑，独立博客往往有将博文同步到其他博客社区的需求。自己人肉黏贴的方式笨拙、重复，对于程序猿而言，着实不可取。</p>

<p>我在 github 上找到了 <a href="https://github.com/huangbowen521/octopress-syncPost">syncPost</a> 这个针对 octopress 的第三方工具，能够通过一些论坛提供的 <a href="http://en.wikipedia.org/wiki/MetaWeblog">metaWeblog</a> 服务实现 octopress 最新一篇博文的同步提交。</p>

<p>这大概就是我要找的东西吧。不过，其中有些细节并不是我想要的：</p>

<ul>
<li>1.在本地配置文件存储论坛账户的密码。虽然可以设置为 ignore 不提交到 git 代码库中，但这也并不安全。</li>
<li>2.只能同步最新的一篇博客，没有整体的博文搬家功能。</li>
<li>3.先比其他的 octopress 插件，原来版本的代码结构难于维护，比如有自己单独的配置文件，而不是使用全局的<code>_config.yml</code>(在那个版本中大概是为了不把明文密码提交到版本库中)，比如 ruby 文件单独在一个<code>_custom</code>文件夹下等</li>
</ul>


<p>基于这些点，我 fork 了 <a href="http://huangbowen.net/">huangbowen</a> 大哥的代码，定制成了它<a href="https://github.com/biaobiaoqi/octopress-syncPost">现在的样子</a>。</p>

<!--more-->


<h2>功能</h2>

<p>通过 rake 的方式实现同步功能：</p>

<ul>
<li>1.同步所有 octopress 的博文到目标博客。 (<code>rake sync_all_posts</code>)</li>
<li>2.同步最新一篇博文到目标博客。(<code>rake sync_lates_post</code>)</li>
</ul>


<h2>开发</h2>

<p>这个 octopress 插件的结构很简单：</p>

<ul>
<li>安装<code>nokogiri</code>和 <code>metaweblog</code>两个 gem。前者实现对 octopress 生成的 html 页面的解析，找到对应的博文。提供了客户端发起 MetaWeblog 请求的功能。</li>
<li>在全局配置文件<code>_config.yml</code>中配置了目标博客 MetaWeblog 的服务地址、用户的账号信息。</li>
<li>octopress/plugins/sync_*.rb 三个文件则是代码实现。其中 sync_post.rb 中包含了 post 类，是主要的逻辑代码所在，sync_all_posts.rb 和 sync_latest_post.rb 则是对前者的调用。</li>
<li>修改了 octopress 的 Rakefile，通过 rake 的方式实现功能。</li>
</ul>


<h2>下一步</h2>

<p>希望能进一步完善这个插件，现在考虑到的有：</p>

<ul>
<li>增加同步所有博文功能中，对目标博客中已有博文的查重功能。即对于已经同步过去的博客，不再发送请求，或者实现编辑功能的同步功能。由于站点的 MetaWeblog 服务大多对请求有时限控制，同步过程中可能出现中断，此时部分博文已经同步过去，而部分没有，这种情况下，暂时没有好的解决方式。</li>
<li>测试其他有 MetaWeblog 服务的博客站点（现在仅测试了 cnblog）。</li>
<li><del>cnblog 的博文显示中，似乎不支持 octopress 的代码块样式。</del> (注：原作者 huangbowen 大哥已经解释了是 css 样式的问题)</li>
</ul>


<p>欢迎感兴趣的朋友参与到这个 repo 中来:)</p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/08/31/octopress-3rd-party-plugin-syncpost/'>http://biaobiaoqi.github.com/blog/2013/08/31/octopress-3rd-party-plugin-syncpost/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PAT 1061 - 1064 题解]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/08/31/pat-1061-pat-1064/"/>
    <updated>2013-08-31T13:32:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/08/31/pat-1061-pat-1064</id>
    <content type="html"><![CDATA[<p>这四道题来自 13 年 08 月 30 的 PAT 测试。</p>

<p>代码量不大，思路也比较直接。不过第一题的处理逻辑不太清晰，需要好好把握。稍有不慎就掉进坑里了（很多人被这道 20‘的题坑了一个多小时心慌意乱我会乱说-，-？）。</p>

<p>PAT advanced level 全部源码：<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/tree/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel">请戳</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1061">1061. Dating (20)</a></h2>

<h5>题意</h5>

<p>题意比较模糊，需要仔细对照 Sample 的数据理清思路。给定四个字符串，每个不超过 60 个字符，不含空格。要求从中找到符合如下规定的三个字符（或者它们的位置），并转化成一个时间的表达：</p>

<ul>
<li>1.依次比较前两个字符串中每个位置的元素，找到第一个相等的字符，且该字符属于[&#8216;A&#8217;, &#8216;G&#8217;]的字母，注意大小写敏感。转换成一周七天输出。</li>
<li>2.在 1 中的字符出现之后，继续比较前两个串，找到一个相等的字符，使它属于[&#8216;0&#8217;, &#8216;9&#8217;] || [&#8216;A&#8217;, &#8216;N&#8217;]，同样，大小写敏感。转换成一天 24 小时的小时数输出。</li>
<li>3.比较后两个字符串，找到第一个相等的字母（isalpha()），将它在数组中的位置值转换分钟数输出。</li>
</ul>


<p>为了便于理解，给出 Sample 数据:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Sample Input:
</span><span class='line'>
</span><span class='line'>3485djDkxh4hhGE 
</span><span class='line'>2984akDfkkkkggEdsb 
</span><span class='line'>s&hgsfdk 
</span><span class='line'>d&Hyscvnm
</span><span class='line'>
</span><span class='line'>Sample Output:
</span><span class='line'>
</span><span class='line'>THU 14:04
</span></code></pre></td></tr></table></div></figure>


<h5>分析</h5>

<p>理清题目的逻辑以后，实现起来是很简单的。</p>

<p>pat1061 源码:<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel/APAT1061.cpp">请戳</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1062">1062. Talent and Virtue (25)</a></h2>

<h5>题意</h5>

<p>给定一堆人，每个人有三条记录：id，道德值(v)，才能值(t)。给出两个值 L 和 H，用作对这堆人的分类。按照如下规则输出排序结果：</p>

<!--more-->


<ul>
<li>0.过滤掉 v 和 t 都小于 L 的人</li>
<li>1.v 和 t 都不小于 H 的人是圣人，属于最高的层级，排序在其他层级之前。</li>
<li>2.v 不小于 H，而 t 小于 H 的人是君子，这个层级排在圣人之后。</li>
<li>3.剩下的人中，v 不小于 t 的人是愚人，层级关系里排第三，排在所有圣人和君子之后。</li>
<li>4.最后剩下的人是小人，是最低的层级。</li>
<li>5.排名时，相同层级的人的排序关系是 1.按照 v+t 的总分 non-increasing 排序；2.按照 v 的分值按 non-increasing 排序；3.找到 id 按 increasing 排序。</li>
</ul>


<h5>分析</h5>

<p>题意梳理清楚以后，定制比较函数用 qsort()能很快的实现。</p>

<p>经测试，使用<code>cout</code>，<code>cin</code>会超时，改用&#8217;printf() scanf()&#8217;轻松过。</p>

<p>pat1062 源码:<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel/APAT1062.cpp">请戳</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1063">1063. Set Similarity (25)</a></h2>

<h5>题意</h5>

<p>题目给出了 N(&lt;=50)个正整数集合（实际上不是真正意义上的 set，有重复数值），每个集合最多存 M(&lt;10<sup>4)个元素，其中数值范围是</sup> [0, 10<sup>9]。给出</sup> K 次查询，每次查询条件为两个集合，要求求出两集合的相似度。</p>

<p>这里集合相似度的定义是 Nc/Nt*100%，其中 Nc 为两集合的交集元素数量，Nt 为两集合的并集的元素数量。</p>

<h5>分析</h5>

<p>思路一：</p>

<p>利用<code>sort()</code>对数组做排序，然后遍历去重。计算交集时，直接用两个游标对数组遍历进行比较操作，并集等于两者的大小之和减去交集的大小。复杂度为 O(M<em>K + N</em>M*logM)。这种游标遍历的思想，还是很 common sense 的处理方式，精妙之处在于循环判断和内部的判断逻辑的分离，让代码清晰明了。</p>

<p>思路二：</p>

<p>有不愿意透露姓名的<a href="http://weibo.com/cloudbye">@草原</a>同学提出，使用 set 做去重是没问题的。</p>

<p>pat1063 源码:<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel/APAT1063.cpp">请戳</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1064">1064. Complete Binary Search Tree (30)</a></h2>

<h5>题意</h5>

<p>给定一串数据，要求构建完全二叉搜索树。</p>

<h5>分析</h5>

<p>常规思路：</p>

<ul>
<li>对数据排序</li>
<li>递归的构建二叉搜索树，递归条件为根据有序数组找到子树顶点，顶点位置需要满足完全二叉树的结构。</li>
<li>最后用 queue 输出层序遍历。</li>
</ul>


<p>实现起来需要注意各种边界条件的判定，坑比较多，且代码量比较大（我的参考代码里写了 70 行）。后来<a href="http://weibo.com/redow7">@Redow7</a> 给介绍了一种更有趣的方法：</p>

<ul>
<li>0.对数据排序，等待操作。</li>
<li>1.首先构建好完全二叉树。</li>
<li>2.利用二叉搜索树的中序遍历的有序性，在中序遍历的过程中，将排序好的数据插入其中。</li>
</ul>


<p>如此一来，难点就转移到了构建完全二叉树上。</p>

<p>联想到最大堆的数组实现：父节点坐标为 n 时，左儿子为 2<em>n，右儿子为 2</em>n+1。对的，数组实现的二叉树就是满足完全二叉树的特点的。构建完全二叉树的步骤直接缩减为定义一个一定长度的数组。</p>

<p>于是，使用数组实现的二叉树做迭代的思路就出来了，30 行搞定。</p>

<p>pat1064 源码:<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel/APAT1064.cpp">请戳</a><p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/08/31/pat-1061-pat-1064/'>http://biaobiaoqi.github.com/blog/2013/08/31/pat-1061-pat-1064/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分布式事务slides]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/08/26/distributed-transaction/"/>
    <updated>2013-08-26T23:49:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/08/26/distributed-transaction</id>
    <content type="html"><![CDATA[<p>最近看了<a href="http://book.douban.com/subject/21624776/">《分布式系统概念与设计 第 5 版》</a>的分布式事务章节，整理了一份 ppt。还有恢复部分没有收录进来，有空再整理啦。</p>

<p>下面是传到 deckspeaker 上的 slides 展示:</p>

<script async class="speakerdeck-embed" data-id="aa521420f0a101303be246475d95d052" data-ratio="1.33333333333333" src="http://biaobiaoqi.github.com//speakerdeck.com/assets/embed.js"></script>


<p>下载链接：<a href="https://dl.dropboxusercontent.com/u/64021093/slides/distributed%20transcation.pptx">请戳</a><p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/08/26/distributed-transaction/'>http://biaobiaoqi.github.com/blog/2013/08/26/distributed-transaction/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PAT练习题概览]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/08/03/overcome-pat/"/>
    <updated>2013-08-03T22:20:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/08/03/overcome-pat</id>
    <content type="html"><![CDATA[<p>PAT(<a href="http://pat.zju.edu.cn">pat.zju.edu.cn</a>)是一个面向 C/C++程序的 Online Judge 系统。相比 ZOJ，HDOJ，POJ 等 ACM 题库，PAT 的题目非常基础，对于数据结构、算法的入门是比较有助益的。</p>

<p>本文按照自己的认识，给 PAT advanced level 做出了分类。由于很多题目实际上兼顾有多种解法和思路，我给每道题打上了 tag，来应对分类的独占性局限，供大家参考。</p>

<h2>简单题</h2>

<p>这类题几乎不需要数据结构、算法基础，主要通过简单的逻辑流程和判断实现。</p>

<ul>
<li>1001 A+B</li>
<li>1002 多项式相加</li>
<li>1005 简单 hash</li>
<li>1006 选极值</li>
<li>1008 模拟电梯</li>
<li>1009 多项式乘法</li>
<li>1011 选极值</li>
<li>1019 数字/字符处理</li>
<li>1024 数字/字符处理</li>
<li>1027 数字/字符处理，简单 hash</li>
<li>1031 数字/字符处理</li>
<li>1035 简单 hash<!--more --></li>
<li>1036 选极值</li>
<li>1037 简单模拟</li>
<li>1040 数字/字符处理</li>
<li>1046 数字/字符处理</li>
<li>1050 数字/字符处理</li>
<li>1058 数字/字符处理</li>
<li>1060 数字/字符处理</li>
<li>1061 数字/字符处理，坑题</li>
<li>1063 数字/字符处理，游标</li>
</ul>


<h2>模拟题</h2>

<p>这类题也相对简单，需要使用到一些简单的数据结构或者相对复杂的逻辑流程实现。</p>

<ul>
<li>1022 倒排索引</li>
<li>1023 数字/字符处理</li>
<li>1032 链表</li>
<li>1049 计算数字中的 1</li>
<li>1051 模拟栈</li>
<li>1052 链表</li>
<li>1054 dominant color</li>
<li>1056 模拟分组淘汰赛</li>
</ul>


<h4>排队模拟</h4>

<p>下面三道模拟题是针对排队模型处理的：</p>

<ul>
<li>1014 排队问题</li>
<li>1017 排队问题</li>
<li>1026 排队问题</li>
</ul>


<h4>排序模拟</h4>

<p>这几道模拟题侧重在使用排序方法：</p>

<ul>
<li>1012 排序</li>
<li>1016 排序，模拟电话账单计算</li>
<li>1025 排序</li>
<li>1028 排序</li>
<li>1029 归并排序</li>
<li>1038 递归，排序</li>
<li>1062 排序</li>
</ul>


<h4>时间优化</h4>

<p>这几道题需要做好时间优化才能 ac。</p>

<ul>
<li>1044 搜索，时间优化</li>
<li>1039 倒排索引，hash，时间优化</li>
<li>1047 倒排索引，hash，时间优化</li>
<li>1055 排序，时间优化</li>
</ul>


<h4>素数判定</h4>

<ul>
<li>1015 素数</li>
<li>1059 素数</li>
</ul>


<h2>图</h2>

<ul>
<li>1003 最短路径</li>
<li>1018 最短路径</li>
<li>1030 最短路径</li>
<li>1034 dfs</li>
</ul>


<h2>搜索</h2>

<ul>
<li>1010 二分搜索，优化剪枝</li>
<li>1013 并查集/dfs</li>
<li>1021 并查集，dfs，图的直径</li>
<li>1054 dfs，优化剪枝</li>
</ul>


<h2>树</h2>

<ul>
<li>1004 dfs，树遍历</li>
<li>1020 二叉树遍历</li>
<li>1043 二叉树遍历</li>
<li>1064 重建完全二叉搜索树</li>
</ul>


<h2>Hash</h2>

<ul>
<li>1041 hash</li>
<li>1042 hash</li>
<li>1048 hash</li>
</ul>


<h2>分治</h2>

<ul>
<li>1007 最大子连续序列</li>
</ul>


<h2>贪心</h2>

<ul>
<li>1033 贪心</li>
</ul>


<h2>动态规划</h2>

<ul>
<li>1045 DP，最长递增子序列</li>
</ul>


<h2>树状数组</h2>

<p>树状数组是一种神奇的数据结构，在 1057 题中其神奇的效果得到了很好的体现。</p>

<ul>
<li>1057 树状数组，模拟栈，二分搜索</li>
</ul>


<h2>题解</h2>

<p>截止 2013-08-03，PAT advanced level 的 60 道题全部题解和代码已经发布在本博客中，链接如下：欢迎讨论大家;)</p>

<ul>
<li><a href="http://biaobiaoqi.me/blog/2013/07/31/pat-1001-1010-solutions/">《PAT 1001-1010 题解》</a></li>
<li><a href="http://biaobiaoqi.me/blog/2013/07/31/pat-1011-1020-solutions/">《PAT 1011-1020 题解》</a></li>
<li><a href="http://biaobiaoqi.me/blog/2013/08/01/pat-1021-1030-solutions/">《PAT 1021-1030 题解》</a></li>
<li><a href="http://biaobiaoqi.me/blog/2013/08/01/pat-1031-1040-solutions/">《PAT 1031-1040 题解》</a></li>
<li><a href="http://biaobiaoqi.me/blog/2013/08/01/pat-1041-1050-solutions/">《PAT 1041-1050 题解》</a></li>
<li><a href="http://biaobiaoqi.me/blog/2013/08/01/pat-1051-1060-solutions/">《PAT 1051-1060 题解》</a></li>
<li><a href="http://biaobiaoqi.me/blog/2013/08/31/pat-1061-pat-1064/">《PAT 1061-1064 题解》</a></li>
</ul>


<p>附博客的 PAT 专题区链接：<a href="http://biaobiaoqi.me/tags/pat/">请戳</a><p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/08/03/overcome-pat/'>http://biaobiaoqi.github.com/blog/2013/08/03/overcome-pat/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PAT 1051-1060 题解]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/08/01/pat-1051-1060-solutions/"/>
    <updated>2013-08-01T01:43:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/08/01/pat-1051-1060-solutions</id>
    <content type="html"><![CDATA[<p>浏览全部代码：<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/tree/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel">请戳</a></p>

<p>本文谨代表个人思路，欢迎讨论;)</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1051">1051. Pop Sequence (25)</a></h2>

<h4>题意</h4>

<p>给定 stack 的容量，给定数据的入栈顺序：从 1 开始的正整数序列，在允许随机的出栈操作的情况下，要求判断某出栈序列是否可能。</p>

<p>比如，告知 stack 容量为 5，入栈序列的最大值为 7。有两个序列需要判断合理性：</p>

<ul>
<li>{1 2 3 4 5 6 7}： 这个序列是可能的，只需每次入栈时都做出栈操作。</li>
<li>{3 2 1 7 5 6 4}： 这个序列是不可能的，其中前半部分 3 2 1 是合法的，先将 1 2 3 顺序入栈，然后三次执行出栈操作。而之后的 7 5 6 则是不可能的。</li>
</ul>


<h4>分析</h4>

<p>两种思路：</p>

<h5>第 1 种思路：</h5>

<p>使用 stl 中的 stack 模拟。判定条件有两条：1.栈中数据量不超过栈的容量；2.出栈只能从栈顶取，不应该出现从固定的堆栈中取出其他数据的情况。</p>

<h5>第 2 种思路：</h5>

<p>由于入栈序列数据由小到大排列非常特殊，要通过出栈序列判定可能性是存在简便思路的。
对比分析题中 Sample 给出的序列，结合上面提到的两条冲突条件入手分析：</p>

<ul>
<li><p>1.栈中数据量不超过栈的容量：</p>

<p>  只有在入栈时，才会需要考虑栈中数据是否超量。出栈序列中的每个数，都以为着在出栈操作之前，它刚入栈，
  那么当它入栈的时候能否判定是否超过栈容量呢？可以的，（当前的出栈数值 - 已经执行过的出栈操作数量）就是当前栈中元素的数量。</p></li>
<li><p>2.出栈只能从栈顶取，不应该出现从固定的堆栈中取出其他数据的情况。</p>

<p>  根据观察分析发现，当某数据 m 出栈之后，比 m 小的数据如果在 m 之后出栈的，它们所组成的序列本身需要保持从大到小的顺序排列。
  距离如 3 2 1 7 5 6 4 这个序列，在 7 之后有 5 6 4 这个子序列，它们都大于 7，但却没有保持一个递减的顺序，不合法。</p></li>
</ul>


<p>更多分析参见博文<a href="../../../../2013/07/16/verify-pop-sequence-for-stack/">《出栈序列的可能性判定》</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1052">1052. Linked List Sorting (25)</a></h2>

<h4>题意</h4>

<p>链表的节点被表示为{地址， 值， 下一个指针地址}，其中如果 NULL 的地址表示为-1，
地址为 5 正数，值的范围为[-10<sup>5,</sup> 10<sup>5]。</sup></p>

<p>给定 N(&lt; 10<sup>5)个节点以及其头指针，要求按照每个节点上值的大小重新排序，并按照链表顺序输出每个节点。</sup></p>

<h4>分析</h4>

<p>将链表中的节点按值做 qsort()排序，然后调整每个值的 next 指针即可。需要注意的有：</p>

<ul>
<li>1.INPUT 中的节点并不保证全是链表中的，先需要过滤掉悬空的节点。</li>
<li>2.head 直接指向-1(NULL)的情况需要特殊处理。</li>
</ul>


<!--more-->


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1053">1053. Path of Equal Weight (30)</a></h2>

<h4>题意</h4>

<p>给定一棵树，有 N( &lt;= 100) 个节点，每个节点有一个权重，另给定一个权重值 S(&lt; 230)。要求找到从根节点出发到叶节点的路径上，所有点权重值和等于 S 的所有情况，并按照逆字典序输出。</p>

<h4>分析</h4>

<p>使用邻接表的方式构建树，dfs 搜索，由于需要逆字典序输出，处理前需要对每个节点的儿子节点邻接表进行排序，合理剪枝即可。</p>

<p>需要注意的是：结果路径要求以叶子节点结束。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1054">1054. The Dominant Color (20)</a></h2>

<h4>题意</h4>

<p>给定一个 M(&lt;= 800)*N(&lt;=600)个像素点，每个像素点的范围为 [0, 2<sup>24]，要求找出其中出现次数超过总数量的一半左右的点，称作</sup> restrict dominant color.</p>

<h4>分析</h4>

<p>由于条件比较特殊，使用一个计数器<code>count</code>，一个寄存器<code>color</code>就可以实现对超过一半数目的选项的挑选。过程如下：</p>

<ul>
<li>1.<code>count</code>初始化为 0，<code>color</code>初始化为-1</li>
<li>2.读入新的颜色值<code>newColor</code>，如果<code>newColor</code>跟寄存器的<code>color</code>一样，则计数器<code>count</code>加一。如果不一样，且<code>count</code>不为 0，则<code>count</code>减一；如果不一样，且<code>coun</code>t 为 0，则寄存器中的<code>color</code>被置为<code>newColor</code>。</li>
<li>3.不断循环 2，直到读入所有颜色值。这时候，寄存器<code>color</code>中存储的就是结果。</li>
</ul>


<p>这个方法的巧妙之处，在于寄存器和计数器保存了状态，用抵消的思想，最终得到了较多数量的状态。思考时，不妨假设所有颜色值只有两个，一个是超过一半数量的 restrict dominant color，另一个则是少于一半数量的颜色，经过累加和寄存的操作，少于一半的颜色肯定会被多余一般的颜色抵消掉，最后剩下多于一半的颜色。另外，大家不妨想一下，本题的最后，计数器中的值就是 restrict dominant color 超过其他颜色的数量么？</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1055">1055. The World&#8217;s Richest (25)</a></h2>

<h4>题意</h4>

<p>福布斯排行榜上，给出了 N(&lt;=10<sup>5)个人的名单，每个名单包含了不超过</sup> 8 个字符的姓名，(0,200]的年龄以及[-10<sup>6,10<sup>6]的财富值。</sup></sup></p>

<p>另外，给出了 K(&lt;=10<sup>3)次查询，以及每次查询要求的结果条数</sup> M(&lt;=100)。每次查询给定一个年龄区间，要求查询出这个区间范围内财富排名前 M 的人的名单。如果财富值相同，按姓名字典序排列。</p>

<h4>分析</h4>

<p>这道题时间限制比较严格。有两种思路：</p>

<h5>第 1 种思路：</h5>

<ul>
<li>1.所有年龄做 qsort()排序；</li>
<li>2.分离到不同年轻的人的数组中，此时每个年龄中，都是排序好的。</li>
<li>3.对于每个查询，从 2 中所得数组里进行归并排序，归并的每次比较过程，使用最大堆实现。</li>
</ul>


<h5>第 2 种思路：</h5>

<ul>
<li>1.所有年龄做排序</li>
<li>2.对排序好的年龄，每个年龄计数减掉 100 名之后的人。</li>
<li>3.然后对待查询轮训过滤即可。</li>
</ul>


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1056">1056. Mice and Rice (25)</a></h2>

<h4>题意</h4>

<p>分组淘汰赛背景。给出 Np(&lt;=1000)个参赛者，限定每场比赛最多有 Ng(&lt;=1000)个参赛者参加，如果一轮比赛中，组队的过程单出几个人，也将他们组成一次比赛。每场比赛决出一名胜者，参加到下一轮的淘汰赛中，而同一轮的负者都拥有相同的排名，如此循环往复，直到决出第一。</p>

<p>输入数据中还规定了必须依据顺序分组，而初始顺序体重已经给出。</p>

<h4>分析</h4>

<p>模拟题。用队列存储剩下的参赛队员，每轮比赛做一次循环，直到队列为空。处理一轮比赛时，负者的 rank 等于该轮比赛场次+1.换分组别的时候，需要仔细。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1057">1057. Stack (30)</a></h2>

<h4>题意</h4>

<p>在 stack 的基础上，增加了一个 PeekMedian 操作定义，要求输出 stack 中所有数据的中间大小的数。</p>

<p>题目给出 N(&lt;=10<sup>5)个对</sup> stack 的顺序操作，要求输出操作结果。其中保证每次操作的值不大于 10<sup>5。</sup></p>

<h4>分析</h4>

<p>使用 stl 中的 stack 模拟常规栈操作，关键问题在于中位数的读取。由于时间限制比较严格，使用诸如优先队列等方式会超时。考虑到每次的操作数都不超过 10<sup>5，想到诸如使用</sup> hash 的方式用空间换时间。但即使是开一个<code>int hash[100001]</code>的 hash 表，也只能记录读入的所有数据的次数，无法提供高效的查询操作。实际上，在 hash 方式的前提下，使用<a href="http://dongxicheng.org/structure/binary_indexed_tree/">树状数组</a>能很好的解决这个问题。 （另有一篇详细介绍树状数组的译文:<a href="http://hawstein.com/posts/binary-indexed-trees.html">请戳</a>）</p>

<p>对<code>int hash[100001]</code>建立树状数组，然后通过二分的方式，就可方便的查询到 hash 数组中那个坐标下的统计值处于中间位置，这个坐标的值也就是中位数了。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1058">1058. A+B in Hogwarts (20)</a></h2>

<h4>题意</h4>

<p>给定的数的结构如下：a.b.c，其中 a 的范围是 [0, 10<sup>7]，b</sup> 的范围是 [0,17)，c 的范围是 [0,29)。给定两个数，要求计算他们的和。</p>

<h4>分析</h4>

<p>简单模拟题，有一个坑：题目交代最高位的区间为 [0, 100000000]，但是没说如果两数相加超过这个值怎么办。需要将最高位的结果区间设定为 20000000 以上才 AC。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1059">1059. Prime Factors (25)</a></h2>

<h4>题意</h4>

<p>给定一个正整数，要求格式化输出它的素因数相乘的形式。</p>

<h4>分析</h4>

<p>由于时间限制，不可以简单的重复判定素数。可以使用 DP 的思想做素数的判定。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1060">1060. Are They Equal (25)</a></h2>

<h4>题意</h4>

<p>科学计数法相关背景。假设机器只能存储 3 个有效数字，那么<code>12300</code>和<code>12358.9</code>在机器侠都表达都为<code>0.123*10^5</code>，他们相等。其中有效数字使用简单截尾方式，不进位。</p>

<p>给定两个不大于 10<sup>100</sup> 的非负整数，以及有效位数 N(&lt;=100)，要求计算在对应的精确位数下，两数的表达是否相等。</p>

<h4>分析</h4>

<p>由于非负整数非常大，不可使用 longlong 甚至精确度不高的 double，当做字符串来处理。</p>

<p>需要注意的一点是对值为 0 的情况的处理。比如 0 在有效位数为 3 下的表达为:<code>0.00*10^0</code><p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/08/01/pat-1051-1060-solutions/'>http://biaobiaoqi.github.com/blog/2013/08/01/pat-1051-1060-solutions/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PAT 1041-1050 题解]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/08/01/pat-1041-1050-solutions/"/>
    <updated>2013-08-01T01:43:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/08/01/pat-1041-1050-solutions</id>
    <content type="html"><![CDATA[<p>浏览全部代码：<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/tree/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel">请戳</a></p>

<p>本文谨代表个人思路，欢迎讨论;)</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1041">1041. Be Unique (20)</a></h2>

<h5>题意</h5>

<p>给出 N (&lt;=105)个数（数值范围为 [1, 10<sup>4]），找到其中不重复的第一个数字。比如给出</sup> <code>5 31 5 88 67 88 17</code> ， 答案是 <code>31</code> 。</p>

<h5>分析</h5>

<p>简单模拟题，开一个大数组<code>int a[10001];</code>，以读入的数为下标，记录 count:<code>a[index] ++;</code>。结果输出第一个存储为 1 的下标:<code>if (a[index] == 1)</code>。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1042">1042. Shuffling Machine (20)</a></h2>

<h5>题意</h5>

<p>背景是洗牌机的洗牌过程。过程是给定洗牌的每张牌的位置替换序列，由原来的次序算出最后的牌的平排列。</p>

<p>比如原有的次序为<code>S3, H5, C1, D13, J2</code>，
给定的洗牌顺序为<code>4, 2, 5 ,3 ,1</code>，那么一次洗牌的结果为：<code>J2, H5, D13, S3, C1</code>。
如果需要两次洗牌，则结果为<code>C1, H5, S3, J2, D13</code>。</p>

<p>输入为对一整副牌（54 张）的洗牌策略，以及洗牌次数 N，要求计算出最后的洗牌结果。</p>

<h5>分析</h5>

<p>简单 hash 题。</p>

<!--more-->


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1043">1043. Is It a Binary Search Tree (25)</a></h2>

<h5>题意</h5>

<p>二叉搜索树的定义就不重复了，题目新定义了一个镜像二叉搜索树，就是将一颗二叉搜索树所有节点的左右子树交换后的二叉树。</p>

<p>输入是一个二叉树的前序排列，要求判定是否是一个二叉搜索树或者镜像二叉搜索树。如果是，输出该树后序遍历的序列。</p>

<h5>分析</h5>

<p>解题思路：</p>

<ul>
<li>1.BST 很特殊，实质上 BST 的所有节点的顺序排列就是中序遍历了。</li>
<li>2.要检查树是否是 BST 或者镜像 BST，只需按照重建树的思路，在每次重建的过程中做适当检查即可。检查思路是：检查前序遍历序列中，根节点之后的节点排序是否符合 BST 的二分规则（即前一段都是小于根节点的，后一段都是大于根节点的）。</li>
<li>3.最后的输出是后序遍历。过程中其实并不用构建整个树，直接在处理过程中，按后序的方式存储节点到队列中即可。</li>
</ul>


<p>更多相关分析，参见博文<a href="../../../../2013/04/27/pat1020-pat1043-rebuild-binary-tree/">《根据前中后序和层序重建二叉树》</a>。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1044">1044. Shopping in Mars (25)</a></h2>

<h5>题意</h5>

<p>火星人购物使用钻石链，每颗钻石都有一定的价值。付款是，要求从钻石链上找到所有刚好能匹配到商品价值的连续的钻石子链，如果没有，
则找到超过商品价值的最小的钻石子链。</p>

<p>比如钻石链为<code>3 2 1 5 4 6 8 7</code>，商品价值为<code>15</code>，则候选的方案有：第 4 到第 6 颗的子链<code>5 4 6</code>，第 7 到第 8 颗：<code>8 7</code>。</p>

<p>输入为一个钻石链以及商品的价值，要求找到所有满足条件的分割方案，按起始点从小到大排序输出。</p>

<h5>分析</h5>

<p>由于时间限制有些严格，需要做足够的优化：</p>

<ul>
<li>1.为了便于计算某个区间的累加值，在存储钻石串时，可以在<code>index</code>位置存储包括当前钻石在内的之前所有钻石价值的累加和。</li>
<li>2.使用两层循环遍历所有可能，在遍历以位置 i 为其实坐标的子串时，不应该将结束位置初始化为 i，而是应该是以<code>i-1</code>为起始位置的搜索过程中的 break 时的
结束位置的下标减 1.</li>
</ul>


<p>其中第 2 条的证明如下：</p>

<p>算法中首先计算以<code>i</code>为起始位置的子串的累加值。假定计算到<code>j</code>满足累加值等于或者刚好大于商品价值<code>m</code>。之后，结束以<code>i</code>位置开始的子串的探寻，进入下一阶段以 i+1 为起始位置的搜索。
由于<code>[i, j]</code>的累加和刚好等于<code>m</code>，则<code>[i, j - 1]</code>的累加和肯定小于<code>m</code>，那么<code>[i + 1, j - 1]</code>的累加和也肯定小于<code>m</code>。</p>

<p>综上述，在以<code>i+1</code>为起始位置的搜索中，可以初始化结束位置为上一次搜索结束的位置减一，即<code>j - 1</code>.</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1045">1045. Favorite Color Stripe (30)</a></h2>

<h5>题意</h5>

<p>Eva 对彩色条有特殊的癖好，对于一条五颜六色的彩带，她会减掉其中一些颜色块，让整个彩带的颜色顺序匹配到自己的一个颜色喜好顺序上。</p>

<p>举例来说，她喜欢的颜色顺序为{2 3 1 5 6}，给定的彩带的颜色顺序为{2 2 4 1 5 5 6 3 1 1 5 6}，那么经过她的剪辑，留下的彩带的可能选项有：{2 2 1 1 1 5 6}
{2 2 1 5 5 5 6}，{2 2 1 5 5 6 6}和{2 2 3 1 1 5 6}。</p>

<p>我们的任务是找到其中最长的剪辑可能。</p>

<h5>分析</h5>

<p>这是经典的最长递增子序列问题(LIS)，递增在这里体现为子序列的颜色顺序要遵照 Eva 的对颜色的喜好顺序。使用动态规划解决。</p>

<ul>
<li>1.剔除不在 Eva 喜欢颜色列表中的颜色。</li>
<li>2.DP 的状态： 用<code>length[max]</code>数组存储状态，<code>length[i]</code>表示到彩带的第 i 个位置为止，包含该颜色的符合 Eva 喜好顺序的子串长度的最长值。记得在每次</li>
<li>3.DP 的子问题：<code>length[i]</code>等于在其之前的所有<code>lengths[j]</code>跟<code>i</code>位置颜色组合后的最长子串值。</li>
</ul>


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1046">1046. Shortest Distance (20)</a></h2>

<h5>题意</h5>

<p>给定在圆环上的几个点的相对位置，要求计算不同点之间的距离。</p>

<h5>分析</h5>

<p>简单模拟。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1047">1047. Student List for Course (25)</a></h2>

<h5>题意</h5>

<p>根据每名学生填报的课程，按顺序输出每门课程的学生名单。其中学生总量为 N(&lt;=40000)，课程总量为 K(&lt;=2500)。学生姓名为 3 个大写英文字符加一个数字。</p>

<h5>分析</h5>

<p>倒排索引的模拟。可以针对学生姓名做 hash 方式的优化。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1048">1048. Find Coins (25)</a></h2>

<h5>题意</h5>

<p>给定一系列硬币，以及一个商品的价格。要求从硬币中找到两个硬币让他们的组合等于商品的价格。如果有多个，输出有用最小单个值的硬币组合。</p>

<h5>分析</h5>

<p>首先，硬币中币值不小于商品价格的可以过滤掉。遍历过程中，使用 hash 标记的方法，设定一个<code>coins[MAXVALUE]</code>（其中 MAXVALUE 为商品价格的最大值）记录已有的币值种类，
在遍历的过程中，一边将读入的硬币增加到<code>coins[]</code>中，一边计算满足条件的最小币值。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1049">1049. Counting Ones (30)</a></h2>

<h5>题意</h5>

<p>给定一个正整数 N(&lt;=2<sup>30)，要求计算所有小于</sup> N 的正整数的各个位置上，1 出现的次数之和。</p>

<h5>分析</h5>

<p>比较有思维难度的一题，核心在于找规律。10ms 的时间限制表明了不能用常规的循环遍历来解决。需要从简单的 case 找规律，逐步扩大到常规的情况。</p>

<p>详情参见《编程之美》P132 页《1 的数目》。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1050">1050. String Subtraction (20)</a></h2>

<h5>题意</h5>

<p>给定两个字符串，S1 和 S2,要求将 S2 中的字符从 S1 串中剔除。</p>

<h5>分析</h5>

<p>用 Hash 的方式标记需要剔除的字符。<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/08/01/pat-1041-1050-solutions/'>http://biaobiaoqi.github.com/blog/2013/08/01/pat-1041-1050-solutions/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PAT 1031-1040 题解]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/08/01/pat-1031-1040-solutions/"/>
    <updated>2013-08-01T01:43:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/08/01/pat-1031-1040-solutions</id>
    <content type="html"><![CDATA[<p>早期部分代码用 Java 实现。由于 PAT 虽然支持各种语言，但只有 C/C++标程来限定时间，许多题目用 Java 读入数据就已经超时，后来转投 C/C++。浏览全部代码：<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/tree/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel">请戳</a></p>

<p>本文谨代表个人思路，欢迎讨论;)</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1031">1031. Hello World for U (20)</a></h2>

<h5>题意</h5>

<p>将给定的字符串打印出 U 型。</p>

<p>比如给定<code>helloworld</code>，打印出</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>h  d
</span><span class='line'>e  l
</span><span class='line'>l  r
</span><span class='line'>lowo
</span></code></pre></td></tr></table></div></figure>


<p>设定左边的字符个数为 n1,底边字符个数为 n2,右边字符个数为 n3。需要满足 n1 = n3 = max
{k|k &lt;= n2 for all 3 &lt;= n2 &lt;= N} with n1 + n2 + n3 -3 = N.</p>

<h5>分析</h5>

<p>简单模拟题。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1032">1032. Sharing (25)</a></h2>

<h5>题意</h5>

<p>为了节省存储空间，单词使用链表实现。比如对于<code>loading</code>和<code>being</code>两个单词，有如下存储结构：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>word1 : -&gt; [l] -&gt; [o] -&gt; [a] -&gt; [d]  
</span><span class='line'>                                  \
</span><span class='line'>                                    [i] -&gt; [n] -&gt; [g] -&gt; null
</span><span class='line'>                                  /
</span><span class='line'>word2 : -&gt; [b] -&gt; [e] -------------
</span></code></pre></td></tr></table></div></figure>


<p>输入中，指定了两个单词的首字符的地址，并给出了 N (&lt;= 10<sup>5)个节点，每个节点包含：物理地址（5</sup> 位的正整数），实际存储的字符以及指向的下一个节点的地址。NULL 的地址是-1.
要求找到两单词的的公共后缀开始的地址，如果没有，则输出-1.</p>

<h5>分析</h5>

<p>既然是单词，它的长度应该是有限的，也就是链表不会出现环这种情况（实际上这里的处理方式对于有环无环都适用）。对第一个单词链表做遍历，对爬过的节点做好标记。第二个单词链表也同样做标记，一旦遇到已经标记过的节点，则该节点就是结果。</p>

<p>需要注意一点：直接使用 map 做节点的存储最后一个 case 会超时。而鉴于 5 位正整数的数据量，可以直接使用数组，用空间换时间。</p>

<!--more-->


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1033">1033. To Fill or Not to Fill (25)</a></h2>

<h5>题意</h5>

<p>高速路从 A 地到 B 地，路途有许多加油站，每个加油站的油价不一样，要求计算一个最优方案，使得以最便宜的开销跑完全程。</p>

<h5>分析</h5>

<p>用贪心算法，理清贪心算法的策略：</p>

<ul>
<li>1.从 A 加油站出发，在能行走的最大范围内，如果有比 A 站汽油更便宜的 B 站，则保证在 A 站点的加油量刚好满足能到达 B 站点；如果没有比 A 站汽油更便宜的站，则在 A 加满车油行走到【从 A 能走出的范围内】油价【最便宜】的站上，再行计算。</li>
<li>2.从 A 加油站出发，在能行走的最大范围内，如果没有其他站点，则 A.dist + 一次最大的行走距离 为 impossible 情况下的最大站点。</li>
</ul>


<p> 注意有个陷阱：如果没有距离为 0 的加油站，则无法行驶。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1034">1034. Head of a Gang (30)</a></h2>

<h5>题意</h5>

<p>『gang』翻译过来是『一伙人』。gang 的定义是一群人，至少有 3 个人，这群人中每个人之间都通过通话相连，且整个群体的通话时长超过一个阈值。整个 gang 的团体中，拥有的电话时长最长的人就是头目了。</p>

<p>题目给定了 gang 的阈值 K，以及 N 个通话记录，每条记录包括主叫人、被叫人以及通话时间。要求计算出有几个 gang，并按照 gang 的头目的字母顺序排序输出头目和其中成员数量。</p>

<h5>分析</h5>

<p>本题使用 dfs 求解比较方便。dfs 能简单的实现状态值的记录，比如当前的 gang 的成员数量和权重，如果使用并查集，则相对复杂。</p>

<p>需要注意的坑点：如果建立邻接表时，每个通话记录都在两人头上计算了时间积累的，那么在判定 gang 的权重值是否低于阈值的时候，需要对阈值乘以 2。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1035">1035. Password (20)</a></h2>

<h5>题意</h5>

<p>给定多个字符串，按要求替换其中的某些特殊字符，并按原顺序输出。如果字符串中没有需要修改的字符，则不舒服该字符串。</p>

<h5>分析</h5>

<p>简单的 hash 实现。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1036">1036. Boys vs Girls (25)</a></h2>

<h5>题意</h5>

<p>输入是一批学生的成绩，要求找出其中男生最低的成绩和女生最高的成绩，求其间的差值。如果无法计算，则输出 NA.</p>

<h5>分析</h5>

<p>简单模拟题。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1037">1037. Magic Coupon (25)</a></h2>

<h5>题意</h5>

<p>背景是火星上的神奇的购物券购物策略：每张购物券上有一个整数，可正可负，商店里商品的标价也是一个整数，可正可负的。如果用正值购物券购买正值商品，则可获利两者之积；如果以负值购物券购买负值商品，也可获利两者之积；但其他情况，则会亏损。比如用面值为<code>2</code>的购物券购买面值为<code>3</code>的商品，获利<code>6</code>，用面值为<code>-5</code>的购物券购买面值为<code>-9</code>的商品，获利<code>45</code>，但如果用面值为<code>2</code>的购物券购买面值为<code>-3</code>的商品，则亏损<code>6</code>，</p>

<p>给定一组数量为 NC 购物券面值和一组数量为 NP 的商品面值，1&lt;= NC , NP &lt;= 10<sup>5，要求计算能获利的最大值。</sup></p>

<h5>分析</h5>

<p>同号相乘可获利，异号相乘会亏损。要使获利最大，使用贪心思想计算。实际上，不需要用完购物券或者买完商品，所以只需要将同号的数值乘积算出即可，没有更复杂的情况。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1038">1038. Recover the Smallest Number (30)</a></h2>

<h5>题意</h5>

<p>给定 N(&lt;= 10000)个不超过 8 位的非负整数，要求将其按某个顺序拼接为一个数，使其值最小。</p>

<h5>分析</h5>

<p>容易简单的以为使用字典序排列拼接，实际上有一个特殊的拼接情况需要考虑。</p>

<p>比如数据<code>32 321 3214</code>，这是按字典序排列的，但实际上这并不是最小的拼接方式，最小的拼接方式是：<code>321 3214 32</code>。</p>

<p>比较这个实例，不难找到最小拼接的排序规律：</p>

<ul>
<li>1.两个字符串做比较时，如果其中一个字符串(a)是另一个字符串(ab)的前缀串，则需要将较长字符串(ab)除去前缀串的部分(b)与较短字符串(a)继续递归比较。比如，321 和 32，需要拿 1 和 32 做比较。又比如 323 和 32 比较，第一次拿 3 和 32 比较，第二次拿 3 和 2 按字典序比较。</li>
<li>2.其他情况按字典序比较。</li>
</ul>


<p>另外需要注意的一个坑是：如果没有数据，则输出 0。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1039">1039. Course List for Student (25)</a></h2>

<h5>题意</h5>

<p>给出 K(&lt;=2500)门课程，每门课程有 Ni(&lt;=200)名学生，学生编号为四位字符串，前三位为小写英文字母，后一位是数字。另给出 N 个需要查询的学生编号。</p>

<p>要求列出对应查询编号学生的课程。如果有多个课程，需要按升序输出。</p>

<h5>分析</h5>

<p>这个题是个倒排索引的实现。不过在时间上卡的比较严。</p>

<p>使用最简单的思路：map&lt;string, vector<int> students 倒排索引，在没有输出排序的课程列表时最后一个 case 已经超时；优化：将学生姓名的 hash 为 int，减免了 string 的匹配过程，还是超时（map 本身用红黑树实现，效率并不是特别高，还需要对每组数据进行排序），只能改变使用 map 的方式。</p>

<p>最终 AC 的解法是：</p>

<ul>
<li>构建一个从学生编号字符串到 int 值的 hash 函数，在读入学生编号后，hash 到 int 值做处理。</li>
<li>不适用 map 结构，根据学生姓名的限制，设定一个<code>vector&lt;int&gt; st[26*26*26*10]</code>的数据结构，读入时直接倒排索引插入。</li>
</ul>


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1040">1040. Longest Symmetric String (25)</a></h2>

<h5>题意</h5>

<p>给定一个字符串，要求输出最长的连续对称子串的长度。比如给定字符串为<code>Is PAT&amp;TAP symmetric?</code>，其中最长对称子串为<code>s PAT&amp;TAP s</code>，所以输出结果 11.</p>

<h5>分析</h5>

<p>这个题就是典型的 Java 实现 timeout，而 Cpp 实现轻松过的类型。需要注意两点：</p>

<ul>
<li>1.有两种对称情况，一种形如<code>aba</code>，一种形如<code>abba</code>。</li>
<li>2.循环遍历的过程，以 index 为对称中心向两边扩散比较编码实现简单也更高效。</li>
</ul>


<p>另外，C 读入一整行数据到 char 数组的方法可以用<code>gets(s);</code>。</p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/08/01/pat-1031-1040-solutions/'>http://biaobiaoqi.github.com/blog/2013/08/01/pat-1031-1040-solutions/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PAT 1021-1030 题解]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/08/01/pat-1021-1030-solutions/"/>
    <updated>2013-08-01T01:43:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/08/01/pat-1021-1030-solutions</id>
    <content type="html"><![CDATA[<p>早期部分代码用 Java 实现。由于 PAT 虽然支持各种语言，但只有 C/C++标程来限定时间，许多题目用 Java 读入数据就已经超时，后来转投 C/C++。浏览全部代码：<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/tree/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel">请戳</a></p>

<p>本文谨代表个人思路，欢迎讨论;)</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1021">1021. Deepest Root (25)</a></h2>

<h5>题意</h5>

<p>无环连通图也可以视为一棵树，选定图中任意一点作为根，如果这时候整个树的深度最大，则称其为 deepest root。
给定一个图，按升序输出所有 deepest root。如果给定的图有多个连通分量，则输出连通分量的数量。</p>

<h5>分析</h5>

<p>算法实现的步骤如下：</p>

<ul>
<li>1.使用并查集判断图是否为连通的。</li>
<li>2.任意选取一点，做 dfs 搜索，选取其中一个最远距离的点 A，再做一次 dfs，找到的所有距离最远的点以及点 A 都是 deepest root。</li>
</ul>


<p>判定图是否连通使用 union-find set 即可。更关键的点在于找到 deepest root。实际上，使用两次 dfs 就可以实现。
证明之前，先介绍两个概念，一个是直径，树的 deepest root 到最远叶子的路径我们暂称直径，而 deepest root 和最远叶子节点则成为端点。
注明关键在于以下两点：</p>

<ul>
<li><p>从任意一个点 dfs 得到的最远点都是直径的端点。证明如下：</p>

<p>  任意选一点 A，做 dfs 查找距离 A 最远的点，因为是 dfs，所以肯定会经过某直径上的点 B，从 B 出发最远的点是直径上的端点 C。
  那么，这个端点 C 为何一定是 A 的最远居里点呢？可以反证证明，如果有一个点 D，A->D 不经过直径，且 length(A->D) > length(A->C)，
  那么，从 C 所在直径上构造出经过 D 的比原直径更长的直径，得证。</p></li>
<li><p>所有的树的直径都交于一点（或者公用段路径上的几点）。
于是，从 B 点 dfs 出发的所有最长距离的点即为 deepest root。证明如下：</p>

<p>  如果两条直径不相交，而树上任意两点肯定连通，则从两直径上，可以选取两点连通以组成更长的直径；如果三条直径相较于不同的两点，也可以根据相交截断的长度组合出更长的直径。</p></li>
</ul>


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1022">1022. Digital Library (30)</a></h2>

<h5>题意</h5>

<p>给定 N (&lt;=10000) 本书的信息，包括 7 位 ID，最多 80 字符的书名，最多 80 字符的作者名，
多个最多 10 字符的关键词，最多 80 字符的出版商和属于 [1000, 3000]的出版时间。
另给出 M (&lt;=1000) 的查询请求，按照查询格式分为：</p>

<ul>
<li>1: 书名</li>
<li>2: 作者</li>
<li>3: 关键词</li>
<li>4: 出版商</li>
<li>5: 年份</li>
</ul>


<p>输出查询结果。如果有多个结果，按照书的 ID 的升序排列。</p>

<h5>分析</h5>

<p>简单模拟题。在使用 Map 结构来构建倒排索引的过程中，可以讨巧的避免根据不同查询类型使用两层 map，
直接通过在 key 中增加查询标记来实现。另外 C++的 priority_queue 支持对常规数据类型的最小堆实现：<code>priority_queue&lt;string, vector&lt;string&gt;, greater&lt;string&gt;&gt;</code>，方便了结果输出。</p>

<!--more-->


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1023">1023. Have Fun with Numbers (20)</a></h2>

<h5>题意</h5>

<p>给出一个 20 位的正整数，要求计算其乘以 2 的值，并判定结果的数值是否是原数字所有位数打乱的结果。结果输出 Yes 或 No，以及乘以 2 以后的数字。</p>

<h5>分析</h5>

<p>判重使用 Hash 思想。过程如下：</p>

<ul>
<li>1.原数字按字符串读入，并在一个 int hash[10]的 hash 数组中标记每个数值出现的次数，比如如果出现了四次 1，则 hash[1]=4。</li>
<li>2.模拟实现乘以 2 的简单乘法过程，没计算出一位的值，在 hash[]中对应位置上减一。</li>
<li>3.最后通过判定 hash 是否全为 1 和最后结果是否有进位来做判定。</li>
</ul>


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1024">1024. Palindromic Number (25)</a></h2>

<h5>题意</h5>

<p>非回文数可以通过将它与它的倒转数相加，并不断迭代这一过程获得回文数的结果。比如 67 经过两次处理就得到了 484：
<code>67 + 76 = 143, and 143 + 341 = 484.</code></p>

<p>给定一个数和迭代的次数，判断能否在迭代次数内获得回文结果。</p>

<h5>分析</h5>

<p>简单模拟题，处理数字，做逻辑判断。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1025">1025. PAT Ranking (25)</a></h2>

<h5>题意</h5>

<p>以 PAT 考试为背景，给所有人做排名。给定的数据包括 N(&lt;=100)为赛区的数目，每个赛区的人数以及每个人的分数。
按照总排名、分区号、注册号的优先级排名。</p>

<h5>分析</h5>

<p>简单模拟题，使用 qsort()排序，注意相同分数的人应该拥有相同的排名。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1026">1026. Table Tennis (30)</a></h2>

<h5>题意</h5>

<p>乒乓球俱乐部有 K 张乒乓球桌，其中有 M 张是 VIP 桌。有很多人到俱乐部打球，如果桌子都满了，多余的人只能排队等待。</p>

<p>有一个特殊的 VIP 制度：如果有空的 VIP 桌，那么等待队列中的第一对 VIP 会员可以使用这张卓，
如果等待队列中没有 VIP 会员，那么一般会员也可以使用 VIP 桌。当轮到 VIP 上的时候，没有 VIP 桌子，那么 VIP 用户也可以使用一般的桌子。</p>

<p>另外，每张桌服务一对会员的时间最大限制在两个小时。</p>

<p>给定了乒乓球桌的数量 M(编号为 1-M)，其中 VIP 卓的数量 K，并指定是那几张桌子。给出来乒乓球俱乐部的 N 对会员的信息，每对会员有一个达到时间，
是否是 VIP 的标记以及打球的时间。要求计算出每对会员的等待时间，以及每张桌服务过的次数。</p>

<h5>分析</h5>

<p>排队模拟题。有两种思路：</p>

<ul>
<li>1.主体循环处理人。将乒乓球桌和人都当做资源，乒乓球桌对应记录了 available 的时间，每次取出 available 最早的时间，从等待队列中选
则最早的会员使用乒乓球桌。其中 vip 处理逻辑为：如果 available 并列最早的桌子中有 vip 桌，则看等待队列中有没有 vip 会员，
如果有则直接处理他，否则按照正常逻辑处理。每次将某会员安置到一个乒乓球桌上，则可以输出该会员的等待时间的结果信息，并将该乒乓球桌的
服务人数增加一。</li>
<li>2.主体循环是时间。这样需要模拟同一时刻所有的乒乓球桌以及等待队列，相对比较复杂。</li>
</ul>


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1027">1027. Colors in Mars (20)</a></h2>

<h5>题意</h5>

<p>给定三个十进制数，要求格式化输出其 13 进制表达。</p>

<h5>分析</h5>

<p>简单的数字处理和 hash 实现。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1028">1028. List Sorting (25)</a></h2>

<h5>题意</h5>

<p>模拟 Excel 中按列排序。N (&lt;=100000) 为数据条数，每条数据由三列组成：ID，姓名，成绩。C 可以等于 1,2,3，分别对应到按三列中的哪一列排序。
输出排序结果。</p>

<h5>分析</h5>

<p>简单排序题。两种思路：</p>

<ul>
<li>1.简单的直接使用 qsort()实现。</li>
<li>2.自己手写排序算法，比如二叉搜索树实现。</li>
</ul>


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1029">1029. Median (25)</a></h2>

<h5>题意</h5>

<p>给定两个已排序的整数序列，求出两组数的集合里中间大小的数。</p>

<h5>分析</h5>

<p>使用归并排序思路实现。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1030">1030. Travel Plan (30)</a></h2>

<h5>题意</h5>

<p>给定加权图，每条边有两种权值：一是路径长度，二是开销。要求求出给点两点间的最短路径，如果路径长度一样，则要求比较选择开销最小的路径。</p>

<h5>分析</h5>

<p>使用 Dijkstra 算法的变形，增加一个权重的判定，可以轻松解决。<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.com/blog/2013/08/01/pat-1021-1030-solutions/'>http://biaobiaoqi.github.com/blog/2013/08/01/pat-1021-1030-solutions/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p></p>
]]></content>
  </entry>
  
</feed>
