<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Biaobiaoqi的博客]]></title>
  <link href="http://biaobiaoqi.github.com/atom.xml" rel="self"/>
  <link href="http://biaobiaoqi.github.com/"/>
  <updated>2013-04-19T22:15:30+08:00</updated>
  <id>http://biaobiaoqi.github.com/</id>
  <author>
    <name><![CDATA[Biaobiaoqi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SSH原理和使用]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/04/19/use-ssh/"/>
    <updated>2013-04-19T21:44:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/04/19/use-ssh</id>
    <content type="html"><![CDATA[<p>在linux上工作，ssh是必须要了解的技术方法。它可以建立起多台主机之间的安全的加密传输，以进行远程的访问、操控、传输数据。</p>

<h2>ssh是什么</h2>

<p>SSH為Secure Shell的縮寫。為建立在应用层和传输层基础上的安全协议。</p>

<p>传统的网络服务程序，如FTP、POP和Telnet其本质上都是不安全的；因为它们在网络上用明文传送数据、用户帐号和用户口令，很容易受到中间人（man-in-the-middle）攻击方式的攻击。就是存在另一个人或者一台机器冒充真正的服务器接收用户传给服务器的数据，然后再冒充用户把数据传给真正的服务器。
而SSH是目前较可靠，專为远程登录会话和其他网络服务提供安全性的协议。利用SSH协议可以有效防止远程管理过程中的信息泄露问题。透過SSH可以對所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗。
SSH之另一項優點為其传输的数据是经过压缩的，所以可以加快传输的速度。SSH有很多功能，它既可以代替Telnet，又可以为FTP、POP、甚至为PPP提供一个安全的「通道」。
了解这么多就好了，其实ssh连接也就是可以理解成经过加密的远程访问啦。</p>

<!--more-->


<p>&#8212;（来自中文维基）</p>

<h2>ssh连接的验证、加密方式</h2>

<p>ssh连接是CS模型（客户端-服务器），客户端发出连接申请，服务器对客户端进行验证，再考虑是否接受连接申请。</p>

<p>ssh的安全加密方式的理论基础是非对称加密体系。而非对称加密中，常见的一种就是RSA加密算法。在使用ssh，务必先弄清楚非对称加密和rsa的算法流程。详情参见<a href="http://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95">RSA加密算法</a>。</p>

<p>ssh有两种级别的安全验证：账户口令验证、rsa加密验证。详细参数，可以在sshd_config配置文件中设置(Ubuntu是/etc/ssh/sshd_config，mac下是/etc/sshd_config)</p>

<h3>账号口令验证</h3>

<p>直接输入所要登陆的用户的口令是默认的方式。不需要修改配置文件。</p>

<p>如果直接从客户端将用户密码传输到服务器，那么密码信息很容易被中间人截获，从而实现重放攻击。ssh的实现方式是：</p>

<ul>
<li>1.客户端向ssh服务器发出请求，服务器将自己的公钥返回给客户端；</li>
<li>2.客户端用服务器的公钥加密自己的登录密码，再将信息发送给服务器；</li>
<li>3.服务器接收到客户端传送的密码，用自己的私钥解码，如果结果正确，则同意登录，建立起连接。</li>
</ul>


<p>这种方式还是有漏洞的，中间人可以假扮成服务器，骗取客户端的密码。</p>

<h3>RSA加密验证</h3>

<p>rsa加密验证方式，充分利用了非对称加密体系的优势，不需要在网络传输密码，完全杜绝了中间人攻击的可能。步骤如下：</p>

<h5>准备工作</h5>

<ul>
<li>-1.客户端先使用 ssh-keygen 命令，生成私钥和公钥。按照默认配置，私钥会被保存在~/.ssh/id_rsa中，公钥则在~/.ssh/id_rsa.pub中。(一般别修改这里的文件)</li>
<li>0.客户端通过安全的方式将公钥发送给服务器。在服务器端，将客户端发的公钥写入到~/.ssh/authorized_keys文件末尾。</li>
</ul>


<h5>建立连接</h5>

<ul>
<li>1.客户端发出申请。服务器产生session密钥对，返回通过对应客户端的公钥加密后的session公钥。</li>
<li>2.客户端用自己的密钥解密信息，得到session公钥。</li>
<li>3.之后的数据交互，都通过对方方公钥加密，对方收到信息后，用其私钥解密，实现安全加密过程。</li>
</ul>


<h2>免密码的RSA加密方式实施过程</h2>

<ul>
<li>1.安装ssh</li>
</ul>


<p>mac下自带的有，ubuntu下直接sudo apt-get install ssh。</p>

<ul>
<li>2.在客户端生成私钥公钥</li>
</ul>


<p>使用ssh-keygen命令生成密钥对。遇到提示都直接回车（其中passphrase是保护rsa密钥的另一套加密方式）。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ssh-keygen   
</span><span class='line'>Generating public/private rsa key pair.  
</span><span class='line'>Enter file in which to save the key (/Users/biaobiaoqi/.ssh/id_rsa): /Users/biaobiaoqi/.ssh/id_rsa  
</span><span class='line'>Enter passphrase (empty for no passphrase):   
</span><span class='line'>Enter same passphrase again:   
</span><span class='line'>Your identification has been saved in /Users/biaobiaoqi/.ssh/id_rsa.  
</span><span class='line'>Your public key has been saved in /Users/biaobiaoqi/.ssh/id_rsa.pub.  
</span><span class='line'>The key fingerprint is:  
</span><span class='line'>b7:c2:5c:3f:83:5e:5e:93:a4:42:db:51:d8:ac:07:66 biaobiaoqi@biaobiaoqi.local  
</span><span class='line'>The key's randomart image is:  
</span><span class='line'>+--[ RSA 2048]----+  
</span><span class='line'>|                 |  
</span><span class='line'>|             +   |  
</span><span class='line'>|            E +  |  
</span><span class='line'>|           o +   |  
</span><span class='line'>|        S + o o  |  
</span><span class='line'>|       o + * = . |  
</span><span class='line'>|        + = B +  |  
</span><span class='line'>|         o + + . |  
</span><span class='line'>|          . .    |  
</span><span class='line'>+-----------------+  </span></code></pre></td></tr></table></div></figure>


<p>结果是在~/.ssh/下生成了 id_rsa（私钥）和id_rsa.pub（公钥）</p>

<ul>
<li>3.将客户端的公钥id_rsa.pub传递给服务器</li>
</ul>


<p>传送id_rsa.pub到服务器上，并将其内容写入到~/.ssh/authorized_keys文件尾。</p>

<p>可以物理的用U盘转运（似乎更安全），也可以使用scp指令（这个时候就需要运用到口令验证的ssh方式)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$scp ~/.ssh/id_rsa.pub user@host:~/.ssh/tmp_id_rsa.pub
</span><span class='line'>$ssh user@host "cat ~./ssh/tmp_id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys"</span></code></pre></td></tr></table></div></figure>


<p>在执行scp传输的过程中，如果是第一次ssh连接到服务器，客户端会提示是否信任这个主机，比如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$scp ~/.ssh/id_rsa.pub user@host:~/.ssh/tmp_id_rsa.pub
</span><span class='line'>The authenticity of host XXX can't be established.
</span><span class='line'>ECDSA key fingerprint is xxxxxxxxxxxxxxxxxxxxxx.
</span><span class='line'>Are you sure you want to continue connecting (yes/no)?</span></code></pre></td></tr></table></div></figure>


<p>原因是，客户端不确定所连接的host是否是真正的host。一般情况，直接输入yes，继续就好了。这里有较详细的解释：<a href="http://stackoverflow.com/questions/3663895/ssh-the-authenticity-of-host-hostname-cant-be-established">点击连接</a></p>

<p>然后就可以免密码、更安全的登录啦</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> ssh xxxx@hostAddress</span></code></pre></td></tr></table></div></figure>


<p>在ssh登录服务器时，如果出现如下问题：<em>Agent admitted failure to sign using the key</em>则需要手工将客户端私钥加入到ssh管理体系中。使用 ssh-add 指令。（具体机理还不太清楚）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ssh-add   ~/.ssh/id_rsa</span></code></pre></td></tr></table></div></figure>


<h2>and one more thing;)</h2>

<h4>ssh+firefox+autoproy</h4>

<p>看看wall外面的世界，是多么美好的事情。ssh能帮我们做到，只要有一台在wall外的主机做代理。
具体方式参见博文：<a href="http://reverland.bitbucket.org/ssh_climbe.html">ssh+firefox-autoproxy</a></p>

<h4>SCP命令加密赋值数据</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#将本地文件复制到远程主机上
</span><span class='line'>$scp ~./tmp user@rehost:~/tmp
</span><span class='line'>
</span><span class='line'>#见远程主机上的文件复制到本地
</span><span class='line'>$scp user@rehost:~/tmp ~./tmp
</span><span class='line'>
</span><span class='line'>#复制的是目录，需要迭代，添加-r参数
</span><span class='line'>$scp -r user@rehost:~/tmpDir ~./tmpDir</span></code></pre></td></tr></table></div></figure>


<h4>SSH的配置</h4>

<p>具体参数细节参见博文：<a href="http://www.ibm.com/developerworks/cn/aix/library/au-sshsecurity/">SSH 安全性和配置入门</a>
<a href="http://blog.licess.org/sshd_config/">sshd_config配置 详解</a></p>

<h2>推荐阅读：</h2>

<ul>
<li><a href="http://blog.lizhigang.net/archives/249">《linux ssh 使用深度解析（key登录详解）》</a></li>
<li><a href="http://wiki.tuna.tsinghua.edu.cn/SshKeyHowto">《使用 RSA 密钥对进行 SSH 登录验证》</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html">《SSH原理与运用（一）：远程登录》</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html">《SSH原理与运用（二）：远程操作与端口转发》</a></li>
<li><a href="http://reverland.bitbucket.org/ssh_climbe.html">ssh+firefox-autoproxy</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/aix/library/au-sshsecurity/">SSH 安全性和配置入门</a></li>
<li><a href="http://blog.licess.org/sshd_config/">sshd_config配置 详解</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于软件工程的一些看法]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/04/18/some-opinions-about-software-engineering/"/>
    <updated>2013-04-18T18:03:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/04/18/some-opinions-about-software-engineering</id>
    <content type="html"><![CDATA[<p>标题党了，其实实际的内容是[自己的项目经验总结和反思]。</p>

<p>今天在高级软件工程课上，做了一次关于项目经验的展示。展示的主题围绕自己参与的移动互联网团队开发经验展开。借此机会，我整理了一下思路，于是有了以下的slides。没时间码字，就先把slides直接贴上来啦:)</p>

<h2>提纲如下：</h2>

<ul>
<li>背景：对传统软件工程方法和移动互联网项目开发的对比</li>
<li>项目总结体会：</li>
<li><ul>
<li>协同目标<!--more--></li>
</ul>
</li>
<li><ul>
<li>需求的确定</li>
</ul>
</li>
<li><ul>
<li>里程碑</li>
</ul>
</li>
<li><ul>
<li>编码实现</li>
</ul>
</li>
<li><ul>
<li>发布</li>
</ul>
</li>
<li>ReCERD成长模型</li>
<li>推荐书目</li>
</ul>


<p>值得指出的是，所谓的ReCERD小团队项目能力成长模型其实是我根据自身经历所总结的一套方法模型;)， slides中有详细介绍，见笑了，欢迎拍砖。</p>

<p>slides下载地址：<a href="https://www.dropbox.com/s/0b084ccqao8igq8/course-slides.pdf">请点击</a> （使用的dropbox存储文档，可能不太稳定，海涵）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[再见，Seeme]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/04/07/goodbye-seeme/"/>
    <updated>2013-04-07T23:26:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/04/07/goodbye-seeme</id>
    <content type="html"><![CDATA[<p>过年算是仪式感最强的节日之一了。不想将过年作为成熟的时间节点，因为生命总是在时间里沉淀。但社会的周期运作确确实实的依着四季来过度，于是总有些决定、变化需要在此执行和接受。真诚的向过去的一切道一声感谢。</p>

<h2>半年小结</h2>

<p>2012年的7月份下旬，XB学长联系了我。那时候我有半吊子的iOS开发经验。因为对ITP早有耳闻，而自己也对创业一直有着一些念想，在没有对Seeme的团队和产品做深入的了解的情况下，我加入了。这也意味着，实验室那头的内容被暂时搁置。</p>

<!--more-->


<p>查好友iOS版本的开发周期很急，临危受命，我和几乎同时加入的没有ios开发经验的乐乐简单的认识后，就开始了编码。有android的版本作为原型，我们依照着“功能-交互-UI”的原则，开始了没日没夜的开发。9月份开学后，我们两从全职转型为兼职，9月下旬，正式在appstore发布了查好友的iOS v1.0。在我看来，那是最刺激的一段时间了，我和LL共同摸索着前进，看着开发进度条一天天向满状态增进，时而掉进坑里，也挣扎着爬起，别无他念，Done is better than perfect.</p>

<p>发版后几天的休息时间，我满怀着对技术实现的热情，琢磨着经验总结和未来的开发规划。遗憾的是，这些想法在之后的时间里并没有被自己重视，也没有很好的向其他人传递。它们从项目初期的疯狂建设中被勾起，又在项目开展的紧锣密鼓和实验室任务的双重压力下被遗忘。</p>

<p><img src="http://g.hiphotos.baidu.com/baike/c%3DbaikeA2%2C10%2C95/sign=b5413922fc039245b5b5b65eeeffc183/30adcbef76094b36da20d402a3cc7cd98c1001e93801bd93.jpg"></p>

<p>忙碌的时间过的很快，从2012年10月开始，到2013年的1月底，我们给查好友iOS版本加入了不少的新功能，比如公共组织通讯录、消息盒子（包括联系人更新、活动提醒和生日提醒）、应用分享、群发短信等，也发布了两个定制版的app到appstore。也是在这忙碌的几个月间，我的思想开始从最初的团队合作的“蜜月期”，渐渐过度到了一个新的阶段。</p>

<p>在这半年时间里，每个阶段，我们都在挑战自我。大家都有太多的优点让我学习。LL的认真负责、XX的敏捷，LY的乐观，RL的积极和对产品的探求，RK从技术角度对产品的感知，XK对设计的见解，更不用说XB学长一肩挑起的团队的运营、详实的数据分析，LP哥思维的缜密、理性，LP和YY学长在会议上思想的碰撞，YY学长对大局观的把控。也是Seemed团队带来的资源，让我有幸见识到LD的风采，思维的发散、活跃以及对产品的把控，见识到CJL大哥在面对实际应用场景时对框架设计的精准。</p>

<p>能够在这个凝聚而内省的团队里成长，我倍感荣幸。</p>

<p>所有的这些经历让我切切实实的了解到一个商业级的产品从设计到运营的不易，以及知识技能的学习和其应用之间微妙的trade-off。</p>

<h2>转折</h2>

<p>每个人的成长过程都充满着无数的选择。是对自我价值实现的追求，让我半年前抓住了机会，加入了Seeme。12月中旬，也是同样的原因，让我开始犹豫。我开始反思自己所做的是不是自己真正所想要的。如果是，那么我会毫不犹豫的走下去；如果不是，那么为什么我会在当前的位置，又如何改变。这两个月，我一直在寻找答案。</p>

<p>主观的看，我渐渐清晰了我的理想：藉由网络对信息分享自由的促进，将人类社会向自由平等推进。听起来有些黑客精神，有些狂妄，不过既然是理想，就不需要太靠谱。另一方面，我希望是做一个对用户负责的开发者，不论用什么开发语言，什么平台。我渴望挑战，虽然现在的技术能力并没有什么优势，但这不是理由，我需要时间。</p>

<p>客观上，首先，虽然我认为技术只是手段，但自己的技术能力并没有达到应用自如的高度。边干边学会将自己抛向了一个充满着更多不确定性的空间，这是现阶段的我所不希望接受的。坦率的说，我更希望在研究生的两年里以一种更有效率、更有针对性的方式学习和提升。</p>

<p>其次，虽然自己做事有一定的主动性，但由于种种原因，一直以来也没在团队中发挥出足够的执行力，来带动大家更高效的调整好自身进步和产品进度之间的平衡。从这个角度而言，我本身也是不适合目前的团队的。</p>

<p>记得刚开始接触团队的时候，我曾经对YY学长说过，“既是对自己负责，也是对团队负责，我无法保证自己在团队的贡献时间”。现在的状况也是如此。我想，我的情况已经不适合Seeme团队的健康成长。既然双方都无法有所助益，理智告诉我，是时候离开了。     </p>

<p>我享受半年来大家的一起奋斗，享受共同构建的产品中一批批用户数据流入的成就感，享受跟优秀的大家合作所激发的自己的斗志。</p>

<p>最后，感谢YY学长，让我接触到了产品从需求到设计、到实现的过程，让我了解到一个IT人对行业所应具有的的触觉和热情，让我学习到要认真的对待每一件事；感谢PG，让我见识到一个冷静理性的思维所能带来的力量；感谢XB学长，让我了解了运营产品过程的复杂，是你将我介绍到团队中，这是一切的引子；感谢XX，我一直在学习你的雷厉风行；感谢LL，你的诚恳和踏实让我自叹不如；感谢XK，见面不多，但合作一直很愉快；感谢RL，你的积极主动也一直感染者我；感谢LY和RK童鞋，合作不多，却很上心。</p>

<p>真心的祝Seeme团队继续壮大，在移动互联网圈子里闯出一片天地。</p>

<p>再见了，半年多的奋斗，承载的梦想和远方。</p>

<p>再见，Seeme。</p>

<hr />

<p>2013/02</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分治、时间空间的权衡:最大合的连续字串问题 (PAT 1007)]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/04/05/maximum-subsequence-sum/"/>
    <updated>2013-04-05T20:16:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/04/05/maximum-subsequence-sum</id>
    <content type="html"><![CDATA[<p><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1007">PAT1007</a>：给定一个整数串，找出连续子串中合最大的子串。</p>

<p>《编程珠玑》中用专门的一章对这个问题进行了讲解。（《编程珠玑（第2版）》P73 第8章 算法设计技术）</p>

<p>第一次在PAT上遇到这个题目时，我的思路如下：</p>

<p><del>最简单的淡然是一个三层循环咯，O(n3)，肯定会超时。节省时间的话，用动态规划吧。但简单的动态规划，显然是会超出内存限制的。有没有更巧妙的子问题划分方法呢？</del>先找到子问题：因为要求的串必须连续，分治的时候需要考虑如何延续这个连续性，那么每个子问题中就得考虑找出三个串：1.即左端连续的最大串，2.右端连续的最大串，3.整个串中的最大串.<del>由于每个问题都有三个量要维护，难道我得造出三个表来？卡主:(</del></p>

<!--more-->


<p>《编程珠玑》列出了性能上依次递进的四个算法。这里我结合个人理解和感悟做一些阐释。</p>

<ul>
<li>1.粗暴的brute forse。三层循环嵌套，据说当n 为100000的时候，就需要运行15天时间=.=</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>maxsofar = 0
</span><span class='line'>for i = 0 [0, n)
</span><span class='line'>  for j = [i, n)
</span><span class='line'>      sum = 0;
</span><span class='line'>      for k = [i, j]
</span><span class='line'>       sum += x[k]
</span><span class='line'>       /*sum is sum of x[i..j]*/
</span><span class='line'>       maxsofar = max(maxsofar, sum)</span></code></pre></td></tr></table></div></figure>


<ul>
<li>2.针对第一个算法做出了优化。利用零时变量保存状态，避免了过多的重复操作，即所谓的<strong>memoization思想</strong>。时间复杂度下降到O(n*logn)。不过这份代码在PAT的OJ上仍然会超时。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>maxsofar = 0;
</span><span class='line'>for i = [0, n)
</span><span class='line'>  sum = 0;
</span><span class='line'>  for j = [i, n)
</span><span class='line'>      sum += x[j]
</span><span class='line'>      /* sum is sum of x[i..j]*/
</span><span class='line'>      max sofar = max(maxsofar, sum)</span></code></pre></td></tr></table></div></figure>


<p>相比之下，动态规划的策略也是有memoization的思想在的，不过，在这里用DP将会创建一张很大的表。。。超出内存限定。</p>

<ul>
<li><p>3.分治算法</p>

<p>  其实之前我自己在思考DP更好的子问题划分时，已经考虑到了这种分治策略。但它的实现，<strong>并非需要DP支持</strong>。</p>

<p>  divide：将串平均分为两段，如下代码第6行。分别处理两个子串，并拼接计算。</p>

<p>  conquer： 计算1.自身包含左端的最大子串；2.包含右端的最大子串；（这两个子串用于与其他子串拼接）；3.自身的最大子串。</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>float maxsum3(l, u)
</span><span class='line'>  if (l &gt; u) /* zero elements*/
</span><span class='line'>      return 0
</span><span class='line'>  if (l == u) /* one element*/
</span><span class='line'>      return max (0, x[l]);
</span><span class='line'>  m = (1 + u) / 2
</span><span class='line'>  
</span><span class='line'>  /* find max crossing to left */
</span><span class='line'>  lmax = sum = 0
</span><span class='line'>  for (i = m; i &gt;= 1; i--)
</span><span class='line'>      sum += x[i]
</span><span class='line'>  lmax = max(lmax, sum)
</span><span class='line'>  
</span><span class='line'>  /* find max croosing to right */
</span><span class='line'>  rmax = sum = 0;
</span><span class='line'>  for i = (m, u]
</span><span class='line'>      sum += x[i]
</span><span class='line'>  rmax = max(rmax, sum)
</span><span class='line'>  
</span><span class='line'>  return max(lmax+rmax, maxsum3(l, m), maxsum3(m+1, u))   </span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>4.扫描算法</p>

<p>  类似于<strong>数学归纳法</strong>的思想。从串的最左端开始扫描。对于子串[0, k],其最大子串要么存在于[0, k-1]中而不包含[k]，称其为maxsofar，要么包含[k]，称其maxendingright。</p>

<p>  maxsofar和maxendingright是可能重合的。maxendingright的作用在于对[0,k+1]的子串而言，新的元素[k+1]可以与之结合，从而产生可能的新的子串。</p>

<p>  如果[k+1]本身就是负数呢？不要紧，将[k+1]加入到maxendingright的过程本身就是试错以产生可能的过程。当maxendingright降到0以下时，放弃掉这一子串就好了，因为无论如何扩张，它都是会拖后退的。别忘了，我们还维护着maxsofar，它记录最大的子串。有点绕，但是可以严格的证明算法的正确性。</p>

<p>  伪代码如下：</p></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>maxsofa = 0
</span><span class='line'>maxendingright = 0
</span><span class='line'>for i = [0, n)
</span><span class='line'>  /* invariant: maxendingright and maxsofar are accurate for x[0..i-1]*/
</span><span class='line'>  maxendingright = max(maxendingright + x[i], 0)
</span><span class='line'>  maxsofar = max(maxsofar, maxendingright)</span></code></pre></td></tr></table></div></figure>


<p>根据这个思路，写出<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/pat/advancedlevel/APAT1007.java">代码</a>，一遍AC:)</p>

<h2>总结：</h2>

<ul>
<li>保存状态，避免重复计算：在算法整体框架没有大的优化的情况下，时间和空间的trade-off或许会有奇效。memoization本身就是一种用空间换时间的思想，而DP中用一种方式实现了这种思想。不过不要被DP算法所禁锢。因为，这个trade-off的实现是很多变的，就像这题的第2种算法。</li>
<li>分治：它的重要性不必多说了。同样的，DP中有分治的思想，但分治本身也是非常灵活的。</li>
<li>数学归纳证明，对算法的设计和正确性佐证很有帮助。话说它也类似于分治的思想呢。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《痛并快乐着》]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/04/05/tong-bing-kuai-le-zhe/"/>
    <updated>2013-04-05T02:30:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/04/05/tong-bing-kuai-le-zhe</id>
    <content type="html"><![CDATA[<h2>儿时没烙印下的痛与快乐</h2>

<p><img class="left" src="http://img3.douban.com/lpic/s4599357.jpg" width="150" height="250" title="Place Kitten #2" ></p>

<p>这是一本让我内心平静的书。或许是因为他所讲，都是那十年来有亲身经历到过的。</p>

<p>《痛并快乐着》有二十来篇文章，每篇一个主题。所有的主题都围着个人在中国二十世纪后十年中的发展和社会的变迁中展开。文中，描述了白岩松如何从大学毕业后，几经波折获得了一个并非自己当初所想的工作，又如何在计划之外的点点滴滴中，将人生的珠子穿成了一根线。</p>

<!--more-->


<p>作者在记叙自身的成长历程之余，也抛出了对所深处新闻行业的思考，从他的视角展现了十年来行业如何从重重束缚中不断的开放和进步。更进一步的，文中表达了对中国改革开放过程中一步步脚印的反思，比如在于世界磨合的初期表现出的对体育特有的狂热等等。</p>

<p>从沉稳的文字中，我读到了曾经所身处的过往，一些属于上一辈人的积淀。虽然模糊，却深刻。作为90年出生的非典型90后，渡过了懵懂的人生头二十年，对那个时代缺乏了解。这些空白难以填补，但在阅读和思考中也渐渐瞧得出时代的痕迹，一个逐渐开放的社会在残酷的现实中前行的身影。</p>

<p>以前，总会觉得父母过于保守，他们感激改革开放带来的新政策，忍受着在我辈人看来一无是处的社会现象。这本书的沉重和乐观，让我对此的看法有所改观。</p>

<p>新年的烟花撒满夜空，是符号，是兴奋，是新时代的到来，而我们依旧是我们。我们能做的，不是自欺欺人的仗着仪式感享乐现在，不是否认过去，不是怨恨，而是不断前行。</p>

<p>有评论说这本书歌功颂德，政府喉舌。但我倒觉得，看到了其中的真诚。一种生命的沉淀。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PAT Advanced Level (1) easy problems]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/04/04/pat-advanced-level-1-easy-problems/"/>
    <updated>2013-04-04T20:58:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/04/04/pat-advanced-level-1-easy-problems</id>
    <content type="html"><![CDATA[<p><img class="left" src="http://visualcaffeine.com/ws/wp-content/uploads/2012/04/computer_guy.jpg" title="Place Kitten #2" ></p>

<p>今天做的这批题目，总的来说几乎不需要数据结构基础。几个小时刷完。</p>

<blockquote><ul>
<li>1001: 数字的格式转换。第一次做的时候，将正负数分两种情况处理了，其实负数可以拆成正数加上一个负号。太简单的道理，竟然没注意。另外，Java完全可以使用NumberFormat实现格式转换。好简单的说。</li>
</ul>
</blockquote>

<!-- more -->


<blockquote><ul>
<li><p>1002：一元多项式求导问题。有三点需要注意：1.输出中的小数精确的位数；2.浮点数操作过程中需要使用到eps做判定；<em>3.在我的实现中，主循环逻辑中，将判定游标越界的逻辑统一的提出到最外层，让代码更加简洁，利于维护。</em></p></li>
<li><p>1005: 简单的hash。注意Java可以直接实现int转string，string转int。</p></li>
<li><p>1006: 简单的找最大最小。用到了Java中String的split方法划分子串和Integer.parseInt()转String为int。</p></li>
<li><p>1008: 纯水题。</p></li>
<li><p>1009: 一元多项式相乘。基于桶排序的思想，将子项相乘的结果加到数组中去实现。第一次提交时，算错了“桶”的大小。。</p></li>
<li><p>1011: 水题，求组最大值的问题。</p></li>
<li><p>1027: 水题，hash求解。</p></li>
</ul>
</blockquote>

<h2>资料</h2>

<p><a href="http://pat.zju.edu.cn/contests/pat-a-practise">题目列表</a></p>

<p><a href="https://github.com/biaobiaoqi/biaobiaoqiCode/tree/master/src/biaobiaoqi/pat/advancedlevel">我的代码</a></p>

<h2>PS</h2>

<p>除了这几道题，其他的题目似乎都需要树、图、DP的思想。明天开干！</p>

<p>用了那么久eclipse，其实对eclipse的掌握并不好。比如他对（）和“”等的支持方式：</p>

<blockquote><p><strong>只需要输入左单边括号，即可获得一个完整的括号，并定位到括号内输入内容。完成内容输入后，回车即可跳到反括号外，继续输入。同理于调用方法时参数的输入等。</strong></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PAT Basic Level 1001-1010]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/04/04/pat-basic-level-1001-1010/"/>
    <updated>2013-04-04T01:50:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/04/04/pat-basic-level-1001-1010</id>
    <content type="html"><![CDATA[<h2>背景</h2>

<p>算法开始练手了。从最简单的做起。</p>

<p>由于实验室用的是Java，为了节省时间，也为了更好的掌握这门语言，我先用Java来实现了。在并非以比赛为目的的前提下，这并不妨碍什么，唯一的可能就是没有足够的参考代码咯。:(话说，自己也并不是特别喜欢一些“简洁”的代码。我现在的手速是不快，但过于简介的南与维护的代码，也不在我的目标之列。</p>

<!--more-->


<h2>资料</h2>

<p><strong><a href="http://pat.zju.edu.cn/contests/pat-b-practise">题目看这里</a></strong></p>

<p>我把所有AC过的<strong><a href="https://github.com/biaobiaoqi/biaobiaoqiCode/tree/master/src/biaobiaoqi/practice">解题代码都贴到了我的github</a></strong>上，可以直接去那边儿看，就不贴到blog里啦。（确切的说，这个博客本身就是在github里，不是么:)）</p>

<h2>总结：</h2>

<blockquote><ul>
<li><p>1001：第一次用Java在PAT上提交，遇到了【返回非零】的问题，两个原因：1.需要去掉package信息；2.程序跑异常也会出现这个问题。</p></li>
<li><p>1002：简单的将输入加起来，再对应到的显示出来。</p></li>
<li><p>1003：<em>题目像是用自动机构建的字符串？理论基础不够，没想太明白，或许需要个词法分析器？</em> 这里是利用字符串的统计规律计数字符串出现个数的出来的。在识别的过程中，有些小坑需要注意。</p></li>
<li><p>1004：求最大最小，想必是一道不能更水的题了=。=</p></li>
<li><p>1005：各个元素间互相影响。如果简单的全部计算覆盖数，当然能解出来，但显然不是最优的方法。需要尽量介绍重复计算的过程。<em>感觉解题方式没有美感</em></p></li>
<li><p>1006：转换格式。无坑。</p></li>
<li><p>1007：素数相关的题目。按照最原始的素数原理，固然可以解出，但优化的路还很长。参考了这篇博客（<a href="http://www.cnblogs.com/luluping/archive/2010/03/03/1677552.html">《浅析求素数算法》介绍的挺有味道的</a>）的内容。</p></li>
<li><p>1008：只要注意别先把所有数据都存到数组，再做操作，就ok了。无坑。</p></li>
<li><p>1009：充分利用了Java的String操作，无坑。</p></li>
<li><p>1010：有坑。需要考虑将无input的case输出为0 0.花了我很长时间。不想再纠结这个题目本身的正确性了。。</p></li>
</ul>
</blockquote>

<h2>PS：</h2>

<p>写代码的速度确实太慢了。得练。一个是敲代码本身的速度。一个是思维的速度。</p>

<p>到现在为止，还没有找到一个顺手的排版工具。此文出自mou，但不知道是不是因为我的姿势不对，对所有格式的支持并非那么完美。有空研究下，好让简陋的排版有脸见人吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在github上搭建octopress博客 mac]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/03/21/building-octopress-in-github-mac/"/>
    <updated>2013-03-21T23:43:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/03/21/building-octopress-in-github-mac</id>
    <content type="html"><![CDATA[<p><img src="http://pikipity.github.com/images/post/octopress.jpg"></p>

<p>最早的时候，是看见了<a href="http://blog.devtang.com/blog/2012/02/10/setup-blog-based-on-github/">唐巧大哥的博客</a>，UI上已是觉得耳目一新。后来读到过<a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html">阮一峰的博文</a>，当知道这是搭建在Github这个程序员的facebook上时，更是心头一震，什么时候自己也搭这么个博客呢。直接用github托管代码，完全不用自己租服务器，实在方便。自己之前也有在csdn上维护了一个博客，虽然那已经是一年前的事情了。</p>

<!--more-->


<p>深刻的记得，当时想将自己的weibo账户贴到博客页面上，却发现它不支持一般用户潜入javascript代码:(。这更让我对octopress的感情与日俱增。</p>

<p>今天终于动手啦。自己从网上搜到了很多中文的博客描述如何安装配置octopress，有些博客讲得算是清晰，但终归每台电脑有不同的环境，每个人的叙述也或多或少的主观。最要命的是，我发现好几篇博文所讲述的命令都不太一样，走了不少弯路之后，倒腾了一下午，最终还是官网救了我。这也让我进一步认识到，信息的流通中的失真在所难免，最好的方法还是直接探寻最权威的内容。</p>

<p>如果对octopress不太了解，不用急着动手，首先看看几个概念。（当然，lz现在也并非精通这几点，初来乍到的，先做出来再说，以后不断学习&#8230;）</p>

<blockquote><ul>
<li> Ruby：octopress框架的实现语言。rvm（ruby version manager）是用于管理ruby版本的，rake是ruby中类似于make工具。</li>
<li> 静态站点生成工具：简单地说，不用数据库，直接生成网页文件。Jekyll就是这样的工具，而octopress是构建于它的上层的框架。</li>
<li> Git：我主观的认为完虐svn的分布式版本控制工具。git官网貌似被gfw墙了=.=</li>
<li> <a href="https://github.com/">Github</a>：程序员的Facebook,为程序员托管了很多代码的站点。</li>
<li> <a href="https://help.github.com/categories/20/articles">Github pages</a>:github推出的，给与程序员自由创造静态网页的功能。支持Jekyll，因此也支持octopress。</li>
<li> <a href="http://mxcl.github.com/homebrew/">homebrew</a>：mac os下的软件包管理工具，类似于linux下的dpkg。它使用ruby脚本，mac os下自带了ruby。</li>
<li> <a href="http://octopress.org/">octopress</a> 其官网的help中有搭建octopress的足够的权威指导</li>
</ul>
</blockquote>

<p>窃以为，最好的学习方式还是从最源头的资料入手。这里仅针对我的配置过程做简单描述，经验浅薄，有差错的地方还请指教:)</p>

<h1>1. 配环境</h1>

<h3>1.0 homebrew</h3>

<p>万事开头难，第一步还是配环境。为了软件包安装的方便，可以先安装好homebrew.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ruby -e "$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)"</span></code></pre></td></tr></table></div></figure>


<p>其使用方法，参见<a href="http://mxcl.github.com/homebrew/">官网</a>。</p>

<h3>1.1 ruby</h3>

<p>mac os x 10.8.1 的系统自带了Ruby，但是版本是1.8.3，而octopress官网所支持的最新版是1.9.3（2013.3），兼容起见，先对版本进行升级。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ rvm install 1.9.3 && rvm use 1.9.3 
</span><span class='line'>$ rvm ruby gems latest</span></code></pre></td></tr></table></div></figure>


<p>lz在升级过程中遇到了奇怪的错误，于是又参考<a href="http://wj1s.iteye.com/blog/1118672">另一篇博文</a>，重新安装了rvm，再升级ruby到1.9.3版本。</p>

<h3>1.2 git</h3>

<p>使用homebrew安装git。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ brew install git</span></code></pre></td></tr></table></div></figure>


<h1>2. 搭建octopress</h1>

<p>环境配置完成后，就可以开始参照<a href="http://octopress.org/help/">官网</a>的指导搭建octopress，并在github建代码仓库，同步管理啦。</p>

<h1>3. 配置</h1>

<p>具体配置同见<a href="http://octopress.org/help/">官网</a>。</p>

<p>经过试错，发现_config.yml的配置中，配置项和值之间必须有空格。否则会报错。</p>

<p>另附个性化配置方案：（这些内容大都能在官网文档中找到）</p>

<h3>3.1 <a href="http://icodeit.org/2012/10/how-to-embed-douban-show-in-your-octopress-site/">装饰边栏（加weibo、豆瓣信息)</a></h3>

<h3>3.2 增加weibo评论：  <a href="http://blog.devtang.com/blog/2012/02/10/setup-blog-based-on-github/">友言版</a></h3>

<h3>3.3 CNAME</h3>

<p>如果你有自己的域名，可以CNAME到github pages上。以我的配置为例。</p>

<p>1.在工作目录的source目录下创建CNAME文件，并输入新域名：biaobiaoqi.com</p>

<p>2.在域名管理中，创建或修改A记录，指向204.232.175.78这个地址。</p>

<p>3.创建CNAME记录，www.biaobiaoqi.com -> biaobiaoqi.github.com</p>

<p>网上很多CNAME的操作指南，对于A记录的IP都写着<del>207.97.227.245</del>，或者其他的IP。实际上，这是github pages更换了地址所致。再一次证明<strong>官方文档才是最可靠的！</strong></p>

<h3>3.4 让链接在新窗口中打开</h3>

<p>markdown不支持这一语法，如果要自己用html标签实现，也太得不偿失了。参考<a href="http://www.blogjava.net/lishunli/archive/2013/01/20/394478.html">这篇博文</a>，可以通过将如下代码添加到 {OCTOPRESS_HOME}/source/_includes/custom/head.html文件末尾来实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;script type="text/javascript"&gt;
</span><span class='line'>function addBlankTargetForLinks () {
</span><span class='line'>  $('a[href^="http"]').each(function(){
</span><span class='line'>      $(this).attr('target', '_blank');
</span><span class='line'>  });
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>$(document).bind('DOMNodeInserted', function(event) {
</span><span class='line'>  addBlankTargetForLinks();
</span><span class='line'>});
</span><span class='line'>&lt;/script&gt;</span></code></pre></td></tr></table></div></figure>


<h1>4. 发博文和在线部署</h1>

<p>同样的，参考<a href="http://octopress.org/help/">官网</a>即可。
这里大致的列出我所常用到的几条命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>#创建一篇博文
</span><span class='line'>rake new_post["post title"] #octopress将在工作目录的source/_post/目录下生成相应的markdown文件。然后可以使用mou工具去修改编辑内容。
</span><span class='line'>
</span><span class='line'>#生成预览
</span><span class='line'>rake preview #可以通过localhost:4000在本机实时观察最新的编辑效果。
</span><span class='line'>
</span><span class='line'>#在线发布
</span><span class='line'>rake deploy #完成编辑后，可以将最新的内容部署到github上去。成功后，即可在线访问。
</span><span class='line'>
</span><span class='line'>#向github提交源文件更新
</span><span class='line'>git add -A
</span><span class='line'>git commit -m "提交内容"
</span><span class='line'>git push
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>其中推荐到的<a href="http://mouapp.com/">mou</a>，是一个mac下的markdown编辑器。试用后发现有些格式兼容问题，但似乎mac下也只有他这个可视化工具了=。=</p>

<p>另附<a href="http://wowubuntu.com/markdown/index.html">markdown语法</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[开篇]]></title>
    <link href="http://biaobiaoqi.github.com/blog/2013/03/17/kai-pian/"/>
    <updated>2013-03-17T10:18:00+08:00</updated>
    <id>http://biaobiaoqi.github.com/blog/2013/03/17/kai-pian</id>
    <content type="html"><![CDATA[<p>花了一下午时间，终于搭起了这个博客。</p>

<p>我会陆续将原来csdn博客中的内容筛选过来，将这个博客作为技术主博客。</p>

<p>github真是神器啊。感谢github，“感谢”tc最终没有封锁github，让我得以有机会搭建这个独立博客。</p>

<p>希望五年、十年、二十年过后，回过头来，依然能在这个博客中找到自己的脚印和梦想。</p>
]]></content>
  </entry>
  
</feed>
