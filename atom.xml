<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Biaobiaoqi的博客]]></title>
  <link href="http://biaobiaoqi.me/atom.xml" rel="self"/>
  <link href="http://biaobiaoqi.me/"/>
  <updated>2013-10-03T14:28:43+08:00</updated>
  <id>http://biaobiaoqi.me/</id>
  <author>
    <name><![CDATA[Biaobiaoqi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[《改变未来的九大算法》]]></title>
    <link href="http://biaobiaoqi.me/blog/2013/10/03/nine-algorithms-that-changed-the-future/"/>
    <updated>2013-10-03T13:19:00+08:00</updated>
    <id>http://biaobiaoqi.me/blog/2013/10/03/nine-algorithms-that-changed-the-future</id>
    <content type="html"><![CDATA[<h2>不要在意那些细节</h2>

<p>这是一本关于计算机世界的科普读物。豆瓣链接：<a href="http://book.douban.com/subject/24529132/">请戳</a>。</p>

<p>非常推荐刚接触计算机的朋友花上三五小时将全书通读一遍，没有技术细节，没有公式证明，它会告诉作者挑选出的九大算法出现的缘由和发展的过程。这些不关乎实现细节的思想概括，更能体现算法在整个领域中的存在的原因。它们不再是冷冰冰的算法过程，这是阅读大多数的书籍、教材所难以获得的。</p>

<p>至于我的推荐原因，如下全文。</p>

<h3>课程学习之弊</h3>

<p>大二大三的那两年，在学校上过了网络、操作系统、数据库、算法设计等诸多计算机领域的基础必修课程。由于生性愚钝加之令人头大的砖头书的体系化、理论化，对于知识的掌握顶多处于知其然却不知其所以然的程度。在这种情况下，学习就退化为了填鸭式的记忆。比如我记得 RSA 的公钥加密流程，却无法理解为何要套用这么一大堆的数学方法来得到如此神奇的效果，比如，我知道数据库有一套日志机制，却不知道它是如何与其他的组件共同构建起一个系统的……没有来龙去脉，就没有对技术发展的感知，没有对技术本质的理解和认识。</p>

<p>经过了四年多的摸爬滚打，到现在对这些基础知识的认识自然远好于当年上课的理解水平，不是因为我在反复的学习课程内容，而是从实践中获得了新的认识。</p>

<h3>从生活出发</h3>

<p>大多数人的思维习惯，倾向于从已知的事物中衍生对新事物的认识，这是一种类推。而高校的大多数教材和教授方式较少考虑到这一点，一种简单粗暴的直入主题的方式被大量的使用，排斥了知识的前因后果，技术的来龙去脉，剩下的只是新体系本身。这增加了学习曲线的入门坡度。</p>

<blockquote><p>理论是灰色的，生活之树常青</p></blockquote>

<p>《改变未来的九大算法》是对歌德这句话的良好实践。</p>

<!--more-->


<p>比如在阐述公钥加密机制时，作者从生活中的寄信讲起，一步步类比到计算机的通信上，并用染料配色的方式举例了迪菲赫尔曼机制。生动形象的描述了算法的原理和来由。</p>

<h3>抛开细节实现</h3>

<p>过往的教材一旦陷入对某些实现细节的阐释，就失去了对全局上下文的把握。就像镜头对焦到了一个点上，造成了周边景物的模糊化效果。</p>

<p>《改变未来的九大算法》全书很少涉及到技术的实现细节，这正是它的优势所在。比如数据库的一致性章节，从一个银行转账的实例讲起，通过所面临的一系列问题的解决方案的描述，让人对数据库的整体实现有了全局的把握。在理解的前提下，更深入的学习也变得更有动力和方向。</p>

<p>奈何自己已经过了朦朦胧胧的那几年，在此将本书强烈推荐给初涉计算机领域的朋友们。当然，其他人粗读一遍，也是对自己知识体系的一次小梳理啦;)。<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.me/blog/2013/10/03/nine-algorithms-that-changed-the-future/'>http://biaobiaoqi.me/blog/2013/10/03/nine-algorithms-that-changed-the-future/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jobs和jobs]]></title>
    <link href="http://biaobiaoqi.me/blog/2013/09/30/jobs-and-jobs/"/>
    <updated>2013-09-30T11:41:00+08:00</updated>
    <id>http://biaobiaoqi.me/blog/2013/09/30/jobs-and-jobs</id>
    <content type="html"><![CDATA[<p>作为一个不太安分的技术男，或多或少会对乔布斯怀有敬意。</p>

<p>我是从<a href="http://movie.douban.com/subject/1298084/">《硅谷海盗》</a>这部老片开始了解到乔布斯这个人的，查了下上映日期，竟然是我出生的第二天。那时候觉着演员挺帅啊，后来发现真人更有味道一点。<del>国内的互联网大佬们怎么不见如此气度的-,-。</del></p>

<p>前天下午，和实验室的基友们一起去看了刚上映的<a href="http://movie.douban.com/subject/6877703/">《乔布斯》</a>。由于乔布斯的段子、事迹早已充斥到生活的各个角落，两个小时的观影我几乎是以一种期待下个情节的心情在审视电影的脉络：求学时代开始，Apple1 一炮打响，Apple2 大卖，Lisa 折戟，Macintosh 阻力重重，被赶出苹果，重回苹果，END。我试图将乔布斯真人带给社会的感动融入到电影的观影情绪里，但并不太奏效，电影缺了一些代入感。或许是库切的身体太壮脸太宽了的缘故，也或许是因为广电总局减掉了乔布斯和女友的 1 分钟激情戏。</p>

<p>走出 Jobs，心里没有太多涟漪。世界倒是依旧的躁动——最近又迎来了找工作的季节。于是后面的节奏是，江湖上将流传着师兄师姐们的各种牛 offer 的传说，师弟师妹们各种仰慕，筹划着如何准备明年的面试，憧憬着明年的自己，以及抱怨着帝都魔都恶劣的生存条件和充沛的机遇并存的矛盾……充满着成王败寇的腥味，和纸醉金迷的浮躁。</p>

<p>理想和现实的纠缠从来就不曾停息，欲望的高低贵贱也是如此。</p>

<p>一场 Jobs，告诉我们<code>connecting the dolts</code>的感动。大家所追寻的 jobs，<code>dolts</code>在哪里？</p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.me/blog/2013/09/30/jobs-and-jobs/'>http://biaobiaoqi.me/blog/2013/09/30/jobs-and-jobs/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java类、实例的初始化顺序]]></title>
    <link href="http://biaobiaoqi.me/blog/2013/09/22/java-initialization/"/>
    <updated>2013-09-22T21:53:00+08:00</updated>
    <id>http://biaobiaoqi.me/blog/2013/09/22/java-initialization</id>
    <content type="html"><![CDATA[<p>今晚是阿里巴巴 2013 校园招聘的杭州站笔试。下午匆忙看了两张历年试卷，去现场打了瓶酱油。</p>

<p>题目总体考察点偏基础，倒数第二题（Java 附加题）比较有趣，考察了 Java 初始化机制的细节，在此摘录出来。</p>

<h2>题目</h2>

<p>求如下 java 代码的输出：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">class</span> <span class="nc">T</span>  <span class="kd">implements</span> <span class="n">Cloneable</span><span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="n">T</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="o">(</span><span class="s">&quot;t1&quot;</span><span class="o">);</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="n">T</span> <span class="n">t2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="o">(</span><span class="s">&quot;t2&quot;</span><span class="o">);</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">print</span><span class="o">(</span><span class="s">&quot;i&quot;</span><span class="o">);</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">99</span><span class="o">;</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">print</span><span class="o">(</span><span class="s">&quot;j&quot;</span><span class="o">);</span>
</span><span class='line'>  <span class="o">{</span>
</span><span class='line'>      <span class="n">print</span><span class="o">(</span><span class="s">&quot;构造快&quot;</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">static</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">print</span><span class="o">(</span><span class="s">&quot;静态块&quot;</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="nf">T</span><span class="o">(</span><span class="n">String</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">((++</span><span class="n">k</span><span class="o">)</span> <span class="o">+</span> <span class="s">&quot;:&quot;</span> <span class="o">+</span> <span class="n">str</span> <span class="o">+</span> <span class="s">&quot;    i=&quot;</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">&quot;  n=&quot;</span> <span class="o">+</span> <span class="n">n</span><span class="o">);</span>
</span><span class='line'>      <span class="o">++</span><span class="n">n</span><span class="o">;</span> <span class="o">++</span> <span class="n">i</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">print</span><span class="o">(</span><span class="n">String</span> <span class="n">str</span><span class="o">){</span>
</span><span class='line'>      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">((++</span><span class="n">k</span><span class="o">)</span> <span class="o">+</span><span class="s">&quot;:&quot;</span> <span class="o">+</span> <span class="n">str</span> <span class="o">+</span> <span class="s">&quot;   i=&quot;</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">&quot;   n=&quot;</span> <span class="o">+</span> <span class="n">n</span><span class="o">);</span>
</span><span class='line'>      <span class="o">++</span><span class="n">n</span><span class="o">;</span>
</span><span class='line'>      <span class="k">return</span> <span class="o">++</span> <span class="n">i</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
</span><span class='line'>      <span class="n">T</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="o">(</span><span class="s">&quot;init&quot;</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>分析</h2>

<p>代码主要考察的是类、变量初始化的顺序。</p>

<p>一般的，我们很清楚类需要在被实例化之前初始化，而对象的初始化则是运行构造方法中的代码。</p>

<p>本题的代码显然没有这么简单了。本题中涉及到了<code>static {…}</code> 和 <code>{…}</code>这种形式的代码块，以及在类的静态变量中初始化该类的对象这种交错的逻辑，容易让人焦躁（类似于密集恐惧症吧=(）。实际上，按照<a href="http://biaobiaoqi.me/blog/2013/09/08/java-class-loading-linking-and-initialising/">类的装载、链接和初始化逻辑</a>，以及<a href="http://biaobiaoqi.me/blog/2013/09/08/strange-behavior-using-braces-in-java/">对象初始化的顺序</a>来思考，不难得到答案。</p>

<!--more-->


<h3>代码组成</h3>

<ul>
<li><p>成员变量
  2~6 行的变量是 static 的，为类 T 的静态成员变量，需要在类加载的过程中被执行初始化；第 8 行的<code>int j</code>则为实例成员变量，只再类被实例化的过程中初始化。</p></li>
<li><p>代码段
  9~11 行为实例化的代码段，在类被实例化的过程中执行；13~15 行为静态的代码段，在类被加载、初始化的过程中执行。</p></li>
<li><p>方法
  方法<code>public static int print(String str)</code> 为静态方法，其实现中牵涉到 k,i,n 三个静态成员变量，实际上，这个方法是专门用来标记执行顺序的方法；T 的构造方法是个实例化方法，在 T 被实例化时调用。</p></li>
<li><p>main 方法
  main 方法中实例化了一个 T 的实例。</p></li>
</ul>


<h3>执行顺序分析</h3>

<p>在一个对象被使用之前，需要经历的过程有：类的装载 -> 链接（验证 -> 准备 -> 解析） -> 初始化 -> 对象实例化。（详情参见<a href="http://biaobiaoqi.me/blog/2013/09/08/java-class-loading-linking-and-initialising/">《Java 类的装载、链接和初始化》</a>），这里需要注意的点主要有：</p>

<ul>
<li><p>在类链接之后，类初始化之前，实际上类已经可以被实例化了。</p>

<p>  就如此题代码中所述，在众多静态成员变量被初始化完成之前，已经有两个实例的初始化了。实际上，此时对类的实例化，除了无法正常使用类的静态承运变量以外（还没有保证完全被初始化），JVM 中已经加载了类的内存结构布局，只是没有执行初始化的过程。比如第 3 行<code>public static T t1 = new T("t1");</code>，在链接过程中，JVM 中已经存在了一个 t1，它的值为 null，还没有执行<code>new T("t1")</code>。又比如第 5 行的<code>public static int i = print("i");</code>，在没有执行初始化时，i 的值为 0，同理 n 在初始化前值也为 0.</p></li>
<li><p>先执行成员变量自身初始化，后执行<code>static {…}</code>、<code>{…}</code>代码块中的内容。</p>

<p>  如此策略的意义在于让代码块能处理成员变量相关的逻辑。如果不使用这种策略，而是相反先执行代码块，那么在执行代码块的过程中，成员变量并没有意义，代码块的执行也是多余。</p></li>
<li><p>类实例化的过程中，先执行隐式的构造代码，再执行构造方法中的代码
  这里隐式的构造代码包括了<code>{}</code>代码块中的代码，以及实例成员变量声明中的初始化代码，以及父类的对应的代码（还好本题中没有考察到父类这一继承关系，否则更复杂;)）。为何不是先执行显示的构造方法中的代码，再执行隐式的代码呢？这也很容易解释：构造方法中可能就需要使用到实例成员变量，而这时候，我们是期待实例变量能正常使用的。</p></li>
</ul>


<p>有了如上的分析，也就能推到出最终的输出结果了。实际上，这几个原则都不需要死记硬背，完全能通过理解整个 JVM 的执行过程来梳理出思路的。</p>

<h2>答案</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="mi">1</span><span class="o">:</span><span class="n">j</span>   <span class="n">i</span><span class="o">=</span><span class="mi">0</span>   <span class="n">n</span><span class="o">=</span><span class="mi">0</span>
</span><span class='line'><span class="mi">2</span><span class="o">:</span><span class="err">构造快</span>   <span class="n">i</span><span class="o">=</span><span class="mi">1</span>   <span class="n">n</span><span class="o">=</span><span class="mi">1</span>
</span><span class='line'><span class="mi">3</span><span class="o">:</span><span class="n">t1</span>    <span class="n">i</span><span class="o">=</span><span class="mi">2</span>  <span class="n">n</span><span class="o">=</span><span class="mi">2</span>
</span><span class='line'><span class="mi">4</span><span class="o">:</span><span class="n">j</span>   <span class="n">i</span><span class="o">=</span><span class="mi">3</span>   <span class="n">n</span><span class="o">=</span><span class="mi">3</span>
</span><span class='line'><span class="mi">5</span><span class="o">:</span><span class="err">构造快</span>   <span class="n">i</span><span class="o">=</span><span class="mi">4</span>   <span class="n">n</span><span class="o">=</span><span class="mi">4</span>
</span><span class='line'><span class="mi">6</span><span class="o">:</span><span class="n">t2</span>    <span class="n">i</span><span class="o">=</span><span class="mi">5</span>  <span class="n">n</span><span class="o">=</span><span class="mi">5</span>
</span><span class='line'><span class="mi">7</span><span class="o">:</span><span class="n">i</span>   <span class="n">i</span><span class="o">=</span><span class="mi">6</span>   <span class="n">n</span><span class="o">=</span><span class="mi">6</span>
</span><span class='line'><span class="mi">8</span><span class="o">:</span><span class="err">静态块</span>   <span class="n">i</span><span class="o">=</span><span class="mi">7</span>   <span class="n">n</span><span class="o">=</span><span class="mi">99</span>
</span><span class='line'><span class="mi">9</span><span class="o">:</span><span class="n">j</span>   <span class="n">i</span><span class="o">=</span><span class="mi">8</span>   <span class="n">n</span><span class="o">=</span><span class="mi">100</span>
</span><span class='line'><span class="mi">10</span><span class="o">:</span><span class="err">构造快</span>   <span class="n">i</span><span class="o">=</span><span class="mi">9</span>   <span class="n">n</span><span class="o">=</span><span class="mi">101</span>
</span><span class='line'><span class="mi">11</span><span class="o">:</span><span class="n">init</span>    <span class="n">i</span><span class="o">=</span><span class="mi">10</span>  <span class="n">n</span><span class="o">=</span><span class="mi">102</span>
</span></code></pre></td></tr></table></div></figure>


<h3>参考：</h3>

<ul>
<li><a href="http://biaobiaoqi.me/blog/2013/09/08/strange-behavior-using-braces-in-java/">《Java 构造方法中的执行顺序》</a></li>
<li><a href="http://biaobiaoqi.me/blog/2013/09/08/java-class-loading-linking-and-initialising/">《Java 类的装载、链接和初始化》</a><p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.me/blog/2013/09/22/java-initialization/'>http://biaobiaoqi.me/blog/2013/09/22/java-initialization/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于科学上网]]></title>
    <link href="http://biaobiaoqi.me/blog/2013/09/10/scientifically-surfing-the-internet/"/>
    <updated>2013-09-10T12:11:00+08:00</updated>
    <id>http://biaobiaoqi.me/blog/2013/09/10/scientifically-surfing-the-internet</id>
    <content type="html"><![CDATA[<p>为了防止被某墙 fuck，暂且称其为『很棒的防火墙』吧，你懂的-,-.</p>

<p>在 teahour 上听了 <a href="http://teahour.fm/2013/07/09/gfw-and-vpncloud.html">***技术研究和云梯产品故事</a>，有感于之前几天修改本地 hosts 的策略再次失效，切换到 goagent 模式，在此，基于这期 teahour 对<a href="https://twitter.com/kgen">@Kgen</a> 的访谈内容，对很棒的防火墙做份简单的笔记：</p>

<p>很棒的防火墙有用大量的服务器，并由一大只团队维护和升级。它的目的是让大部分的互联网用户无法接触到“有害”的网络资源，“净化”国内的网络环境。同时，它需要尽可能的减少商业上的影响，比如为了不阻碍外企的 VPN 工作环境，很棒的防火墙并没有直接对 VPN 进行封堵。在这个前提上，留给我们的可能性也是一直存在的。</p>

<h2>防御策略</h2>

<p>很棒的防火墙一直在茁壮成长着。一个方校长倒下了，千千万万 X 校长站起来了。他们背负着一辈子的骂名，忍辱负重的为祖国奉献着生命，死而后已。总之，前赴后继的技术人员不断的在补全着很棒的防火墙的防御规则，因此，应对策略也需要不断的调整和改进。整体来看，防御策略主要有如下几种：</p>

<ul>
<li><h4>1.DNS 污染</h4>

<p>  DNS 协议本身并没有安全认证功能，很棒的防火墙检测到相应 dns 请求后，会返回一个错误的 IP 地址，造成无法正常访问。解决方案有使用第三方 DNS 服务或者修改本地 hosts 文件。</p></li>
<li><h4>2.IP 拦截</h4>

<p>  对于特定敏感网站，很棒的防火墙会直接侦察到相应的 IP 地址施行拦截。简单的 DNS 修改无法解决 IP 层的问题，只能通过代理等手段绕过这些 IP 进行访问。常用的应对方式有：使用 VPN、ssh 代理和 GAE 上搭建 <a href="http://zhoudemin.com/goagent.html">GoAgent</a> 服务等。至于为什么一些国内用户说自己的 GoAgent 速度很快，而又有很多人在抱怨自己的 GAE 速度很慢，原因在于 GAE 应用会不受控制的部署到 Google 不同的服务器节点上，而国内网络环境复杂，不同地区的网络连入国外不同服务器的线路不尽相同，速度也差异明显。同样的情况也发生在 VPS 的使用速度差异上。</p></li>
</ul>


<!--more-->


<ul>
<li><h4>3.端口封锁：比如 ssh 端口</h4>

<p>  <a href="http://biaobiaoqi.me/blog/2013/04/19/use-ssh/">ssh</a> 是一种安全的加密的网络通信协议，通过 ssh 可以施行对远程主机的操控。部分网民通过在很棒的防火墙外的 VPS（虚拟主机）做代理，使用 ssh 服务上网。针对这一情况，最近两年，很棒的防火墙开始实现对 ssh 端口的封锁。当 ssh 链接被鉴定为非正常流量，则相应端口会受到封锁。如果频繁切换端口，可能整个 IP 都将被封锁。</p></li>
<li><h4>4.http 请求明文内容检测和中断</h4>

<p>  使用 Google 搜索某些敏感内容时，链接会被重置，就是因为很棒的防火墙侦测到了敏感内容，给用户浏览器发送了重置消息，扰乱了链接。</p></li>
<li><h4>5.https 间歇性中断</h4>

<p>  https 的链接本身是安全的、加密的。在无法侦测内容的前提下，很棒的防火墙采用了不讲道理的间歇性中断策略。</p></li>
</ul>


<p>更多关于很棒的防火墙的资料，请先翻过墙去查看;)<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.me/blog/2013/09/10/scientifically-surfing-the-internet/'>http://biaobiaoqi.me/blog/2013/09/10/scientifically-surfing-the-internet/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[对Java字符串的探究]]></title>
    <link href="http://biaobiaoqi.me/blog/2013/09/08/string-interning/"/>
    <updated>2013-09-08T13:01:00+08:00</updated>
    <id>http://biaobiaoqi.me/blog/2013/09/08/string-interning</id>
    <content type="html"><![CDATA[<h2>问题的出发点</h2>

<p>在网上看到一道题：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">String</span> <span class="n">str</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">&quot;abc&quot;</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>以上代码执行过程中生成了多少个 String 对象？</p>

<p>答案写的是两个。&#8221;abc&#8221;本身是一个，而 new 又生成了一个。</p>

<h2>&#8220;abc&#8221;是什么</h2>

<p>查看这句程序的字节码，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">NEW</span> <span class="n">String</span>
</span><span class='line'>    <span class="n">DUP</span>
</span><span class='line'>    <span class="n">LDC</span> <span class="s">&quot;abc&quot;</span>
</span><span class='line'>    <span class="n">INVOKESPECIAL</span> <span class="n">String</span><span class="o">.&lt;</span><span class="n">init</span><span class="o">&gt;(</span><span class="n">String</span><span class="o">)</span> <span class="o">:</span> <span class="kt">void</span>
</span><span class='line'>    <span class="n">ASTORE</span> <span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure>


<p>指令<code>ldc indexbyte</code>的含义：将两字节的值从 indexbyte 索引的常量池中的项中推到方法栈上。</p>

<p>指令<code>LDC "abc"</code>说明了&#8221;abc&#8221;并不是直接以对象存在的，而是存在于常量池的索引中。String 的构造函数调用命令实际使用的就是 String 类型作为参数，那么，栈上应该有一个 String 类型的索引。</p>

<p>由此我们得出，在字节码中，ldc 命令在常量池中找到了能索引到“abc”那个 String 对象的索引值。</p>

<h2>常量池</h2>

<p>常量池是类文件（.class）文件中的一部分，记录了许多常量信息，索引的字符串信息。</p>

<p>由于 Java 是动态加载的，类文件并没有包含程序运行时的内存布局，方法调用等无法直接记录出方法的物理位置，常量池通过索引的方法解决了这个问题。</p>

<!--more-->


<p>常量池中存着许多表，其中 Constant_Utf8_info 表中，记录着会被初始化为 String 对象的字符串的字面值（iteral）。
而在 String 的 java doc 中，有对 String 字面值的说明：</p>

<blockquote><p>All string literals in Java programs, such as &#8220;abc&#8221;, are implemented as instances of this class.</p></blockquote>

<p>在 Java 编译的过程中，确定下来的 String 字面值都先被优化记录在常量池中（那些双引号字符串，都是以 CONSTANT_utf8_info 的形式存储在常量池中的）。也就是说，Java 源代码文件中出现的那些诸如&#8221;abc&#8221;字符串，都已经被提前放在了常量池中。</p>

<p>可以使用如下代码验证这一点：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Program</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>       <span class="n">String</span> <span class="n">str1</span> <span class="o">=</span> <span class="s">&quot;Hello&quot;</span><span class="o">;</span>
</span><span class='line'>       <span class="n">String</span> <span class="n">str2</span> <span class="o">=</span> <span class="s">&quot;Hello&quot;</span><span class="o">;</span>
</span><span class='line'>       <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">str1</span> <span class="o">==</span> <span class="n">str2</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出结果是 true.说明&#8221;Hello&#8221;作为对象是被程序从同一个内存空间读取出来的。</p>

<p>常量池是编译时产生的，存在于类文件中（*.class 文件）。运行时，JVM 中每个对象都拥有自己的运行时常量池（run time constant pool）。</p>

<h2>字符串池</h2>

<p>我在 String 的 java doc 中又发现了一个有趣的 method：intern() ,我翻译如下：</p>

<blockquote><p>当 intern 方法被调用，如果池中已经拥有一个与该 String 的字符串值相等（即 equals()调用后为 true）的 String 对象时，那么池中的那个 String 对象会被返回。否则，池中会增加这个对象，并返回当前这个 String 对象。</p></blockquote>

<p>其中有介绍一个字符串池的东西：字符串池（String pool），初始是空的，由类私有的控制。</p>

<p>查看 java.lang.String 的源代码，发现 Intern()方法是一个 native 方法，即本地实现的方法，而不是一个 java 方法，这让我们不能直观的看到字符串池的实现细节。不过能够理解字符串池其实是类似于线程池的缓冲器，可以起到节约内存的作用。如下代码可以验证</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kn">package</span> <span class="n">biaobiaoqi</span><span class="o">.</span><span class="na">thinkingInJava</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">String</span> <span class="n">strA1</span> <span class="o">=</span> <span class="s">&quot;ab&quot;</span><span class="o">;</span>
</span><span class='line'>        <span class="n">String</span> <span class="n">strA2</span> <span class="o">=</span> <span class="s">&quot;c&quot;</span><span class="o">;</span>
</span><span class='line'>        <span class="n">String</span> <span class="n">strB1</span> <span class="o">=</span> <span class="s">&quot;a&quot;</span><span class="o">;</span>
</span><span class='line'>        <span class="n">String</span> <span class="n">strB2</span> <span class="o">=</span> <span class="s">&quot;bc&quot;</span> <span class="o">;</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">((</span><span class="n">strA1</span><span class="o">+</span><span class="n">strA2</span><span class="o">).</span><span class="na">intern</span><span class="o">()</span> <span class="o">==</span> <span class="o">(</span><span class="n">strB1</span> <span class="o">+</span> <span class="n">strB2</span><span class="o">).</span><span class="na">intern</span><span class="o">());</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出结果为 true。</p>

<p>现代的 JVM 实现里，考虑到垃圾回收（Garbage Collection）的方便，将内存区域 <a href="http://en.wikipedia.org/wiki/Java_Virtual_Machine#Heap">heap</a> 划分为三部分： young generation 、 tenured generation（old generation）和 permanent generation( permgen )</p>

<p>字符串池是为了解决字符串重复的问题，生命周期长，它存在于 permgen 中。</p>

<h2>总结</h2>

<p>编译 Java 源代码时，源文件中出现的双引号内的字符串都被收纳到常量池中，用 CONSTANT_utf8_info 项存储着。</p>

<p>JVM 中，相应的类被加载运行后，常量池对应的映射到 JVM 的运行时常量池中。其中每项 CONSTANT_utf8_info（也就试记录那些字符串的）都会在常量引用解析时，自动生成相应的 internal String，记录在字符串池中。</p>

<p>回过头来看看文章刚开始的那个问题。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">String</span> <span class="n">str</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">(</span><span class="s">&quot;abc&quot;</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里确实是有两个 String 对象生成了。</p>

<p><code>new String("xxx")</code> 创建的 String 对象会在 heap 中重新生成新的 String 对象，绕过字符串池的管辖。而如果使用<code>String str = "xxx"</code>则先查看字符串池 是否已经存在，存在则直接返回 PermGen 中的该 String 对象，否则生成新的 String 对象，并将它加入字符串池中。</p>

<blockquote><p>尽量使用<code>String str = "abc";</code>，而不是<code>String str = new String("abc")；</code>用 new 的方法肯定会开辟新的 heap 空间，而前者的方法，则会通过 string interning 优化。</p></blockquote>

<h3>参考资料</h3>

<ul>
<li><a href="http://www.codeinstructions.com/2009/01/busting-javalangstringintern-myths.html">Busting java.lang.String.intern() Myths</a></li>
<li><a href="http://book.douban.com/subject/1788390/">Inside the JAVA2 virtual machine</a></li>
<li><a href="http://book.douban.com/subject/1610251/">Programming for the java virtual machine</a></li>
<li><a href="http://www.xyzws.com/Javafaq/what-is-string-literal-pool/3">What is String literal pool? How to create a String</a></li>
<li><a href="http://stackoverflow.com/questions/4918399/what-type-of-memory-heap-or-stack-string-constant-pool-in-java-gets-stored">What type of memory (Heap or Stack) String constant pool in Java gets stored?</a></li>
</ul>


<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.me/blog/2013/09/08/string-interning/'>http://biaobiaoqi.me/blog/2013/09/08/string-interning/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AOP实践：java.lang.instrument的使用]]></title>
    <link href="http://biaobiaoqi.me/blog/2013/09/08/custom-premain-method/"/>
    <updated>2013-09-08T13:01:00+08:00</updated>
    <id>http://biaobiaoqi.me/blog/2013/09/08/custom-premain-method</id>
    <content type="html"><![CDATA[<h2>背景</h2>

<p>在 <a href="https://github.com/biaobiaoqi/rcjp">rcjp</a> 项目中，需要调用 ASM API（用于字节码处理的开源库）对字节码进行处理，目标是实现对 Java 程序运行时各种对象的动态跟踪，并进一步分析各个对象之间的关系。在此之前，需要考虑如何获取程序运行的入口。</p>

<p>首先，我考虑到了自定义类加载器（详情见参考资料），即在程序的 main 入口处，首先加载自定义的类加载器，然后通过反射技术使用这个类加载器加载并调用测试程序。这个方法缺点是：每次都必须先找到测试程序的入口类，而对于有的封装成 jar 的程序集合，这一点相对比较难控制。</p>

<p>于是，有了这里介绍的方法：通过 <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/instrument/package-summary.html">java.lang.instrument</a> 实现的 java agent 对象操作字节码，是一种 <a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">AOP</a> 的方法。</p>

<p>程序中，除了 ASMAgent 以外的所有类都是调用 ASM API 实现对测试程序中各个对象的构造、方法调用、属性赋值等操作行为的记录（其中对 Collection 子类的处理着实费了一番心血= =，字节码操作很细节，容易出错）。</p>

<!--more-->


<h2>原理</h2>

<p><a href="http://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html#N100A7">JVMTI（Java Virtual Machine Tool Interface）</a>是一套本地编程接口集合，它提供了一套『代理』机制，可以支持第三方工具程序以代理的方式连接和访问 JVM，并利用 JVMTI 提供的丰富的编程接口，完成很多跟 JVM 相关的功能。</p>

<p>java.lang.instrument 包的实现，也就是基于这种机制的：在 Instrumentation 的实现当中，存在一个 JVMTI 的代理程序，通过调用 JVMTI 当中 Java 类相关的函数来完成 Java 类的动态操作。</p>

<p>Instrumentation 的最大作用就是类定义的动态改变和操作。在 Java SE 5 及其后续版本当中，开发者可以在一个普通 Java 程序（带有 main 函数的 Java 类）运行时，通过 – javaagent 参数指定一个特定的 jar 文件（包含 Instrumentation 代理）来启动 Instrumentation 的代理程序。</p>

<h2>步骤</h2>

<h3>1.编写 java 代理类</h3>

<p>这个类中，premain 方法是关键，对比于一般的入口 main 一样，这里的 premain 是在 main 之前执行的。它会告诉 JVM 如何处理加载上来的 java 字节码。如下例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">premain</span><span class="o">(</span><span class="n">String</span> <span class="n">agentArgs</span><span class="o">,</span> <span class="n">Instrumentation</span> <span class="n">inst</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">Trace</span><span class="o">.</span><span class="na">BeginTrace</span><span class="o">();</span> <span class="c1">// it&#39;s important for trace files  </span>
</span><span class='line'>            <span class="n">inst</span><span class="o">.</span><span class="na">addTransformer</span><span class="o">(</span><span class="k">new</span> <span class="n">ASMAgent</span><span class="o">());</span>
</span><span class='line'>        <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>值得注意的是，addTransformer 实现了对字节码处理的方法的回调。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">inst</span><span class="o">.</span><span class="na">addTransformer</span><span class="o">(</span><span class="k">new</span> <span class="n">ASMAgent</span><span class="o">());</span>
</span></code></pre></td></tr></table></div></figure>


<p>类 ASMAgent 包含着实现对 java 字节码处理的方法：transform()。它来自于 ClassFileTransformer 接口。为了方便，这里将对 ClassFileTransformer 接口的实现跟 ASMAgent 类放在了一起。其中 classfileBuffer 是类文件加载时的原始的字节码，retVal 则是经过处理后的字节码。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">transform</span><span class="o">(</span><span class="n">ClassLoader</span> <span class="n">loader</span><span class="o">,</span> <span class="n">String</span> <span class="n">className</span><span class="o">,</span><span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">classBeingRedefined</span><span class="o">,</span>
</span><span class='line'>                                        <span class="n">ProtectionDomain</span> <span class="n">protectionDomain</span><span class="o">,</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">classfileBuffer</span><span class="o">)</span>
</span><span class='line'>            <span class="kd">throws</span> <span class="n">IllegalClassFormatException</span> <span class="o">{</span>
</span><span class='line'>            <span class="kt">byte</span><span class="o">[]</span> <span class="n">retVal</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span><span class="o">(</span><span class="n">isInstrumentable</span><span class="o">(</span><span class="n">className</span><span class="o">)){</span>
</span><span class='line'>                <span class="n">ClassWriter</span> <span class="n">cw</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ClassWriter</span><span class="o">(</span><span class="n">ClassWriter</span><span class="o">.</span><span class="na">COMPUTE_FRAMES</span><span class="o">);</span>
</span><span class='line'>                <span class="n">ASMClassAdapter</span> <span class="n">mca</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ASMClassAdapter</span><span class="o">(</span><span class="n">cw</span><span class="o">);</span>
</span><span class='line'>                <span class="n">ClassReader</span> <span class="n">cr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ClassReader</span><span class="o">(</span><span class="n">classfileBuffer</span><span class="o">);</span>
</span><span class='line'>                <span class="n">cr</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">mca</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
</span><span class='line'>                <span class="n">retVal</span> <span class="o">=</span> <span class="n">cw</span><span class="o">.</span><span class="na">toByteArray</span><span class="o">();</span>
</span><span class='line'>            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
</span><span class='line'>                    <span class="n">retVal</span> <span class="o">=</span> <span class="n">classfileBuffer</span> <span class="o">;</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">return</span> <span class="n">retVal</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>2.打包代理类</h3>

<p>只有合理打包并在 manifest 文件中记录下相应的键值对之后，才能正常执行 premain 的内容。
manifest 文件中需要添加的键值对是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Premain</span><span class="o">-</span><span class="n">Class</span> <span class="o">:</span> <span class="n">biaobiaoqi</span><span class="o">.</span><span class="na">asm</span><span class="o">.</span><span class="na">ASMAgent</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果对字节码的处理有应用到了其他的类，需要在 manifest 中增加路径。比如使用到了 asm-3.0.jar，则增加如下语句：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Class</span><span class="o">-</span><span class="nl">Path:</span> <span class="n">asm</span><span class="o">-</span><span class="mf">3.0</span><span class="o">.</span><span class="na">jar</span>
</span></code></pre></td></tr></table></div></figure>


<h3>3.执行</h3>

<p>执行测试程序时，添加“-javaagent:代理类的 jar[=传入 premain 的参数]”选项。</p>

<p>比如，对于博主的程序，就是</p>

<p><code>java -javaagent:ASMInstrument.jar   -jar XXXX.jar  xxxx</code></p>

<p>其中 ASMInstrument.jar 是第二步中打包的程序，  XXX.jar 是需要测试的程序， xxx 是 XXX.jar 执行时可能的命令行参数。</p>

<p>如果只是执行某.class 文件中的类，我们假设是在当前目录下的一个 XXXX 类，则是：
<code>java -javaagent:ASMInstrument.jar   -cp ./  XXXX xxx</code></p>

<p>其中 xxx 是可能的命令行参数。</p>

<h3>参考资料</h3>

<ul>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html">《Java SE 6 新特性: Instrumentation 新功能》</a></li>
<li><a href="http://biaobiaoqi.me/blog/2013/09/08/java-class-loader-in-practice/">《Java 类加载器编程实践》</a></li>
</ul>


<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.me/blog/2013/09/08/custom-premain-method/'>http://biaobiaoqi.me/blog/2013/09/08/custom-premain-method/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java构造方法中的执行顺序]]></title>
    <link href="http://biaobiaoqi.me/blog/2013/09/08/strange-behavior-using-braces-in-java/"/>
    <updated>2013-09-08T12:58:00+08:00</updated>
    <id>http://biaobiaoqi.me/blog/2013/09/08/strange-behavior-using-braces-in-java</id>
    <content type="html"><![CDATA[<p>这道题来自 <a href="http://stackoverflow.com/questions/8185780/strange-behavior-using-braces-in-java/8186881#8186881">stackoverflow</a>。</p>

<h2>问题描述：</h2>

<p>有如下代码，求其输出内容。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
</span><span class='line'>    <span class="n">Test</span><span class="o">(){</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;1&quot;</span><span class="o">);}</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">{</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;2&quot;</span><span class="o">);}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">static</span><span class="o">{</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;3&quot;</span><span class="o">);}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span> <span class="n">args</span><span class="o">[])</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>        <span class="k">new</span> <span class="nf">Test</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>分析</h2>

<p>作为静态区段的语句，容易知道，3 是会最先出现的。容易弄错的一点是 到底是 1 和 2 的出现顺序。</p>

<p>我们可以参考字节码来分析。在 eclipse 中使用 ASM bytecode 插件，得到相应的字节码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">// class version 50.0 (50)  </span>
</span><span class='line'><span class="c1">// access flags 0x21  </span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
</span><span class='line'>  <span class="c1">// compiled from: Test.java  </span>
</span><span class='line'>  <span class="kd">static</span> <span class="o">&lt;</span><span class="n">clinit</span><span class="o">&gt;()</span> <span class="o">:</span> <span class="kt">void</span>
</span><span class='line'>    <span class="n">GETSTATIC</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span> <span class="o">:</span> <span class="n">PrintStream</span>
</span><span class='line'>    <span class="n">LDC</span> <span class="s">&quot;3&quot;</span>
</span><span class='line'>    <span class="n">INVOKEVIRTUAL</span> <span class="n">PrintStream</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">String</span><span class="o">)</span> <span class="o">:</span> <span class="kt">void</span>
</span><span class='line'>    <span class="n">RETURN</span>
</span><span class='line'>
</span><span class='line'>  <span class="o">&lt;</span><span class="n">init</span><span class="o">&gt;()</span> <span class="o">:</span> <span class="kt">void</span>
</span><span class='line'>    <span class="n">ALOAD</span> <span class="mi">0</span><span class="o">:</span> <span class="k">this</span>
</span><span class='line'>    <span class="n">INVOKESPECIAL</span> <span class="n">Object</span><span class="o">.&lt;</span><span class="n">init</span><span class="o">&gt;()</span> <span class="o">:</span> <span class="kt">void</span>
</span><span class='line'>    <span class="n">ALOAD</span> <span class="mi">0</span><span class="o">:</span> <span class="k">this</span>
</span><span class='line'>    <span class="n">BIPUSH</span> <span class="mi">10</span>
</span><span class='line'>    <span class="n">PUTFIELD</span> <span class="n">Test</span><span class="o">.</span><span class="na">a</span> <span class="o">:</span> <span class="kt">int</span>
</span><span class='line'>    <span class="n">GETSTATIC</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span> <span class="o">:</span> <span class="n">PrintStream</span>
</span><span class='line'>    <span class="n">LDC</span> <span class="s">&quot;2&quot;</span>
</span><span class='line'>    <span class="n">INVOKEVIRTUAL</span> <span class="n">PrintStream</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">String</span><span class="o">)</span> <span class="o">:</span> <span class="kt">void</span>
</span><span class='line'>    <span class="n">GETSTATIC</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span> <span class="o">:</span> <span class="n">PrintStream</span>
</span><span class='line'>    <span class="n">LDC</span> <span class="s">&quot;1&quot;</span>
</span><span class='line'>    <span class="n">INVOKEVIRTUAL</span> <span class="n">PrintStream</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">String</span><span class="o">)</span> <span class="o">:</span> <span class="kt">void</span>
</span><span class='line'>    <span class="n">RETURN</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[])</span> <span class="o">:</span> <span class="kt">void</span>
</span><span class='line'>    <span class="n">NEW</span> <span class="n">Test</span>
</span><span class='line'>    <span class="n">INVOKESPECIAL</span> <span class="n">Test</span><span class="o">.&lt;</span><span class="n">init</span><span class="o">&gt;()</span> <span class="o">:</span> <span class="kt">void</span>
</span><span class='line'>    <span class="n">RETURN</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>正如我们所想，3 是被放在类构造方法中，这是类的初始化函数，固然在类的初始化时出现。</p>

<!--more-->


<p>而在构造方法中先出现 2，之后才是 1。问题的核心集中到对象构造方法的指令顺序问题。实际上，在对象构造方法中，会先执行一些隐性的指令，比如父类的构造方法、{}区段的内容等，然后在执行显性的构造方法中的指令：</p>

<ul>
<li><ol>
<li>Java 编译时，对象构造方法里先嵌入隐式的指令，完毕之后，再执行 Java 源代码中显示的代码。</li>
</ol>
</li>
<li>2.那些隐式的指令，包括父类的构造方法、变量的初始化、{}区段里的内容，并严格按照这个顺序嵌入到对象的构造方法中。</li>
</ul>


<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.me/blog/2013/09/08/strange-behavior-using-braces-in-java/'>http://biaobiaoqi.me/blog/2013/09/08/strange-behavior-using-braces-in-java/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java类的实例化总结]]></title>
    <link href="http://biaobiaoqi.me/blog/2013/09/08/initliate-objects-in-java/"/>
    <updated>2013-09-08T02:03:00+08:00</updated>
    <id>http://biaobiaoqi.me/blog/2013/09/08/initliate-objects-in-java</id>
    <content type="html"><![CDATA[<p>java 类的实例化(instantiation)具有显性的和隐性的区别。</p>

<p>写 Java 代码时，我们所使用 new 的方法实例化最简单直接的显性实例化。而隐性的实例化则出现在 java 程序的整个生命周期中，包括 String、Class，StringBuffer 或者 StringBuilder 的实例化等等。</p>

<h2>显性的实例化</h2>

<h3>new 关键字实例化对象</h3>

<p>调用相应的构造函数完成实例化。（类中的非静态成员变量如果有初始化语句，都会被隐式的加入到构造函数中）代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span>  <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">String</span> <span class="n">strA</span> <span class="o">=</span> <span class="s">&quot;xyz&quot;</span><span class="o">;</span>
</span><span class='line'>    <span class="n">String</span> <span class="n">strB</span> <span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">Test</span><span class="o">(</span><span class="n">String</span> <span class="n">str</span><span class="o">){</span>
</span><span class='line'>        <span class="n">strB</span> <span class="o">=</span> <span class="n">str</span> <span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
</span><span class='line'>            <span class="n">Test</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Test</span><span class="o">(</span><span class="s">&quot;abc&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在 eclipse 中装了 <a href="http://asm.ow2.org/">ASM bytecode</a> 插件后，观察.class 文件中的构造函数对应的字节码如下：</p>

<!--more-->


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">INVOKESPECIAL</span> <span class="n">Object</span><span class="o">.&lt;</span><span class="n">init</span><span class="o">&gt;()</span> <span class="o">:</span> <span class="kt">void</span>
</span><span class='line'>   <span class="n">ALOAD</span> <span class="mi">0</span><span class="o">:</span> <span class="k">this</span>
</span><span class='line'>   <span class="n">LDC</span> <span class="s">&quot;xyz&quot;</span>
</span><span class='line'>   <span class="n">PUTFIELD</span> <span class="n">Test</span><span class="o">.</span><span class="na">strA</span> <span class="o">:</span> <span class="n">String</span>
</span><span class='line'>   <span class="n">ALOAD</span> <span class="mi">0</span><span class="o">:</span> <span class="k">this</span>
</span><span class='line'>   <span class="n">ALOAD</span> <span class="mi">1</span><span class="o">:</span> <span class="n">str</span>
</span><span class='line'>   <span class="n">PUTFIELD</span> <span class="n">Test</span><span class="o">.</span><span class="na">strB</span> <span class="o">:</span> <span class="n">String</span>
</span><span class='line'>   <span class="n">RETURN</span>
</span></code></pre></td></tr></table></div></figure>


<p>关键在于<code>LDC"xyz"</code>这条指令，明显可以看出，这是用于 strA 初始化的字符串。</p>

<p>由此我们可以归纳出，在没有调用本类中其他的构造函数的情况下，每次类的构造函数中都会按如下顺序进行：</p>

<ul>
<li>a)隐式（或显性）的调用父类的构造函数</li>
<li>b)然后执行写在构造函数外的成员变量的初始化赋值</li>
<li>c)最后再执行构造函数中的命令。</li>
</ul>


<p>如果是有显性的调用本类其他构造函数（必须是放在构造函数第一步执行），那么对于这个构造函数，处理过程就简单些了：</p>

<ul>
<li>a)调用那个构造函数。</li>
<li>b)执行之后的代码。</li>
</ul>


<h3>利用 java 反射机制</h3>

<p>反射机制是是 java 动态性中的关键之一，调用 java.lang.reflect.Constructor 的 newInstance()方法能创建对象。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span>  <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">Test</span><span class="o">(){</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Created by invoking newInstance()&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">Test</span><span class="o">(</span><span class="n">String</span> <span class="n">str</span><span class="o">){</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>
</span><span class='line'>                    <span class="kd">throws</span> <span class="n">ClassNotFoundException</span> <span class="o">,</span> <span class="n">InstantiationException</span> <span class="o">,</span>
</span><span class='line'>                    <span class="n">IllegalAccessException</span>  <span class="o">{</span>
</span><span class='line'>            <span class="n">Test</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Test</span><span class="o">(</span><span class="s">&quot;Created with new&quot;</span><span class="o">);</span> <span class="c1">//常规的方法  </span>
</span><span class='line'>            <span class="n">Class</span> <span class="n">myClass</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">&quot;Test&quot;</span><span class="o">);</span>  <span class="c1">//获得了对应于 Test 类的 Class 对象，如果没有加载，会先加载这个类，再返回。  </span>
</span><span class='line'>            <span class="n">Test</span> <span class="n">t2</span> <span class="o">=</span> <span class="o">(</span><span class="n">Test</span><span class="o">)</span><span class="n">myClass</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span> <span class="c1">//调用 newInstance()创建对象。  </span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>其他</h3>

<p>其他还有对象的 clone()方法，以及串行化后的解串行化过程。</p>

<h2>隐性的实例化</h2>

<p>隐性的实例化主要有如下几类：</p>

<ul>
<li>1.String 和 String 数组。main(String[] args)中拥有的 args 参数为 String 数组类型，这些 command line 参数将会首先被实例化。</li>
<li>2.Class 的实例化。由于类的加载过程中，会生成相应类的 Class 对象，这些也会被隐性的实例化。</li>
<li>3.JVM 在执行类加载的过程中，对常量池中的 CONSTANT_String_info 项会实例化出对应的 String 对象。这里涉及到常量池解析的知识。</li>
<li>4.在 String 的操作中，可能存在隐性的 StringBuffer 或者 StringBuilder 的实例化。</li>
<li>5.int 和 Integer 这些类型转化过程中的装箱、拆箱。</li>
</ul>


<p>比如如下代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span>  <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
</span><span class='line'>            <span class="n">String</span> <span class="n">str1</span> <span class="o">=</span> <span class="s">&quot;abc&quot;</span><span class="o">;</span>
</span><span class='line'>            <span class="n">String</span> <span class="n">str2</span> <span class="o">=</span> <span class="s">&quot;def&quot;</span><span class="o">;</span>
</span><span class='line'>            <span class="n">String</span> <span class="n">str</span> <span class="o">=</span> <span class="n">str1</span> <span class="o">+</span> <span class="n">str2</span> <span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在 eclipse 中装了 ASM bytecode 插件后，直接观察.class 文件对应的字节码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">NEW</span> <span class="n">StringBuilder</span>
</span><span class='line'>    <span class="n">DUP</span>
</span><span class='line'>    <span class="n">ALOAD</span> <span class="mi">1</span><span class="o">:</span> <span class="n">str1</span>
</span><span class='line'>    <span class="n">INVOKESTATIC</span> <span class="n">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">Object</span><span class="o">)</span> <span class="o">:</span> <span class="n">String</span>
</span><span class='line'>    <span class="n">INVOKESPECIAL</span> <span class="n">StringBuilder</span><span class="o">.&lt;</span><span class="n">init</span><span class="o">&gt;(</span><span class="n">String</span><span class="o">)</span> <span class="o">:</span> <span class="kt">void</span>
</span><span class='line'>    <span class="n">ALOAD</span> <span class="mi">2</span><span class="o">:</span> <span class="n">str2</span>
</span><span class='line'>    <span class="n">INVOKEVIRTUAL</span> <span class="n">StringBuilder</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">String</span><span class="o">)</span> <span class="o">:</span> <span class="n">StringBuilder</span>
</span><span class='line'>    <span class="n">INVOKEVIRTUAL</span> <span class="n">StringBuilder</span><span class="o">.</span><span class="na">toString</span><span class="o">()</span> <span class="o">:</span> <span class="n">String</span>
</span><span class='line'>    <span class="n">ASTORE</span> <span class="mi">3</span>
</span></code></pre></td></tr></table></div></figure>


<p>实际上，这里 str1 和 str2 合并的过程，是使用了 StringBuilder 来间接完成的，首先以 str1 的值构造一个 StringBuilder，然后调用其中的 append()方法，将 str2 串联上来。</p>

<p>值得注意的是：老版本的 java 使用 StringBuffer 完成这一步，但 StringBuffer 是线程安全的，效率略低，于是在新版本 java 中出现了非线程安全的 StringBuilder，这类似于 Hashtable 和 hashset 的关系。<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.me/blog/2013/09/08/initliate-objects-in-java/'>http://biaobiaoqi.me/blog/2013/09/08/initliate-objects-in-java/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java类加载的延迟初始化]]></title>
    <link href="http://biaobiaoqi.me/blog/2013/09/08/late-initialising-in-java/"/>
    <updated>2013-09-08T02:00:00+08:00</updated>
    <id>http://biaobiaoqi.me/blog/2013/09/08/late-initialising-in-java</id>
    <content type="html"><![CDATA[<p><a href="http://biaobiaoqi.me/blog/2013/09/08/java-class-loading-linking-and-initialising/">《Java 类的装载、链接和初始化》</a>中提到，链接的最后一步是解析，即对符号引用的解析。但这不是必须的，可以等到相应的符号引用第一次使用时再解析。</p>

<p>而类的初始化是在链接之后的（注意了，根据不同 JVM 有不同的实现方式，在类初始化的时候，可能已经完成了所有的符号引用的解析，也可能没有），本文所写的就是类的初始化的时机问题。</p>

<p>Java 类的动态加载机制规定，在类被主动使用(active use)之前，必须已经完成类的初始化。既然有主动调用，那么就有被动调用了。这两者有哪些区别呢？</p>

<p>下面列出所有主动使用的情况，用以区分两者：</p>

<ul>
<li>1.创造该类的一个新的实例</li>
<li>2.调用这个类中的静态方法</li>
<li>3.获取类或者接口中的非常量的静态变量</li>
<li>4.利用反射调用方法</li>
<li>5.初始化该类的某子类</li>
<li>6.被制定为 JVM 开始运行时必须初始化的类</li>
</ul>


<p>注意，3 中为何是“非常量的静态变量”。如果是常量，即声明为 final 的话，并不会出现对类的构造，虽然调用时有类名出现，但实际调用会直接使用常量，绕过了类的限制（详情见相关常量池和运行时常量池的知识）。</p>

<p>只有当一个非常量的静态变量被显示的在类或接口中声明时，它的调用才属于主动调用。对于父类中某非常量静态变量的调用属于被动使用(positive use)。</p>

<!--more-->


<p>如下代码</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Parent</span> <span class="o">{</span>
</span><span class='line'>     <span class="kd">static</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">;</span>
</span><span class='line'>
</span><span class='line'>     <span class="kd">static</span><span class="o">{</span>
</span><span class='line'>            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Parent initiate&quot;</span><span class="o">);</span>
</span><span class='line'>     <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>     <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">func</span><span class="o">(){</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;func&quot;</span><span class="o">);</span>
</span><span class='line'>     <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Son</span> <span class="kd">extends</span> <span class="n">Parent</span><span class="o">{</span>
</span><span class='line'>    <span class="kd">static</span><span class="o">{</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Son initiate&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">static</span><span class="o">{</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Test initiate&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Son</span><span class="o">.</span><span class="na">i</span><span class="o">);</span>
</span><span class='line'>        <span class="n">Son</span><span class="o">.</span><span class="na">func</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>运行的结果是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Test</span> <span class="n">initiate</span>
</span><span class='line'><span class="n">Parent</span> <span class="n">initiate</span>
</span><span class='line'><span class="mi">10</span>
</span><span class='line'><span class="n">func</span>
</span></code></pre></td></tr></table></div></figure>


<p>虽然有出现 Son，但 Son.i 访问的是父类的非常量静态变量。于是没有对 Son 类进行初始化，而只是初始化了明确的声明静态变量的 Parent 类。</p>

<p>由此可见，一般的，我们在某个类中定义了其他类的成员变量引用，只要该变量没有 new 出一个新的对象，则 JVM 也不会初始化这个类，类此时只是被加载了而已，而没有链接和初始化。<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.me/blog/2013/09/08/late-initialising-in-java/'>http://biaobiaoqi.me/blog/2013/09/08/late-initialising-in-java/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[类加载器操作三原则[译]]]></title>
    <link href="http://biaobiaoqi.me/blog/2013/09/08/three-principles-of-classloader-operation/"/>
    <updated>2013-09-08T00:42:00+08:00</updated>
    <id>http://biaobiaoqi.me/blog/2013/09/08/three-principles-of-classloader-operation</id>
    <content type="html"><![CDATA[<p>（出自一本 J2EE 的教材中关于类加载器的介绍，原文已不知所踪。）</p>

<p>类加载的 bug，一旦在编程中遇到很难调试。好消息是，理解类加载的过程中，我们只需要牢记住三条基本原则。如果你能清晰的理解这三条基本原则，所有问题都迎刃而解。下面，我们开始介绍。</p>

<h2>委托原则(Delegation Principle)</h2>

<blockquote><p>如果一个类还没有被加载，类加载器会委托它的父亲加载器去加载它。</p></blockquote>

<p>这种委托会一直延续，直到到达委托层次的最顶层，由原始的类加载器加载完成该类。下图展示了这种情况。</p>

<p><img src="https://dl.dropboxusercontent.com/u/64021093/Java%20Classloader/classloader1.gif" alt="" /></p>

<p>Systm-ClassPath classloader 加载了 MyApp.MyApp，而这个类创造了一个 java.util.Vector。假设现在 java.util.Vector 还没又被加载。因为 System-Classpath classloader 加载了 MyApp 类，它首先请求它的父亲 extension classloader 来加载这个类（java.util.Vector）。而 extension classloader 又请求 Bootstrap classloader 尝试加载。因为 java.util.Vector 是 J2SE 类，bootstrap classloader 成功加载了它。</p>

<!--more-->


<p>考虑一个当略微不同的情况，如下图。</p>

<p><img src="https://dl.dropboxusercontent.com/u/64021093/Java%20Classloader/classloader2.gif" alt="" /></p>

<p>在这种情况中，MyApp 创造了一个新的用户自定义类的实例，MyClass。假设 MyClass 还没有被加载。像以往一样，当 System-Classpath classloader 接收到这个加载请求，它委托了它的父亲。最终这个委托传递到了 Bootstrap classloader。但是在 java 核心 API 里，找不到这个类。所以它的孩子加载器 Extensions classloader 尝试加载它。同样的，Extensions classloader 也没有找到它。最终，委托请求回到了 System-Classpath classloader 这里。它找到了这个类并加载成功。</p>

<h2>可见性原则（Visibility principle）</h2>

<blockquote><p>被父亲类加载器加载的类对于孩子加载器是可见的，但关系相反相反则不可见。</p></blockquote>

<p>这说明，一个类只能看见它自己的加载器或者这个加载器的父类加载器加载的类，反过来是不可以的。比如，被 ClassX 的父亲加载器加载的类是不能看见 ClassX 的。为了更清楚的理解，让我们来看一个例子，如下图。</p>

<p><img src="https://dl.dropboxusercontent.com/u/64021093/Java%20Classloader/classloader3.gif" alt="" /></p>

<p>图中展示了四个类加载器。类加载器 A 是最顶层的加载器，B 是它的孩子。类加载器 X 和 Y 是 B 的孩子。他们各自都加载了与自己同名的类。类加载器 A 能看见 A 类，类加载器 B 能看见 A，B 类。类似的，X 能看见 A，B，X，Y 能看见 A，B，Y。但兄弟、Y 之间的类是不可见的。</p>

<h2>独特性原则（Uniqueness Principle）</h2>

<blockquote><p>当一个类加载器加载一个类时，它的孩子加载器绝不会重新加载这个类。</p></blockquote>

<p>这是因为委托原则中，一个加载器总是会委托自己的父亲加载器加载类。当层次中的父亲加载器无法加载类的时候，孩子类加载器就会（或者尝试去）加载这个类。这样，类加载的独特性就得到了保障。当父亲和孩子加载器加载了同一个类，一个有趣的情况就出现了。你可能会想这怎么可能出现？这不是违反了独特性原则？</p>

<p>我们用可见性原则中的示例图来解释这个问题。我们假设没有任何类被加载到这些类加载器的层次结构中。假设 X 类被类加载器 X 加载，它强制性的用类加载器 X 加载 B 类。这可以通过像 Class.Name()这样的 API 来实现，代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'> <span class="kd">public</span> <span class="kd">class</span> <span class="nc">X</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>   <span class="kd">public</span> <span class="nf">X</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">ClassLoader</span> <span class="n">cl</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getClassLoader</span><span class="o">();</span>
</span><span class='line'>      <span class="n">Class</span> <span class="n">B</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="err">“</span><span class="n">B</span><span class="err">”</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="n">cl</span><span class="o">);</span>
</span><span class='line'>   <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在 X 的构造函数中，B 被显示的使用类加载器 X 加载。如果另一个被类加载器 B 加载的类需要访问 B 类，则无法实现，因为委托原则只能向父亲方向查询。如果类加载器 B 也加载了 B 类，当比较两个 B 类的实例时，如果一个实例来自于类加载器 X，一个来自于类加载器 B，则会抛出 ClassCastException 异常。</p>

<h2>总结</h2>

<p>这三个原则 是解决程序中遇到的类加载问题的关键所在。在实际的编程中，并不需要显示的调用到类加载器，它主要出现在一些框架的代码中。但对于每一个开发者、架构师而言，都必须理解类加载的层次结构，这样才能写出优雅的代码。</p>

<h3>PS</h3>

<p>注意，虽然 java 的加载实现中，对于 bootstrap classloader 、extensions classloader 和 system classloader 来说，他们的关系是 parent-first，也就是像原则一中所说的那样，需要向上委托，但用户自定义的 classloader 完全可以跳出这个圈子，自己实现 parent-lastclassloader。比如 Websphere 中就有相关配置。</p>

<p>更具体的类加载器编程实例，请见另外一篇博文：<a href="http://biaobiaoqi.me/blog/2013/09/08/java-class-loader-in-practice/">《Java 类加载器编程实践》</a><p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.me/blog/2013/09/08/three-principles-of-classloader-operation/'>http://biaobiaoqi.me/blog/2013/09/08/three-principles-of-classloader-operation/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java类的装载、链接和初始化]]></title>
    <link href="http://biaobiaoqi.me/blog/2013/09/08/java-class-loading-linking-and-initialising/"/>
    <updated>2013-09-08T00:33:00+08:00</updated>
    <id>http://biaobiaoqi.me/blog/2013/09/08/java-class-loading-linking-and-initialising</id>
    <content type="html"><![CDATA[<h2>加载(Loading)</h2>

<p>按如下三步执行</p>

<ul>
<li>1.通过类的全名产生对应类的二进制数据流。（注意，如果没找到对应类文件，只有在类实际使用时才抛出错误。）</li>
<li>2.分析并将这些二进制数据流转换为方法区(JVM 的架构：方法区、堆，栈，本地方法栈，pc 寄存器)特定的数据结构（这些数据结构是实现有关的，不同 JVM 有不同实现）。这里处理了部分检验，比如类文件的魔数的验证，检查文件是否过长或者过短，确定是否有父类（除了 Obecjt 类）。</li>
<li>3.创建对应类的 java.lang.Class 实例（注意，有了对应的 Class 实例，并不意味着这个类已经完成了加载链链接！）。</li>
</ul>


<h2>链接(Linking)</h2>

<p>链接的过程比加载过成复杂不少，这是实现 Java 的动态性的重要一步。分为三部分：验证，准备和解析。</p>

<ul>
<li><p>1.验证（verification）</p>

<p>  链接的第三部解析会把类中成员方法、成员变量、类和接口的符号引用替换为直接引用，而在这之前，需要检测被引用的类型正确性和接入属性是否正确（就是 public ,private 的的问题），诸如检查 final class 又没有被继承，检查静态变量的正确性等等。（注意到实际上有一部分验证过程已经在加载的过程中执行了。）</p></li>
</ul>


<!--more-->


<ul>
<li><p>2.准备(preparation)</p>

<p>  对类的成员变量分配空间。虽然有初始值，但这个时候不会对他们进行初始化（因为这里不会执行任何 Java 代码）。具体如下：</p>

<p>  所有原始类型的值都为 0。如 float: 0f, int: 0, boolean: 0(注意 boolean 底层实现大多使用 int)，引用类型则为 null。值得注意的是，JVM 可能会在这个时期给一些有助于程序运行效率提高的数据结构分配空间。比如方发表（类似与 C++中的虚函数表，参见另一篇博文<a href="http://biaobiaoqi.me/blog/2013/06/02/virtual-dispatch-and-method-table-in-java/">《Java：方法的虚分派和方法表》</a>）。</p></li>
<li><p>3.解析(Resolution)</p>

<p>  为类、接口、方法、成员变量的符号引用定位直接引用（如果符号引用先到常量池中寻找符号，再找先应的类型，无疑会耗费更多时间），完成内存结构的布局。</p>

<p>  这一步是可选的。可以在符号引用第一次被使用时完成，即所谓的延迟解析(late resolution)。但对用户而言，这一步永远是延迟解析的，即使运行时会执行 early resolution，但程序不会显示的在第一次判断出错误时抛出错误，而会在对应的类第一次主动使用的时候抛出错误！</p>

<p>  另外，这一步与之后的类初始化是不冲突的，并非一定要所有的解析结束以后才执行类的初始化。不同的 JVM 实现不同。详情见另一篇博文<a href="http://localhost:4000/blog/2013/09/08/late-initialising-in-java/">《Java 类加载的延迟初始化》</a>。</p></li>
</ul>


<h2>初始化类(Initialization)</h2>

<p>开发 Java 时，接触最多的是对象的初始化。实际上类也是有初始化的。相比对象初始化（参见博文 <a href="http://localhost:4000/blog/2013/09/08/initliate-objects-in-java/">Java 类的实例化</a>），类的初始化机制要简单不少。</p>

<p>类的初始化也是延迟的，直到类第一次被主动使用(active use)，JVM 才会初始化类。（参见博文<a href="http://localhost:4000/blog/2013/09/08/late-initialising-in-java/">《Java 类加载的延迟初始化》</a>）</p>

<p>类的初始化分两步：</p>

<ul>
<li>1.如果基类没有被初始化，初始化基类。</li>
<li><p>2.有类构造函数，则执行类构造函数。</p>

<p>  类构造函数是由 Java 编译器完成的。它把类成员变量的初始化和 static 区间的代码提取出，放到一个<clinit>的方法中。这个方法不能被一般的方法访问（注意，static final 成员变量不会在此执行初始化，它一般被编译器生成 constant 值）。同时，<clinit>中是不会显示的调用基类的<clinit>的，因为 1 中已经执行了基类的初始化。类的初始化还必须注意线程安全的问题。</p></li>
</ul>


<h3>PS：</h3>

<p>为什么接口不能定义成员变量，而只能定义 final static 变量。</p>

<ul>
<li>1.接口是不可实例化，它的所有元素都不必是实例（对象）层面的。static 满足了这一点。</li>
<li>2.如果接口的变量能被修改，那么一旦一个子类实现了这个接口，并修改了接口中的非 final 变量，而该子类的子类再次修改这个非 final 的变量后，造成的结果就是虽然实现了相同的接口，但接口中的变量值是不一样的。</li>
</ul>


<p>综上述，static final 更适合于接口。</p>

<p>参考：<a href="http://blog.csdn.net/a352193394/article/details/6844941">《通过类字面常量解释接口常量为什么只能定义为 static final,类加载过程&#8212;Thinking in java》</a></p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.me/blog/2013/09/08/java-class-loading-linking-and-initialising/'>http://biaobiaoqi.me/blog/2013/09/08/java-class-loading-linking-and-initialising/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java类加载器编程实践]]></title>
    <link href="http://biaobiaoqi.me/blog/2013/09/08/java-class-loader-in-practice/"/>
    <updated>2013-09-08T00:33:00+08:00</updated>
    <id>http://biaobiaoqi.me/blog/2013/09/08/java-class-loader-in-practice</id>
    <content type="html"><![CDATA[<p>文本通过实现自定义类加载器，实践 Java 类加载的流程。</p>

<p>阅读此文前，需要了解 Java 类加载的基本原理，参见如下两篇博文：</p>

<ul>
<li><a href="http://biaobiaoqi.me/blog/2013/09/07/java-classloader/">《Java 类加载器浅析》</a></li>
<li><a href="http://biaobiaoqi.me/blog/2013/09/08/three-principles-of-classloader-operation/">《Java 类加载器三原则》</a></li>
</ul>


<p>以上博文中所提及的 Java 类加载机制，都是 Java1.2 及以后的版本，而在最早的 Java1.1 中类加载器是没有父子关系的模式的。这里将分别对 Java1.1 和 Java1.2 及以后的类加载版本进行展示。</p>

<h2>Java1.1 中的实现</h2>

<h3>原理介绍</h3>

<p>Java1.1 的类加载机制相对单一，用户自定义加载器的重写比较复杂。</p>

<p>主要需要重写加载器中的 Class loadClass(String name)方法。</p>

<p>Class loadClass(String name)或 loadClass(String name , boolean resolve)方法是加载的核心。它根据类的全名（比如 String 类的全名是 java.lang.String）获得对应类的二进制数据，然后通过 Class defineClass(byte[] b) 将二进制数据加载到 JVM 的方法区，并返回对应类的 Class 实例，然后根据可选的参数 resolve 决定是否需要现在解析这个类。最后将这个 Class 实例作为 loadClass 方法的返回值。</p>

<p>如果无法加载和 defineClass，即无法通过本加载器直接加载类的情况，则使用 Class findSystemClass(String name) 将类加载任务委派给系统类加载器查找。如果能找到则加载，否则抛出 ClassNotFoundException 异常。</p>

<h3>编程实例</h3>

<p>以下用实例来展示这一过程：</p>

<!--more-->


<p>类 CompilingClassLoader 是一个自定义加载器，它能直接读取 Java 源文件实现类加载。CLL 类的 main 方法为程序入口，通过 ComplilingClassLoader 加载一个 Foo 类，使用反射机制调用 Foo 类的 main 方法。</p>

<p>CompilingClassLoader.java</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
<span class='line-number'>144</span>
<span class='line-number'>145</span>
<span class='line-number'>146</span>
<span class='line-number'>147</span>
<span class='line-number'>148</span>
<span class='line-number'>149</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/* </span>
</span><span class='line'><span class="cm"> </span>
</span><span class='line'><span class="cm">A CompilingClassLoader compiles your Java source on-the-fly.  It </span>
</span><span class='line'><span class="cm">checks for nonexistent .class files, or .class files that are older </span>
</span><span class='line'><span class="cm">than their corresponding source code. </span>
</span><span class='line'><span class="cm"> </span>
</span><span class='line'><span class="cm">*/</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CompilingClassLoader</span> <span class="kd">extends</span> <span class="n">ClassLoader</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>  <span class="c1">// Given a filename, read the entirety of that file from disk  </span>
</span><span class='line'>  <span class="c1">// and return it as a byte array.  </span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">getBytes</span><span class="o">(</span> <span class="n">String</span> <span class="n">filename</span> <span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">// Find out the length of the file  </span>
</span><span class='line'>    <span class="n">File</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span> <span class="n">filename</span> <span class="o">);</span>
</span><span class='line'>    <span class="kt">long</span> <span class="n">len</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Create an array that&#39;s just the right size for the file&#39;s  </span>
</span><span class='line'>    <span class="c1">// contents  </span>
</span><span class='line'>    <span class="kt">byte</span> <span class="n">raw</span><span class="o">[]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[(</span><span class="kt">int</span><span class="o">)</span><span class="n">len</span><span class="o">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Open the file  </span>
</span><span class='line'>    <span class="n">FileInputStream</span> <span class="n">fin</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span> <span class="n">file</span> <span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Read all of it into the array; if we don&#39;t get all,  </span>
</span><span class='line'>    <span class="c1">// then it&#39;s an error.  </span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">fin</span><span class="o">.</span><span class="na">read</span><span class="o">(</span> <span class="n">raw</span> <span class="o">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">r</span> <span class="o">!=</span> <span class="n">len</span><span class="o">)</span>
</span><span class='line'>      <span class="k">throw</span> <span class="k">new</span> <span class="nf">IOException</span><span class="o">(</span> <span class="s">&quot;Can&#39;t read all, &quot;</span><span class="o">+</span><span class="n">r</span><span class="o">+</span><span class="s">&quot; != &quot;</span><span class="o">+</span><span class="n">len</span> <span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Don&#39;t forget to close the file!  </span>
</span><span class='line'>    <span class="n">fin</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// And finally return the file contents as an array  </span>
</span><span class='line'>    <span class="k">return</span> <span class="n">raw</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Spawn a process to compile the java source code file  </span>
</span><span class='line'>  <span class="c1">// specified in the &#39;javaFile&#39; parameter.  Return a true if  </span>
</span><span class='line'>  <span class="c1">// the compilation worked, false otherwise.  </span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">compile</span><span class="o">(</span> <span class="n">String</span> <span class="n">javaFile</span> <span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">// Let the user know what&#39;s going on  </span>
</span><span class='line'>    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span> <span class="s">&quot;CCL: Compiling &quot;</span><span class="o">+</span><span class="n">javaFile</span><span class="o">+</span><span class="s">&quot;...&quot;</span> <span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Start up the compiler  </span>
</span><span class='line'>    <span class="n">Process</span> <span class="n">p</span> <span class="o">=</span> <span class="n">Runtime</span><span class="o">.</span><span class="na">getRuntime</span><span class="o">().</span><span class="na">exec</span><span class="o">(</span> <span class="s">&quot;javac &quot;</span><span class="o">+</span><span class="n">javaFile</span> <span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Wait for it to finish running  </span>
</span><span class='line'>    <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">p</span><span class="o">.</span><span class="na">waitFor</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">catch</span><span class="o">(</span> <span class="n">InterruptedException</span> <span class="n">ie</span> <span class="o">)</span> <span class="o">{</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span> <span class="n">ie</span> <span class="o">);</span> <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Check the return code, in case of a compilation error  </span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">exitValue</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Tell whether the compilation worked  </span>
</span><span class='line'>    <span class="k">return</span> <span class="n">ret</span><span class="o">==</span><span class="mi">0</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// The heart of the ClassLoader -- automatically compile  </span>
</span><span class='line'>  <span class="c1">// source as necessary when looking for class files  </span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">Class</span> <span class="nf">loadClass</span><span class="o">(</span> <span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">resolve</span> <span class="o">)</span>
</span><span class='line'>      <span class="kd">throws</span> <span class="n">ClassNotFoundException</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Our goal is to get a Class object  </span>
</span><span class='line'>    <span class="n">Class</span> <span class="n">clas</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// First, see if we&#39;ve already dealt with this one  </span>
</span><span class='line'>    <span class="n">clas</span> <span class="o">=</span> <span class="n">findLoadedClass</span><span class="o">(</span> <span class="n">name</span> <span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//System.out.println( &quot;findLoadedClass: &quot;+clas );  </span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Create a pathname from the class name  </span>
</span><span class='line'>    <span class="c1">// E.g. java.lang.Object =&gt; java/lang/Object  </span>
</span><span class='line'>    <span class="n">String</span> <span class="n">fileStub</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span> <span class="sc">&#39;.&#39;</span><span class="o">,</span> <span class="sc">&#39;/&#39;</span> <span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Build objects pointing to the source code (.java) and object  </span>
</span><span class='line'>    <span class="c1">// code (.class)  </span>
</span><span class='line'>    <span class="n">String</span> <span class="n">javaFilename</span> <span class="o">=</span> <span class="n">fileStub</span><span class="o">+</span><span class="s">&quot;.java&quot;</span><span class="o">;</span>
</span><span class='line'>    <span class="n">String</span> <span class="n">classFilename</span> <span class="o">=</span> <span class="n">fileStub</span><span class="o">+</span><span class="s">&quot;.class&quot;</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">File</span> <span class="n">javaFile</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span> <span class="n">javaFilename</span> <span class="o">);</span>
</span><span class='line'>    <span class="n">File</span> <span class="n">classFile</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span> <span class="n">classFilename</span> <span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//System.out.println( &quot;j &quot;+javaFile.lastModified()+&quot; c &quot;+  </span>
</span><span class='line'>    <span class="c1">//  classFile.lastModified() );  </span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// First, see if we want to try compiling.  We do if (a) there  </span>
</span><span class='line'>    <span class="c1">// is source code, and either (b0) there is no object code,  </span>
</span><span class='line'>    <span class="c1">// or (b1) there is object code, but it&#39;s older than the source  </span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">javaFile</span><span class="o">.</span><span class="na">exists</span><span class="o">()</span> <span class="o">&amp;&amp;</span>
</span><span class='line'>         <span class="o">(!</span><span class="n">classFile</span><span class="o">.</span><span class="na">exists</span><span class="o">()</span> <span class="o">||</span>
</span><span class='line'>          <span class="n">javaFile</span><span class="o">.</span><span class="na">lastModified</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">classFile</span><span class="o">.</span><span class="na">lastModified</span><span class="o">()))</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">// Try to compile it.  If this doesn&#39;t work, then  </span>
</span><span class='line'>        <span class="c1">// we must declare failure.  (It&#39;s not good enough to use  </span>
</span><span class='line'>        <span class="c1">// and already-existing, but out-of-date, classfile)  </span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(!</span><span class="n">compile</span><span class="o">(</span> <span class="n">javaFilename</span> <span class="o">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">classFile</span><span class="o">.</span><span class="na">exists</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">throw</span> <span class="k">new</span> <span class="nf">ClassNotFoundException</span><span class="o">(</span> <span class="s">&quot;Compile failed: &quot;</span><span class="o">+</span><span class="n">javaFilename</span> <span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span> <span class="k">catch</span><span class="o">(</span> <span class="n">IOException</span> <span class="n">ie</span> <span class="o">)</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Another place where we might come to if we fail  </span>
</span><span class='line'>        <span class="c1">// to compile  </span>
</span><span class='line'>        <span class="k">throw</span> <span class="k">new</span> <span class="nf">ClassNotFoundException</span><span class="o">(</span> <span class="n">ie</span><span class="o">.</span><span class="na">toString</span><span class="o">()</span> <span class="o">);</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Let&#39;s try to load up the raw bytes, assuming they were  </span>
</span><span class='line'>    <span class="c1">// properly compiled, or didn&#39;t need to be compiled  </span>
</span><span class='line'>    <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1">// read the bytes  </span>
</span><span class='line'>      <span class="kt">byte</span> <span class="n">raw</span><span class="o">[]</span> <span class="o">=</span> <span class="n">getBytes</span><span class="o">(</span> <span class="n">classFilename</span> <span class="o">);</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1">// try to turn them into a class  </span>
</span><span class='line'>      <span class="n">clas</span> <span class="o">=</span> <span class="n">defineClass</span><span class="o">(</span> <span class="n">name</span><span class="o">,</span> <span class="n">raw</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">raw</span><span class="o">.</span><span class="na">length</span> <span class="o">);</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">catch</span><span class="o">(</span> <span class="n">IOException</span> <span class="n">ie</span> <span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="c1">// This is not a failure!  If we reach here, it might  </span>
</span><span class='line'>      <span class="c1">// mean that we are dealing with a class in a library,  </span>
</span><span class='line'>      <span class="c1">// such as java.lang.Object  </span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//System.out.println( &quot;defineClass: &quot;+clas );  </span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Maybe the class is in a library -- try loading  </span>
</span><span class='line'>    <span class="c1">// the normal way  </span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">clas</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">clas</span> <span class="o">=</span> <span class="n">findSystemClass</span><span class="o">(</span> <span class="n">name</span> <span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//System.out.println( &quot;findSystemClass: &quot;+clas );  </span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Resolve the class, if any, but only if the &quot;resolve&quot;  </span>
</span><span class='line'>    <span class="c1">// flag is set to true  </span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">resolve</span> <span class="o">&amp;&amp;</span> <span class="n">clas</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'>      <span class="n">resolveClass</span><span class="o">(</span> <span class="n">clas</span> <span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// If we still don&#39;t have a class, it&#39;s an error  </span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">clas</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</span><span class='line'>      <span class="k">throw</span> <span class="k">new</span> <span class="nf">ClassNotFoundException</span><span class="o">(</span> <span class="n">name</span> <span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Otherwise, return the class  </span>
</span><span class='line'>    <span class="k">return</span> <span class="n">clas</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>CCLRun.java</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="cm">/* </span>
</span><span class='line'><span class="cm"> </span>
</span><span class='line'><span class="cm">CCLRun executes a Java program by loading it through a </span>
</span><span class='line'><span class="cm">CompilingClassLoader. </span>
</span><span class='line'><span class="cm"> </span>
</span><span class='line'><span class="cm">*/</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CCLRun</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>  <span class="kd">static</span> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span> <span class="n">String</span> <span class="n">args</span><span class="o">[]</span> <span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// The first argument is the Java program (class) the user  </span>
</span><span class='line'>    <span class="c1">// wants to run  </span>
</span><span class='line'>    <span class="n">String</span> <span class="n">progClass</span> <span class="o">=</span> <span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// And the arguments to that program are just  </span>
</span><span class='line'>    <span class="c1">// arguments 1..n, so separate those out into  </span>
</span><span class='line'>    <span class="c1">// their own array  </span>
</span><span class='line'>    <span class="n">String</span> <span class="n">progArgs</span><span class="o">[]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">String</span><span class="o">[</span><span class="n">args</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
</span><span class='line'>    <span class="n">System</span><span class="o">.</span><span class="na">arraycopy</span><span class="o">(</span> <span class="n">args</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="n">progArgs</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">progArgs</span><span class="o">.</span><span class="na">length</span> <span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Create a CompilingClassLoader  </span>
</span><span class='line'>    <span class="n">CompilingClassLoader</span> <span class="n">ccl</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CompilingClassLoader</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Load the main class through our CCL  </span>
</span><span class='line'>    <span class="n">Class</span> <span class="n">clas</span> <span class="o">=</span> <span class="n">ccl</span><span class="o">.</span><span class="na">loadClass</span><span class="o">(</span> <span class="n">progClass</span> <span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Use reflection to call its main() method, and to  </span>
</span><span class='line'>    <span class="c1">// pass the arguments in.  </span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Get a class representing the type of the main method&#39;s argument  </span>
</span><span class='line'>    <span class="n">Class</span> <span class="n">mainArgType</span><span class="o">[]</span> <span class="o">=</span> <span class="o">{</span> <span class="o">(</span><span class="k">new</span> <span class="n">String</span><span class="o">[</span><span class="mi">0</span><span class="o">]).</span><span class="na">getClass</span><span class="o">()</span> <span class="o">};</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Find the standard main method in the class  </span>
</span><span class='line'>    <span class="n">Method</span> <span class="n">main</span> <span class="o">=</span> <span class="n">clas</span><span class="o">.</span><span class="na">getMethod</span><span class="o">(</span> <span class="s">&quot;main&quot;</span><span class="o">,</span> <span class="n">mainArgType</span> <span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Create a list containing the arguments -- in this case,  </span>
</span><span class='line'>    <span class="c1">// an array of strings  </span>
</span><span class='line'>    <span class="n">Object</span> <span class="n">argsArray</span><span class="o">[]</span> <span class="o">=</span> <span class="o">{</span> <span class="n">progArgs</span> <span class="o">};</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Call the method  </span>
</span><span class='line'>    <span class="n">main</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span> <span class="kc">null</span><span class="o">,</span> <span class="n">argsArray</span> <span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Foo.java</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Foo</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>  <span class="kd">static</span> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span> <span class="n">String</span> <span class="n">args</span><span class="o">[]</span> <span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span> <span class="s">&quot;foo! &quot;</span><span class="o">+</span><span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="n">args</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>执行 CLL 类，命令行传入 Foo 的类名。执行结果如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nl">CCL:</span> <span class="n">Compiling</span> <span class="n">Foo</span><span class="o">.</span><span class="na">java</span><span class="o">...</span>
</span><span class='line'><span class="n">foo</span><span class="o">!</span> <span class="n">arg1</span> <span class="n">arg2</span>
</span></code></pre></td></tr></table></div></figure>


<p>具体参见资料：<a href="http://www.ibm.com/developerworks/java/tutorials/j-classloader/index.html">IBM DeveloperWorks ： Understanding the Java ClassLoader</a>， 这是一篇 2001 年的文章，是早年 Java1.1 的实现方式。如今的 Java 已经变得更加人性化，多功能化，鲁棒性也更强了。</p>

<h2>Java1.2 以后的实现</h2>

<h3>原理介绍</h3>

<p>Java1.2 以后，类加载器实现了 parent-child 模型，能更好的控制安全性方面的问题。</p>

<p>由于 loadClass()方法中包含了 parent-child 的责任链模式逻辑，自定义类加载的自定义部分用策略模式从 loadClass()方法中剥离到了 findClass()中。对应的有一个 findLoadedClass()，这个方法用来实现查找当前加载器是否有加载该某类。</p>

<p>loadClass()：加载一个类时，先调 findLoadedClass()，如果没有找到，则调用父亲加载器的加载方法。如果父亲找到了该类，就返回 Class 实例，没有找到，则父亲加载器会抛出一个异常，捕捉到这个异常后，儿子加载器会自己调用 findClass()尝试实现对类的加载。如果依然没有成功加载，则再向外抛出一个异常。通过向父亲加载器迭代实现了 parent-first 的委托关系。</p>

<p>类加载的流程如图：这里显示了一个类未能成功加载所要经历的流程。（来自 <a href="http://stackoverflow.com/questions/3544614/how-is-the-control-flow-to-findclass-of">stackoverflow:how-is-the-control-flow-to-findclass-of</a>）</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>  <span class="n">A</span><span class="o">.</span><span class="na">loadClass</span><span class="o">()</span>
</span><span class='line'>       <span class="o">|</span>
</span><span class='line'>   <span class="o">(</span><span class="n">not</span><span class="o">-</span><span class="n">found</span><span class="o">?)</span> <span class="o">(</span><span class="n">by</span> <span class="n">findLoadedClass</span><span class="o">)</span>
</span><span class='line'>       <span class="o">|</span>
</span><span class='line'>  <span class="n">B</span><span class="o">.</span><span class="na">loadClass</span><span class="o">()</span>
</span><span class='line'>       <span class="o">|</span>
</span><span class='line'>   <span class="o">(</span><span class="n">not</span> <span class="n">found</span><span class="o">?)</span> <span class="o">(</span><span class="n">by</span> <span class="n">findLoadedClass</span><span class="o">)</span>
</span><span class='line'>       <span class="o">|</span>
</span><span class='line'><span class="n">systemclassloader</span><span class="o">.</span><span class="na">loadClass</span>  <span class="o">(</span><span class="n">Bs</span> <span class="n">parent</span><span class="o">,</span> <span class="n">also</span> <span class="n">can</span> <span class="n">be</span>
</span><span class='line'>       <span class="o">|</span>                  <span class="n">called</span> <span class="n">classpath</span> <span class="n">classloader</span><span class="o">)</span>
</span><span class='line'>       <span class="o">|</span>
</span><span class='line'>   <span class="o">(</span><span class="n">not</span> <span class="n">found</span><span class="o">?)</span> <span class="o">(</span><span class="n">by</span> <span class="n">findLoadedClass</span><span class="o">)</span>
</span><span class='line'>       <span class="o">|</span>
</span><span class='line'><span class="n">bootstrap</span> <span class="n">classloader</span><span class="o">.</span><span class="na">loadClass</span> <span class="o">(</span><span class="n">the</span> <span class="n">bootstrap</span> <span class="n">classloader</span><span class="o">,</span>
</span><span class='line'>       <span class="o">|</span>                   <span class="o">(</span><span class="k">this</span> <span class="n">has</span> <span class="n">no</span> <span class="n">parent</span><span class="o">)</span>
</span><span class='line'>       <span class="o">|</span>
</span><span class='line'>   <span class="o">(</span><span class="n">not</span> <span class="n">found</span><span class="o">?)</span>
</span><span class='line'>       <span class="o">|</span>
</span><span class='line'><span class="n">systemclassloader</span><span class="o">.</span><span class="na">findClass</span>  <span class="o">(</span><span class="n">on</span> <span class="n">system</span> <span class="n">classloader</span><span class="o">,</span>
</span><span class='line'>       <span class="o">|</span>                   <span class="n">will</span> <span class="k">try</span> <span class="n">to</span> <span class="s">&quot;find&quot;</span> <span class="kd">class</span> <span class="nc">in</span> <span class="s">&quot;classpath&quot;</span><span class="o">)</span>
</span><span class='line'>       <span class="o">|</span>
</span><span class='line'>   <span class="o">(</span><span class="n">not</span> <span class="n">found</span><span class="o">?)</span> <span class="n">ClassNotFoundException</span>
</span><span class='line'>       <span class="o">|</span>
</span><span class='line'>   <span class="n">B</span><span class="o">.</span><span class="na">findClass</span>
</span><span class='line'>       <span class="o">|</span>
</span><span class='line'>   <span class="o">(</span><span class="n">not</span> <span class="n">found</span><span class="o">?)</span> <span class="n">ClassNotFoundException</span>
</span><span class='line'>       <span class="o">|</span>
</span><span class='line'>   <span class="n">A</span><span class="o">.</span><span class="na">findClass</span>
</span><span class='line'>       <span class="o">|</span>
</span><span class='line'>    <span class="o">(</span><span class="n">not</span> <span class="n">found</span><span class="o">?)</span>
</span><span class='line'>       <span class="o">|</span>
</span><span class='line'>   <span class="n">ClassNotFoundException</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意，对于扩展类加载器，通过 getParent()方法返回的父亲加载器是 null，因为引导类加载器是本地实现的，并非 Java 实现。那么如何从扩展类加载器向上回溯呢？答案如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="k">try</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">parent</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>       <span class="n">c</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="na">loadClass</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>       <span class="n">c</span> <span class="o">=</span> <span class="n">findBootstrapClassOrNull</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ClassNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>   <span class="c1">// ClassNotFoundException thrown if class not found  </span>
</span><span class='line'>     <span class="c1">// from the non-null parent class loader  </span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
这是类加载器的源代码，对于父加载器为 null 的情况，会直接调用 findBootstrapClassOrNull()方法尝试用引导类加载器加载。通过源代码，能够很好的理解这里的 parent-child 模型了。</p>

<p>另注意，对于基于 parent-child 模型的类加载器实现，都需要定义一个以 parent 类加载器作为参数的构造函数，以指定父加载器。如果直接调用没有参数的构造函数，则默认制定的是 systemclassloader 作为 parent。</p>

<h3>编程实例</h3>

<p>下面的例子是我用来实现动态分析 Java 类关系的加载器代码。</p>

<p>具体逻辑是：调用 ASM 开源库的 API，在加载器加载类时，修改类文件中的字节码，插入相应的字节码语句，让对象在创建或执行相应指令时，在 log 文件中记录自己的行为。</p>

<p>在编码的过程中，我遇到的一个错误：将需要使用自定义加载器加载的类文件直接放在了 eclipse 工程中的 bin 目录下。而这个目录是可以通过系统类加载器找到路径并加载的。根据 parent-first 的实现，这些类直接被系统类加载器加载了，也就绕过了自定义加载器的处理机制。修改过路径以后没有出现相应问题了。</p>

<p>ASMClassLoader.java</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kn">package</span> <span class="n">biaobiaoqi</span><span class="o">.</span><span class="na">classLoader</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.objectweb.asm.ClassReader</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.objectweb.asm.ClassWriter</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="nn">biaobiaoqi.asm.*</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ASMClassLoader</span> <span class="kd">extends</span> <span class="n">ClassLoader</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="n">String</span> <span class="n">basePath</span> <span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/**reference to System Classloader as the parent class loader </span>
</span><span class='line'><span class="cm">     * @param path &lt;br&gt; the path of .class files will be loaded </span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">ASMClassLoader</span><span class="o">(</span><span class="n">String</span> <span class="n">path</span><span class="o">){</span>
</span><span class='line'>        <span class="n">basePath</span> <span class="o">=</span> <span class="n">path</span> <span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/** </span>
</span><span class='line'><span class="cm">     * reference to parent as it&#39;s parent classloader </span>
</span><span class='line'><span class="cm">     * @param path </span>
</span><span class='line'><span class="cm">     * @param parent </span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">ASMClassLoader</span><span class="o">(</span><span class="n">String</span> <span class="n">path</span> <span class="o">,</span> <span class="n">ClassLoader</span> <span class="n">parent</span><span class="o">){</span>
</span><span class='line'>        <span class="kd">super</span><span class="o">(</span><span class="n">parent</span><span class="o">);</span>
</span><span class='line'>        <span class="n">basePath</span> <span class="o">=</span> <span class="n">path</span> <span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Class</span> <span class="nf">findClass</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ClassNotFoundException</span><span class="o">{</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;findClass&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="kt">byte</span><span class="o">[]</span> <span class="n">raw</span><span class="o">;</span>
</span><span class='line'>        <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">raw</span> <span class="o">=</span> <span class="n">getBytesFromBasePath</span><span class="o">(</span> <span class="n">name</span> <span class="o">);</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">ClassNotFoundException</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">byte</span><span class="o">[]</span> <span class="n">transformed</span> <span class="o">=</span> <span class="n">instrumentBtyeCode</span><span class="o">(</span><span class="n">raw</span><span class="o">);</span>
</span><span class='line'>        <span class="cm">/* </span>
</span><span class='line'><span class="cm">        try{ </span>
</span><span class='line'><span class="cm">            FileOutputStream file = new FileOutputStream( &quot;/home/biaobiaoqi/&quot; +name.replace( &#39;.&#39;, &#39;/&#39; )+&quot;.class&quot;); </span>
</span><span class='line'><span class="cm">            file.write( transformed); </span>
</span><span class='line'><span class="cm">            file.close(); </span>
</span><span class='line'><span class="cm">        } </span>
</span><span class='line'><span class="cm">        catch (IOException e) { </span>
</span><span class='line'><span class="cm">            e.printStackTrace(); </span>
</span><span class='line'><span class="cm">        } </span>
</span><span class='line'><span class="cm">        */</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">transformed</span> <span class="o">==</span> <span class="kc">null</span><span class="o">){</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">ClassNotFoundException</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="nf">defineClass</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">transformed</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">transformed</span><span class="o">.</span><span class="na">length</span> <span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">getBytesFromBasePath</span><span class="o">(</span> <span class="n">String</span> <span class="n">className</span> <span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">,</span><span class="n">ClassNotFoundException</span><span class="o">{</span>
</span><span class='line'>        <span class="n">String</span> <span class="n">fileStub</span> <span class="o">=</span> <span class="n">className</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span> <span class="sc">&#39;.&#39;</span><span class="o">,</span> <span class="sc">&#39;/&#39;</span> <span class="o">);</span>
</span><span class='line'>        <span class="n">String</span> <span class="n">classFileName</span> <span class="o">=</span> <span class="n">basePath</span> <span class="o">+</span><span class="n">fileStub</span><span class="o">+</span><span class="s">&quot;.class&quot;</span><span class="o">;</span>
</span><span class='line'>        <span class="n">File</span> <span class="n">file</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="o">(</span> <span class="n">classFileName</span> <span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">long</span> <span class="n">len</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
</span><span class='line'>        <span class="kt">byte</span> <span class="n">raw</span><span class="o">[]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[(</span><span class="kt">int</span><span class="o">)</span><span class="n">len</span><span class="o">];</span>
</span><span class='line'>        <span class="n">FileInputStream</span> <span class="n">fin</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FileInputStream</span><span class="o">(</span> <span class="n">file</span> <span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">fin</span><span class="o">.</span><span class="na">read</span><span class="o">(</span> <span class="n">raw</span> <span class="o">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">r</span> <span class="o">!=</span> <span class="n">len</span><span class="o">)</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IOException</span><span class="o">(</span> <span class="s">&quot;Can&#39;t read all, &quot;</span><span class="o">+</span><span class="n">r</span><span class="o">+</span><span class="s">&quot; != &quot;</span><span class="o">+</span><span class="n">len</span> <span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">fin</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">raw</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">instrumentBtyeCode</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">raw</span><span class="o">){</span>
</span><span class='line'>        <span class="n">ClassWriter</span> <span class="n">cw</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ClassWriter</span><span class="o">(</span><span class="n">ClassWriter</span><span class="o">.</span><span class="na">COMPUTE_FRAMES</span><span class="o">);</span>
</span><span class='line'>        <span class="n">ASMClassAdapter</span> <span class="n">mca</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ASMClassAdapter</span><span class="o">(</span><span class="n">cw</span><span class="o">);</span>
</span><span class='line'>        <span class="n">ClassReader</span> <span class="n">cr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ClassReader</span><span class="o">(</span><span class="n">raw</span><span class="o">);</span>
</span><span class='line'>        <span class="n">cr</span><span class="o">.</span><span class="na">accept</span><span class="o">(</span><span class="n">mca</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">cw</span><span class="o">.</span><span class="na">toByteArray</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Class</span> <span class="nf">loadClass</span><span class="o">(</span> <span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">resolve</span> <span class="o">)</span>
</span><span class='line'>        <span class="kd">throws</span> <span class="n">ClassNotFoundException</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;loadClass_resolve&quot;</span><span class="o">);</span>
</span><span class='line'>          <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">loadClass</span><span class="o">(</span><span class="n">name</span> <span class="o">,</span><span class="n">resolve</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Class</span> <span class="nf">loadClass</span><span class="o">(</span> <span class="n">String</span> <span class="n">name</span> <span class="o">)</span>
</span><span class='line'>        <span class="kd">throws</span> <span class="n">ClassNotFoundException</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;loadClass&quot;</span><span class="o">);</span>
</span><span class='line'>          <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">loadClass</span><span class="o">(</span><span class="n">name</span> <span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.me/blog/2013/09/08/java-class-loader-in-practice/'>http://biaobiaoqi.me/blog/2013/09/08/java-class-loader-in-practice/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java 类加载器]]></title>
    <link href="http://biaobiaoqi.me/blog/2013/09/07/java-classloader/"/>
    <updated>2013-09-07T23:15:00+08:00</updated>
    <id>http://biaobiaoqi.me/blog/2013/09/07/java-classloader</id>
    <content type="html"><![CDATA[<h2>背景知识</h2>

<p>Java 平台无关的特性是由 JVM(Java 虚拟机)支撑的。不同平台有不同的 JVM 支持。</p>

<p>计算机领域有这么一句话：</p>

<blockquote><p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。</p></blockquote>

<p>JVM 其实也可以看做是运行的 Java 程序和实际的硬件架构之间的一个新抽象层。</p>

<p>一个 Java 程序从编写到执行的流程一句话概括如下：首先将 Java 源代码（*.java 文件）编译成字节码（*.class 文件，字节码之于 Java 源码，类比于汇编代码之于 C 源码），然后由 JVM 运行那些字节码文件。</p>

<p>JVM 工作原理如下图</p>

<p><img src="https://dl.dropboxusercontent.com/u/64021093/Java%20Classloader/JVM%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.gif" alt="JVM framework" /></p>

<p>Java 中所有的类文件都需要由类加载器（Class Loader）装载到 JVM 中。可以简单的将 JVM 理解为一个工厂，类文件就是等待加工的原料，加载器则是装载货物的工人。Java 类被装载之后，才能进入到 JVM 的运行时机制中，开始运行。</p>

<h2>类加载器的作用</h2>

<p>顾名思义，Java 类加载器的作用是向 JVM 中装载类。</p>

<p>这种动态装载的技术是 Java 的一种创新，让类能够动态加载到 JVM 中执行（更详细的介绍参见 <a href="http://www.ibm.com/developerworks/java/library/j-dyn0429/">Java programming dynamics, Part 1: Java classes and class loading</a>）。</p>

<!--more-->


<p>而它的意义远非仅仅是加载类这么简单。实际上，类加载器对 Java 的沙箱模型具有重大意义。他和安全管理模块（负责对类文件中的字节码进行校验，防止恶意代码的攻击）一起保证了 JVM 运行的安全性。</p>

<h2>类加载机制</h2>

<p>大体上，每个 Java 应用使用了如下几种类型的类加载器:</p>

<ul>
<li><p>1.引导类加载器（bootstrap class loader）</p>

<p>  它由 C++编写（注意，它非常特殊，并非 Java 中的 ClassLoader 类的子类）。当 JVM 启动时，引导类加载器也随之启动，它负责加载 Java 核心类，如 JRE 的 rt.jar、charsets.jar 等。从 Java1.2 开始，它只加载 Java 核心 API 部分。</p>

<p>  因为这些类是系统信任的类，所以这里的装载，跳过了很多对字节码的验证过程。</p></li>
<li><p>2.扩展类加载器（extension class loader）</p>

<p> 它负责加载/lib/ext 中的 java 扩展类。</p></li>
<li><p>3.系统类加载器（System Class Loader）</p>

<p>这是很重要的一个加载器，加载 Java 的路径 classpath 下的类。应用程序的装载默认由它负责。</p></li>
<li><p>4.自定义类加载器</p>

<p> 由系统类加载器继承得到。它的存在让我们能定制出各种不同功能的加载器，增加了 Java 的可扩展性。自定义的类加载器如果没有显示的继承关系，则其父类默认为系统类加载器。</p></li>
</ul>


<p>一个 JVM，只拥有一个引导类加载器，同时可以拥有多个自定义类加载器，方便不同应用环境的用户定制。比如，自定义类加载器能够动态的修改字节码，让它能接收并加载从网上传来的类文件或 Jar 包，甚至是任何编码方式的压缩包。只要自定义类加载器能够正确识别并调用相应方法来实现类的加载和解析，一切都有可能。</p>

<p>四种加载器不是四个独立的部分，他们之间具有一种特殊的父子关系，每个类加载器都保持着他们的父加载器的应用，共同组成了一条父子关系链，被称作 parent-delegation 模式。如下图</p>

<p><img src="https://dl.dropboxusercontent.com/u/64021093/Java%20Classloader/java%20classloader%20hierachy.gif" alt="class loader hirerachy" /></p>

<p>类加载器按照如此树形排列。类加载的查找顺序是：</p>

<p>cache &#8211;> parent &#8211;> self</p>

<p>子类加载器需要加载某个类时，并不是直接加载，而是首先查看 cache（cache 可以理解为加载器已经加载过的类的记录）。如果没有，则向父加载器提出请求，查看是否存在于父加载器的 cache 中。如此往上，直到根部的引导类加载器。如果引导类加载器的 cache 也没有这个类，则它尝试直接加载这个类，如果无法成功，则请求儿子加载器加载，依次往下。</p>

<p>直接接受程序请求加载某类的加载器被称作初始类加载器（Initiating class loader），而最终加载了该类的加载器则成为定义类加载器（defining class loader）。</p>

<p>类加载器的<code>getParent()</code>方法可以获得加载器的父亲。下面的代码用于输出各个层级的类加载器。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ClassLoaderTest</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">ClassLoader</span> <span class="n">loader</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getContextClassLoader</span><span class="o">();</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;current loader:&quot;</span><span class="o">+</span><span class="n">loader</span><span class="o">);</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;parent loader:&quot;</span><span class="o">+</span><span class="n">loader</span><span class="o">.</span><span class="na">getParent</span><span class="o">());</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;grandparent loader:&quot;</span><span class="o">+</span><span class="n">loader</span><span class="o">.</span><span class="na">getParent</span><span class="o">().</span><span class="na">getParent</span><span class="o">());</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>显示的结果是</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">current</span> <span class="nl">loader:</span><span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">Launcher</span><span class="n">$AppClassLoader</span><span class="err">@</span><span class="mi">1</span><span class="n">c78e57</span>
</span><span class='line'><span class="n">parent</span> <span class="nl">loader:</span><span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">Launcher</span><span class="n">$ExtClassLoader</span><span class="err">@</span><span class="mi">5224</span><span class="n">ee</span>
</span><span class='line'><span class="n">grandparent</span> <span class="nl">loader:</span><span class="kc">null</span>
</span></code></pre></td></tr></table></div></figure>


<p>grandparent 显示的值是 null，并不意味着他没有 parent，而是因为它是由 C++编写的引导类加载器。他并不是 ClassLoader 类的子类，也就无法使用 getParent()方法获得返回了。</p>

<p>如此，parent class loader 总是拥有更高的加载优先级，这让想利用自定义加载器伪装加载某些重要类的恶意代码无法得逞。如果好奇，你可以尝试自己写 package java.lang 里的 String 类，加载执行试试～
另外，当类 A 调用另类 B 时，B 会由加载 A 的 class loader 加载，从而实现。</p>

<h2>加载类的流程</h2>

<p>类的装载大致可以分为三个步骤（如下图）：</p>

<ul>
<li>1.装载(loading)</li>
<li>2.链接(linking)</li>
<li>3.初始化(initialising)</li>
</ul>


<p><img src="https://dl.dropboxusercontent.com/u/64021093/Java%20Classloader/ClassLoaderProcess.gif" alt="class loader process" /></p>

<p>跟 C++或者 C 程序有很大的不同，编译过后的类文件中的字节码并没有设计好内存布局，这些需要等到加载之后的链接阶段，才会完成。这也是 java 可移植性中精彩的一笔！</p>

<p>关于类的加载、链接和初始化，请参见另一篇博文：<a href="http://biaobiaoqi.me/blog/2013/09/08/java-class-loading-linking-and-initialising/">《Java 类的装载、链接和初始化》</a></p>

<p>关于类加载器的编程实践，请参见另一篇博文：<a href="http://biaobiaoqi.me/blog/2013/09/08/java-class-loader-in-practice/">《Java 类加载器编程实践》</a></p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.me/blog/2013/09/07/java-classloader/'>http://biaobiaoqi.me/blog/2013/09/07/java-classloader/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android小游戏：功夫蛇 团队开发经验总结]]></title>
    <link href="http://biaobiaoqi.me/blog/2013/09/06/kongfu-snake-project-summary/"/>
    <updated>2013-09-06T00:00:00+08:00</updated>
    <id>http://biaobiaoqi.me/blog/2013/09/06/kongfu-snake-project-summary</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>曾经没有代码管理的习惯，不用回版本控制工具。这种陋习虽然让原来千穿百孔的代码远离了实现，但这种逃避未必就是一件好事吧;)。
于是从博客中挖出了原来的文章，并千辛万苦找到了最早的代码贴出来。</p>

<p>这篇文章是参加 Google 的 Android 应用开发大赛时，写的总结帖。主要从团队和设计两个方面进行了分析总结。虽然如今看来一些内容显得稚嫩和粗糙，
但没有功劳还是有苦劳的！还是那句话，我们要不断收集生活中的珠子，等到最后，才能串成一条链。</p>

<p>我同步的将代码贴到了自己的 <a href="https://github.com/biaobiaoqi/kongfusnake">github</a> 里。对于这份代码，或许以后有时间，可以重构下代码？又或者没有时间？
这都无所谓。能够让原来的脚印在路途中获得一席之地，也才有之后更好的旅程。</p>

<p>内容不做修改，这就是 12 年 1 月时，我的思维层次总结啦。</p>

<h2>原文</h2>

<p>此文从团队和设计两方面，进行了一些经验总结。没有涉及技术实现的讨论。</p>

<p>KongfuSnake，这是一款取材自贪吃蛇的 android 游戏。（弱弱的说，这个取材其实这是我最不敢说出口的，被大多数人评价为老套、
过时的创意>&lt;&#8230;但需要解释的是，我们确实做了很多“微创新”~）。</p>

<!--more-->


<p>下载链接：<a href="http://www.google.cn/university/androidchallenge/2011/gallery.html#tab=d1-13">KongfuSnake</a></p>

<h3>1.背景</h3>

<p>参加的 google 的 android 应用大学生挑战赛上个月已经画上了句号。</p>

<p>结果是幸运的，最终我们跟另外的 4 只队伍一起，获得了全国总决赛二等奖。当然，名次并不是最重要，重要的是经历了什么，学到了什么。于是，用心的敲下这些文字，给自己的旅途留下脚印，期望对以后的学习、生活有所助益。也算是认知盈余吧。</p>

<p>11 年 6 月份吧，大三下学期萌发参加比赛的念头。</p>

<p>当时的考虑是，自己由于时间安排的关系，无法参加暑期实习，而本科前三年重心一直不在编程上，想借暑假的空闲机会，体验一下比赛的乐趣，
也算见识下 android 的开发体系。而作为团队参加也可以积累些许技术沟通的经验，于是找到了同专业的一个同学，一起组队参赛。
后期，又邀请了工业设计专业的一位同学加入，为作品的 UI 润色，用足了比赛规定的最多三个名额的限定。</p>

<p>回过头来，那些小九九也算达到了一些～甚至还有当时没有考虑到的收获，比如对小游戏设计方面的浅显理解。</p>

<h3>2.团队</h3>

<p>这是一个三人的小规模学生团队，说我们小打小闹也罢，团队里的沟通交流总归是存在的。麻雀虽小，五脏俱全～</p>

<h4>2.1.团队的组成</h4>

<p>经历过以前一些团队作业，我觉得大学生团队最重要的问题就是是否每个人都有足够的时间。基于这个原则，我找到了 yzq 童鞋。</p>

<p>后期，我们发现必须找人润色 UI，又通过学校论坛征到了比我们低一级的 mqx 童鞋，这一步走的略显仓促，与项目早期自己的侥幸心理有关>&lt;&#8230;.
准备不周全。幸运的是，最终效果还不错。</p>

<p>值得反思的是，最初我在征 UI 设计时，没有与候选人沟通好具体的职责：
团队需要的是能尽可能的提供 UI 的整套解决方案，而不仅仅是按照程序开发者的意愿 P 几张图而已。
由于这一失误，mqx 童鞋后来的大多数时间里只是照着后半句在做，让我们编程人员力不从心>&lt;&#8230;.。
当然，另一个侧面，也算是培养了自己产品设计的一些理念吧。。</p>

<h4>2.2.团队沟通</h4>

<p>开发期间，由于暑假回家、之后我出国交流等原因，大家很多时间都不在一起。只是通过 QQ 进行交流的。交流的方式也比较随意。</p>

<p>由于项目小，我们没有使用到 svn、git 等版本控制工具。这些原始的沟通方式，虽然在小项目中负面影响不大，但相信随着项目规模的增大，
它们对效率的影响会显现出来，特别是版本控制方面。这里以后需要注意。</p>

<p>另外，在沟通技巧上，自己比较欠缺。由于专业不同的关系，我与负责 UI 的童鞋对某些设计的理解不尽相同，
而自己起初没有注意到这一点，让大家无谓的耗费了精力；每个人都会有不同的想法，在处理矛盾想法的解决时，作为项目发起人，
我的方式不够委婉。</p>

<h4>2.3.团队建设</h4>

<p>我有意识的提及一旦获奖，我们可以获得的收益，想借此激励大家的积极性。不过技巧性还需要提炼。</p>

<h3>3.设计</h3>

<p>评价一款手机游戏的优缺点，相对来说比较容易。但真的要做出决策如何设计一款游戏，则难了很多。</p>

<p>看过网上很多移动应用开发的设计指南，一条一条的罗列挺纷繁的，总结自己粗劣的设计经验，是如下两条：创新的想法和合理的取舍（trade-off）。</p>

<p>创新能挖掘出用户的需求，合理的取舍，能让众多创新的想法融合出一个完整的产品构图。</p>

<h4>3.1 关于创新</h4>

<p>不要被原来的设计需求禁锢。创新可以挖掘出新的需求。</p>

<p>刚开始的时候无法囊括所有的创新点，新的点子可能在之后的经历中又突然冒出，毫不犹豫的去尝试，不断迭代改进。</p>

<p>当然很多创新点可能在游戏的整体中不和谐，但这些层出不穷的创新只要有千分之一是可行的，就可能让产品脱颖而出，不再陈旧。</p>

<h4>3.2 关于取舍（trade-off）</h4>

<p>突出主题。</p>

<p>手机界面相对较小，视觉上容量本就不多。细小的图形元素容易造成蔓延昏花的效果。突出能抓住用户眼球的主题很重要
，必要的时候，需要适当舍弃可能造成混淆的元素。</p>

<p>增强元素的表现力和区分度。视觉、听觉、触觉（震动）等各个方面增强各个元素之间的区分度和表现力。</p>

<p>统一风格。每一个按键，每一个游戏元素，包括背景、布局、音效，都需要统一风格。</p>

<h3>另</h3>

<p>由于时间拖得比较久，没有及时的总结经验教训，感觉很多细节都已经离我远去了>&lt;&#8230;下次得注意了。</p>

<h3>另另</h3>

<p>由于代码写的比较搓，也就不公开放出了强奸大家的眼球了>&lt;&#8230;，要学的还有很多。<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.me/blog/2013/09/06/kongfu-snake-project-summary/'>http://biaobiaoqi.me/blog/2013/09/06/kongfu-snake-project-summary/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google Android应用开发大赛参赛记]]></title>
    <link href="http://biaobiaoqi.me/blog/2013/09/05/google-android-challenge-2011/"/>
    <updated>2013-09-05T23:51:00+08:00</updated>
    <id>http://biaobiaoqi.me/blog/2013/09/05/google-android-challenge-2011</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>大三结束的暑假，跟另外两个同学一起组队参加了 Google 第二届 Andoid 应用开发中国大学生挑战赛，有幸获得了<a href="http://www.google.cn/university/androidchallenge/2011/gallery.html#tab=d1-13">全国总决赛的前 6 名</a>。
虽然只是移动客户端的开发实践，但也第一次让我体验到了工程的魅力、团队协作的成就感和编码的快乐。</p>

<p>以下内容实际上是一份属于当时经验匮乏的团队的开发草稿，回头看来，满载的无知和丰腴的老土，姑且把它当做开发日志吧;)</p>

<p>不做内容删改（些许格式调整）,原文如下：</p>

<!--more-->


<h2>功夫蛇开发日志</h2>

<h3>2011-06-24</h3>

<p>转眼到大三了都。</p>

<p>说来惭愧，什么项目都没做过，课程的大作业都美认真完成的人，谈何项目呢- -#</p>

<p>技术是王道，其他的，GPA、社团都是浮云。</p>

<p>于是，想着，从现在开始，要做点什么了。觉得，这才是我的兴趣所在。</p>

<p>于是，看到了这个契机。Google Android 应用开发大赛~</p>

<p>于是找到了 yzq 童鞋作搭档。</p>

<p>现在是 6.24。比赛截止日期位 10 月 10。</p>

<p>计划执行的时间是 7 到 9 月两个月。</p>

<p>6.24 - 7.10 技术准备、定题设计。查阅技术资料（读源代码，向老师请教定题方向）</p>

<p>7.10 - 9 月 coding</p>

<p>9 月以后 精化。</p>

<p>于是，开始啦～～</p>

<h3>2011-07-01</h3>

<p>期末考试完毕，我们计划用两周的时间预热，查阅 android 开发知识，想参赛的 idea。</p>

<h3>2011-07-10</h3>

<p>在与 hhl 老师的讨论中，突然想到了一个不错的点子。一个以贪吃蛇为背景，以水果忍者为游戏模式，以重力感应球为操控的 android 游戏：</p>

<p>重力感应操控蛇前进的方向，蛇不会撞墙死、撞自己死。只是不停的吃果子得分，游戏定时计分，不同的果子得分不同。</p>

<p>具体细节待定。游戏拥有自然的物理模型，游戏时，蛇就像在自己的手机上移动。</p>

<p>这个 idea 被 hhl 老师无情的鄙视了，说很早在电视上就有如此实现的游戏。当然，他也安慰我说，没事，在游戏逻辑中做些微创新也是不错的。</p>

<p>犹豫了几天，没有更好的点子，于是决定就是它了。</p>

<p>分工：我负责游戏逻辑、游戏动画的开发（我的手机重力感应功能比较好，I9000 啊~非广告哈~）。yzq 负责游戏整体框架开发。</p>

<h3>2011-07-18</h3>

<p>从 APIDemo 中得 Snake 游戏入手，了解了 android 游戏的框架。</p>

<p>并改良实现了能用重力感应控制方向的经典贪吃蛇（游戏逻辑混乱，且蛇的移动不是连续动画的）。</p>

<h3>2011-07-23</h3>

<p>搭建完成了初步的游戏逻辑（增加了自创的 Round 机制增加游戏的多样性），实现了基本构想，但动画效果很一般。</p>

<p>在暑假短学期的最后的展示课上，向全班同学展示了我们现阶段的成果。在跟大家的交流过程中，萌生了增加 移动的果子 的想法。</p>

<p>在动画实现方面，自己觉得要是做成不连续动画的话，只要控制好游戏风格，倒无所谓。但 hhl 老师坚持实现流畅的动画效果。</p>

<h3>2011-07-29</h3>

<p>重新构建了游戏框架，用 surfaceview 取缔原先的 view，独创的用特殊 patheffect 的 path 实现了蛇体的形状。动画和交互的流畅性。</p>

<h3>2011-08-07</h3>

<p>由于下学期要去爱尔兰交流半年，暑假回家两周。开发暂停。</p>

<h3>2011-08-22</h3>

<p>回到学校，开始与 yzq 的模块拼接工作。</p>

<h3>2011-08-25</h3>

<p>完成拼接工作，开始详细讨论游戏的精华改进。（此时还没有像样的 UI）</p>

<p>定游戏主题为 Kongfu Snake &#8211; 功夫蛇。</p>

<h3>2011-08-27</h3>

<p>在学校的 CC98 论坛上，征到工业设计的 mdd 童鞋，为我们设计 UI。三人团队组建完成。</p>

<h3>2011-09-08</h3>

<p>经过不断的改进、测试，攻克了一些第一次开发中遗留的问题（特别是游戏状态保存的问题），经过几个几近通宵夜晚共同讨论，我们的 Kongfu Snake 终于拥有了自己主题的  UI 和相对完整的功能。</p>

<p>第二天我将踏上去爱尔兰的旅程。但开发并未终止。还有部分需要改进和善后的工作。</p>

<h3>2011-09-23</h3>

<p>由于 25 日有保研的远程电话面试，我和 yzq 最近搁置了手头的开发。祝我们好运。完事后继续最后的攻坚。</p>

<h3>2011-10-26</h3>

<p>已经提交了两周了，结果应该已经出了吧。下周二就有结果了。</p>

<p>bless 啊。</p>

<p>不过我自己感觉希望不大了。</p>

<p>华东赛区前 6 才能进全国决赛。而我们浙大华东赛区是评审单位，我已经看到一个工业设计的同学，做的一个 3D 的游戏，可玩读很不错，虽然细节方面有些 bug。自认为要是评选，他们会排在前面，而 android 应用，学校应该还潜伏着很多高手吧，毕竟，这个入手比较简单。估算从中再产生一个前 6，我想浙江大学作为主评的单位，从避嫌的角度也不会推上去太多明额，两个合适，三个最多了。唉，真担心我们的作品>&lt;&#8230;</p>

<p>只能期待奇迹发生了。</p>

<p>评委老师们要给力啊！</p>

<h3>2011-10-31</h3>

<p>最后一天了，突然觉得好紧张啊。明天就公布区域塞的结果了。</p>

<p>如果。。如果。。。</p>

<p>求 RP 啊。。。。。</p>

<p>唉，虽然说眼光放长远，学习知识最重要，但是还是想获得一些奖励作为 mark 啊～～</p>

<p>看明天吧</p>

<h3>2011-11-1</h3>

<p>i&#8217;m so glad that we&#8217;ve got the second prize in eastern China competition!!</p>

<p>And let&#8217;s moving on to the national competition!!!</p>

<p>I&#8217;ll turn to some friends who has some experience in user interaction to give some advice  about our android game,
and then make a plan to do a better work.
I think we will make it open source and put the game into the market finally, but not now, we should make it better first!<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.me/blog/2013/09/05/google-android-challenge-2011/'>http://biaobiaoqi.me/blog/2013/09/05/google-android-challenge-2011/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[biaobiaoqi的博客日志]]></title>
    <link href="http://biaobiaoqi.me/blog/2013/09/01/blog-log/"/>
    <updated>2013-09-01T01:40:00+08:00</updated>
    <id>http://biaobiaoqi.me/blog/2013/09/01/blog-log</id>
    <content type="html"><![CDATA[<p>鉴于友言的客服不搭理的态度和时而无法正常显示以及管理界面的难以使用，决定将评论系统切换到 disqus 上。</p>

<p>最近一直在更改博客的定制。就像一个人一样，产品也是由生命的，她的脚印就是她价值的体现。于是我萌生了将她的改变全部记录下来的想法，只恨没有在四个月前刚建起博客时就意识到这一点。</p>

<p>这就是本文的初衷了。</p>

<p>&#8211; 2013/9/1</p>

<h2>历史</h2>

<ul>
<li><p>2013/4 octopress 博客在 github 上成功搭建</p></li>
<li><p>2013/5 拟定了『首页』、『技术』、『生活』、『关于』的顶栏 tag 结构，增加了友言评论功能，jiathis 分享功能，侧边栏的微博秀和豆瓣秀。</p></li>
<li><p>2013/7 侧边栏增加标签云，并增加了『标签云』顶栏 tag。取消侧边栏微博秀。</p></li>
<li><p>2013/8 更换博客主题为 whitelake。</p></li>
</ul>


<!--more-->


<ul>
<li><p>2013/9/1 取消友言评论功能，采用 disqus 评论系统。</p></li>
<li><p>2013/9/10 顶栏增加『推荐』，推荐我所收集的学习资源。</p></li>
<li><p>2013/9/12 将侧边栏的友情链接挪到『推荐』中。</p></li>
<li>2013/9/17 取消顶栏的『关于』选项卡；将侧边栏的『最近发表』替换为『关于』，简述自己的身份；替换侧边栏的『我的社区』内容为我的所有社区 ID 的链接。</li>
</ul>


<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.me/blog/2013/09/01/blog-log/'>http://biaobiaoqi.me/blog/2013/09/01/blog-log/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[octopress第三方插件：博文同步工具syncPost]]></title>
    <link href="http://biaobiaoqi.me/blog/2013/08/31/octopress-3rd-party-plugin-syncpost/"/>
    <updated>2013-08-31T19:30:00+08:00</updated>
    <id>http://biaobiaoqi.me/blog/2013/08/31/octopress-3rd-party-plugin-syncpost</id>
    <content type="html"><![CDATA[<p>为了增加外链等考虑，独立博客往往有将博文同步到其他博客社区的需求。自己人肉黏贴的方式笨拙、重复，对于程序猿而言，着实不可取。</p>

<p>我在 github 上找到了 <a href="https://github.com/huangbowen521/octopress-syncPost">syncPost</a> 这个针对 octopress 的第三方工具，能够通过一些论坛提供的 <a href="http://en.wikipedia.org/wiki/MetaWeblog">metaWeblog</a> 服务实现 octopress 最新一篇博文的同步提交。</p>

<p>这大概就是我要找的东西吧。不过，其中有些细节并不是我想要的：</p>

<ul>
<li>1.在本地配置文件存储论坛账户的密码。虽然可以设置为 ignore 不提交到 git 代码库中，但这也并不安全。</li>
<li>2.只能同步最新的一篇博客，没有整体的博文搬家功能。</li>
<li>3.先比其他的 octopress 插件，原来版本的代码结构难于维护，比如有自己单独的配置文件，而不是使用全局的<code>_config.yml</code>(在那个版本中大概是为了不把明文密码提交到版本库中)，比如 ruby 文件单独在一个<code>_custom</code>文件夹下等</li>
</ul>


<p>基于这些点，我 fork 了 <a href="http://huangbowen.net/">huangbowen</a> 大哥的代码，定制成了它<a href="https://github.com/biaobiaoqi/octopress-syncPost">现在的样子</a>。</p>

<!--more-->


<h2>功能</h2>

<p>通过 rake 的方式实现同步功能：</p>

<ul>
<li>1.同步所有 octopress 的博文到目标博客。 (<code>rake sync_all_posts</code>)</li>
<li>2.同步最新一篇博文到目标博客。(<code>rake sync_lates_post</code>)</li>
</ul>


<h2>开发</h2>

<p>这个 octopress 插件的结构很简单：</p>

<ul>
<li>安装<code>nokogiri</code>和 <code>metaweblog</code>两个 gem。前者实现对 octopress 生成的 html 页面的解析，找到对应的博文。提供了客户端发起 MetaWeblog 请求的功能。</li>
<li>在全局配置文件<code>_config.yml</code>中配置了目标博客 MetaWeblog 的服务地址、用户的账号信息。</li>
<li>octopress/plugins/sync_*.rb 三个文件则是代码实现。其中 sync_post.rb 中包含了 post 类，是主要的逻辑代码所在，sync_all_posts.rb 和 sync_latest_post.rb 则是对前者的调用。</li>
<li>修改了 octopress 的 Rakefile，通过 rake 的方式实现功能。</li>
</ul>


<h2>下一步</h2>

<p>希望能进一步完善这个插件，现在考虑到的有：</p>

<ul>
<li>增加同步所有博文功能中，对目标博客中已有博文的查重功能。即对于已经同步过去的博客，不再发送请求，或者实现编辑功能的同步功能。由于站点的 MetaWeblog 服务大多对请求有时限控制，同步过程中可能出现中断，此时部分博文已经同步过去，而部分没有，这种情况下，暂时没有好的解决方式。</li>
<li>测试其他有 MetaWeblog 服务的博客站点（现在仅测试了 cnblog）。</li>
<li><del>cnblog 的博文显示中，似乎不支持 octopress 的代码块样式。</del> (注：原作者 huangbowen 大哥已经解释了是 css 样式的问题)</li>
</ul>


<p>欢迎感兴趣的朋友参与到这个 repo 中来:)</p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.me/blog/2013/08/31/octopress-3rd-party-plugin-syncpost/'>http://biaobiaoqi.me/blog/2013/08/31/octopress-3rd-party-plugin-syncpost/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PAT 1061 - 1064 题解]]></title>
    <link href="http://biaobiaoqi.me/blog/2013/08/31/pat-1061-pat-1064/"/>
    <updated>2013-08-31T13:32:00+08:00</updated>
    <id>http://biaobiaoqi.me/blog/2013/08/31/pat-1061-pat-1064</id>
    <content type="html"><![CDATA[<p>这四道题来自 13 年 08 月 30 的 PAT 测试。</p>

<p>代码量不大，思路也比较直接。不过第一题的处理逻辑不太清晰，需要好好把握。稍有不慎就掉进坑里了（很多人被这道 20‘的题坑了一个多小时心慌意乱我会乱说-，-？）。</p>

<p>PAT advanced level 全部源码：<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/tree/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel">请戳</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1061">1061. Dating (20)</a></h2>

<h5>题意</h5>

<p>题意比较模糊，需要仔细对照 Sample 的数据理清思路。给定四个字符串，每个不超过 60 个字符，不含空格。要求从中找到符合如下规定的三个字符（或者它们的位置），并转化成一个时间的表达：</p>

<ul>
<li>1.依次比较前两个字符串中每个位置的元素，找到第一个相等的字符，且该字符属于[&#8216;A&#8217;, &#8216;G&#8217;]的字母，注意大小写敏感。转换成一周七天输出。</li>
<li>2.在 1 中的字符出现之后，继续比较前两个串，找到一个相等的字符，使它属于[&#8216;0&#8217;, &#8216;9&#8217;] || [&#8216;A&#8217;, &#8216;N&#8217;]，同样，大小写敏感。转换成一天 24 小时的小时数输出。</li>
<li>3.比较后两个字符串，找到第一个相等的字母（isalpha()），将它在数组中的位置值转换分钟数输出。</li>
</ul>


<p>为了便于理解，给出 Sample 数据:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Sample Input:
</span><span class='line'>
</span><span class='line'>3485djDkxh4hhGE 
</span><span class='line'>2984akDfkkkkggEdsb 
</span><span class='line'>s&hgsfdk 
</span><span class='line'>d&Hyscvnm
</span><span class='line'>
</span><span class='line'>Sample Output:
</span><span class='line'>
</span><span class='line'>THU 14:04
</span></code></pre></td></tr></table></div></figure>


<h5>分析</h5>

<p>理清题目的逻辑以后，实现起来是很简单的。</p>

<p>pat1061 源码:<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel/APAT1061.cpp">请戳</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1062">1062. Talent and Virtue (25)</a></h2>

<h5>题意</h5>

<p>给定一堆人，每个人有三条记录：id，道德值(v)，才能值(t)。给出两个值 L 和 H，用作对这堆人的分类。按照如下规则输出排序结果：</p>

<!--more-->


<ul>
<li>0.过滤掉 v 和 t 都小于 L 的人</li>
<li>1.v 和 t 都不小于 H 的人是圣人，属于最高的层级，排序在其他层级之前。</li>
<li>2.v 不小于 H，而 t 小于 H 的人是君子，这个层级排在圣人之后。</li>
<li>3.剩下的人中，v 不小于 t 的人是愚人，层级关系里排第三，排在所有圣人和君子之后。</li>
<li>4.最后剩下的人是小人，是最低的层级。</li>
<li>5.排名时，相同层级的人的排序关系是 1.按照 v+t 的总分 non-increasing 排序；2.按照 v 的分值按 non-increasing 排序；3.找到 id 按 increasing 排序。</li>
</ul>


<h5>分析</h5>

<p>题意梳理清楚以后，定制比较函数用 qsort()能很快的实现。</p>

<p>经测试，使用<code>cout</code>，<code>cin</code>会超时，改用&#8217;printf() scanf()&#8217;轻松过。</p>

<p>pat1062 源码:<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel/APAT1062.cpp">请戳</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1063">1063. Set Similarity (25)</a></h2>

<h5>题意</h5>

<p>题目给出了 N(&lt;=50)个正整数集合（实际上不是真正意义上的 set，有重复数值），每个集合最多存 M(&lt;10<sup>4)个元素，其中数值范围是</sup> [0, 10<sup>9]。给出</sup> K 次查询，每次查询条件为两个集合，要求求出两集合的相似度。</p>

<p>这里集合相似度的定义是 Nc/Nt*100%，其中 Nc 为两集合的交集元素数量，Nt 为两集合的并集的元素数量。</p>

<h5>分析</h5>

<p>思路一：</p>

<p>利用<code>sort()</code>对数组做排序，然后遍历去重。计算交集时，直接用两个游标对数组遍历进行比较操作，并集等于两者的大小之和减去交集的大小。复杂度为 O(M<em>K + N</em>M*logM)。这种游标遍历的思想，还是很 common sense 的处理方式，精妙之处在于循环判断和内部的判断逻辑的分离，让代码清晰明了。</p>

<p>思路二：</p>

<p>有不愿意透露姓名的<a href="http://weibo.com/cloudbye">@草原</a>同学提出，使用 set 做去重是没问题的。</p>

<p>pat1063 源码:<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel/APAT1063.cpp">请戳</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1064">1064. Complete Binary Search Tree (30)</a></h2>

<h5>题意</h5>

<p>给定一串数据，要求构建完全二叉搜索树。</p>

<h5>分析</h5>

<p>常规思路：</p>

<ul>
<li>对数据排序</li>
<li>递归的构建二叉搜索树，递归条件为根据有序数组找到子树顶点，顶点位置需要满足完全二叉树的结构。</li>
<li>最后用 queue 输出层序遍历。</li>
</ul>


<p>实现起来需要注意各种边界条件的判定，坑比较多，且代码量比较大（我的参考代码里写了 70 行）。后来<a href="http://weibo.com/redow7">@Redow7</a> 给介绍了一种更有趣的方法：</p>

<ul>
<li>0.对数据排序，等待操作。</li>
<li>1.首先构建好完全二叉树。</li>
<li>2.利用二叉搜索树的中序遍历的有序性，在中序遍历的过程中，将排序好的数据插入其中。</li>
</ul>


<p>如此一来，难点就转移到了构建完全二叉树上。</p>

<p>联想到最大堆的数组实现：父节点坐标为 n 时，左儿子为 2<em>n，右儿子为 2</em>n+1。对的，数组实现的二叉树就是满足完全二叉树的特点的。构建完全二叉树的步骤直接缩减为定义一个一定长度的数组。</p>

<p>于是，使用数组实现的二叉树做迭代的思路就出来了，30 行搞定。</p>

<p>pat1064 源码:<a href="https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel/APAT1064.cpp">请戳</a><p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.me/blog/2013/08/31/pat-1061-pat-1064/'>http://biaobiaoqi.me/blog/2013/08/31/pat-1061-pat-1064/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分布式事务slides]]></title>
    <link href="http://biaobiaoqi.me/blog/2013/08/26/distributed-transaction/"/>
    <updated>2013-08-26T23:49:00+08:00</updated>
    <id>http://biaobiaoqi.me/blog/2013/08/26/distributed-transaction</id>
    <content type="html"><![CDATA[<p>最近看了<a href="http://book.douban.com/subject/21624776/">《分布式系统概念与设计 第 5 版》</a>的分布式事务章节，整理了一份 ppt。还有恢复部分没有收录进来，有空再整理啦。</p>

<p>下面是传到 deckspeaker 上的 slides 展示:</p>

<script async class="speakerdeck-embed" data-id="aa521420f0a101303be246475d95d052" data-ratio="1.33333333333333" src="http://biaobiaoqi.me//speakerdeck.com/assets/embed.js"></script>


<p>下载链接：<a href="https://dl.dropboxusercontent.com/u/64021093/slides/distributed%20transcation.pptx">请戳</a><p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.me/blog/2013/08/26/distributed-transaction/'>http://biaobiaoqi.me/blog/2013/08/26/distributed-transaction/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PAT练习题概览]]></title>
    <link href="http://biaobiaoqi.me/blog/2013/08/03/overcome-pat/"/>
    <updated>2013-08-03T22:20:00+08:00</updated>
    <id>http://biaobiaoqi.me/blog/2013/08/03/overcome-pat</id>
    <content type="html"><![CDATA[<p>PAT(<a href="http://pat.zju.edu.cn">pat.zju.edu.cn</a>)是一个面向 C/C++程序的 Online Judge 系统。相比 ZOJ，HDOJ，POJ 等 ACM 题库，PAT 的题目非常基础，对于数据结构、算法的入门是比较有助益的。</p>

<p>本文按照自己的认识，给 PAT advanced level 做出了分类。由于很多题目实际上兼顾有多种解法和思路，我给每道题打上了 tag，来应对分类的独占性局限，供大家参考。</p>

<h2>简单题</h2>

<p>这类题几乎不需要数据结构、算法基础，主要通过简单的逻辑流程和判断实现。</p>

<ul>
<li>1001 A+B</li>
<li>1002 多项式相加</li>
<li>1005 简单 hash</li>
<li>1006 选极值</li>
<li>1008 模拟电梯</li>
<li>1009 多项式乘法</li>
<li>1011 选极值</li>
<li>1019 数字/字符处理</li>
<li>1024 数字/字符处理</li>
<li>1027 数字/字符处理，简单 hash</li>
<li>1031 数字/字符处理</li>
<li>1035 简单 hash<!--more --></li>
<li>1036 选极值</li>
<li>1037 简单模拟</li>
<li>1040 数字/字符处理</li>
<li>1046 数字/字符处理</li>
<li>1050 数字/字符处理</li>
<li>1058 数字/字符处理</li>
<li>1060 数字/字符处理</li>
<li>1061 数字/字符处理，坑题</li>
<li>1063 数字/字符处理，游标</li>
</ul>


<h2>模拟题</h2>

<p>这类题也相对简单，需要使用到一些简单的数据结构或者相对复杂的逻辑流程实现。</p>

<ul>
<li>1022 倒排索引</li>
<li>1023 数字/字符处理</li>
<li>1032 链表</li>
<li>1049 计算数字中的 1</li>
<li>1051 模拟栈</li>
<li>1052 链表</li>
<li>1054 dominant color</li>
<li>1056 模拟分组淘汰赛</li>
</ul>


<h4>排队模拟</h4>

<p>下面三道模拟题是针对排队模型处理的：</p>

<ul>
<li>1014 排队问题</li>
<li>1017 排队问题</li>
<li>1026 排队问题</li>
</ul>


<h4>排序模拟</h4>

<p>这几道模拟题侧重在使用排序方法：</p>

<ul>
<li>1012 排序</li>
<li>1016 排序，模拟电话账单计算</li>
<li>1025 排序</li>
<li>1028 排序</li>
<li>1029 归并排序</li>
<li>1038 递归，排序</li>
<li>1062 排序</li>
</ul>


<h4>时间优化</h4>

<p>这几道题需要做好时间优化才能 ac。</p>

<ul>
<li>1044 搜索，时间优化</li>
<li>1039 倒排索引，hash，时间优化</li>
<li>1047 倒排索引，hash，时间优化</li>
<li>1055 排序，时间优化</li>
</ul>


<h4>素数判定</h4>

<ul>
<li>1015 素数</li>
<li>1059 素数</li>
</ul>


<h2>图</h2>

<ul>
<li>1003 最短路径</li>
<li>1018 最短路径</li>
<li>1030 最短路径</li>
<li>1034 dfs</li>
</ul>


<h2>搜索</h2>

<ul>
<li>1010 二分搜索，优化剪枝</li>
<li>1013 并查集/dfs</li>
<li>1021 并查集，dfs，图的直径</li>
<li>1054 dfs，优化剪枝</li>
</ul>


<h2>树</h2>

<ul>
<li>1004 dfs，树遍历</li>
<li>1020 二叉树遍历</li>
<li>1043 二叉树遍历</li>
<li>1064 重建完全二叉搜索树</li>
</ul>


<h2>Hash</h2>

<ul>
<li>1041 hash</li>
<li>1042 hash</li>
<li>1048 hash</li>
</ul>


<h2>分治</h2>

<ul>
<li>1007 最大子连续序列</li>
</ul>


<h2>贪心</h2>

<ul>
<li>1033 贪心</li>
</ul>


<h2>动态规划</h2>

<ul>
<li>1045 DP，最长递增子序列</li>
</ul>


<h2>树状数组</h2>

<p>树状数组是一种神奇的数据结构，在 1057 题中其神奇的效果得到了很好的体现。</p>

<ul>
<li>1057 树状数组，模拟栈，二分搜索</li>
</ul>


<h2>题解</h2>

<p>截止 2013-08-03，PAT advanced level 的 60 道题全部题解和代码已经发布在本博客中，链接如下：欢迎讨论大家;)</p>

<ul>
<li><a href="http://biaobiaoqi.me/blog/2013/07/31/pat-1001-1010-solutions/">《PAT 1001-1010 题解》</a></li>
<li><a href="http://biaobiaoqi.me/blog/2013/07/31/pat-1011-1020-solutions/">《PAT 1011-1020 题解》</a></li>
<li><a href="http://biaobiaoqi.me/blog/2013/08/01/pat-1021-1030-solutions/">《PAT 1021-1030 题解》</a></li>
<li><a href="http://biaobiaoqi.me/blog/2013/08/01/pat-1031-1040-solutions/">《PAT 1031-1040 题解》</a></li>
<li><a href="http://biaobiaoqi.me/blog/2013/08/01/pat-1041-1050-solutions/">《PAT 1041-1050 题解》</a></li>
<li><a href="http://biaobiaoqi.me/blog/2013/08/01/pat-1051-1060-solutions/">《PAT 1051-1060 题解》</a></li>
<li><a href="http://biaobiaoqi.me/blog/2013/08/31/pat-1061-pat-1064/">《PAT 1061-1064 题解》</a></li>
</ul>


<p>附博客的 PAT 专题区链接：<a href="http://biaobiaoqi.me/tags/pat/">请戳</a><p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.me/blog/2013/08/03/overcome-pat/'>http://biaobiaoqi.me/blog/2013/08/03/overcome-pat/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p></p>
]]></content>
  </entry>
  
</feed>
