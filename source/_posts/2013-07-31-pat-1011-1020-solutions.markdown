---
layout: post
title: "PAT 1011-1020 题解"
date: 2013-07-31 23:41
comments: true
categories: [tech]
tags: [algorithm, pat]
description: "PAT 1011, PAT1011,PAT 1012, PAT1012,PAT 1013, PAT1013,PAT 1014, PAT1014,PAT 1015, PAT1015,PAT 1016, PAT1016,PAT 1017, PAT1017,PAT 1018, PAT1018,PAT 1019, PAT1019,PAT 1020, PAT1020, 题解， 解题报告"

---
早期部分代码用Java实现。由于PAT虽然支持各种语言，但只有C/C++标程来限定时间，许多题目用Java读入数据就已经超时，后来转投C/C++。浏览全部代码：[请戳](https://github.com/biaobiaoqi/biaobiaoqiCode/tree/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel)

本文谨代表个人思路，欢迎讨论;)

[PAT1011](http://pat.zju.edu.cn/contests/pat-a-practise/10111)
---

#####题意

给定一个3*3的矩阵，找到每行的最大值，格式化输出一个运算结果。

#####分析

非常简单的模拟题。

<!--more-->

[PAT1012](http://pat.zju.edu.cn/contests/pat-a-practise/10012)
---
#####题意
给定学生的学号和三个科目的分数，查询输出对应学生单门科目排名和总分排名中最高的那个排名。

#####分析
C里stdlib.h中的qsort()和C++里algorithm中的sort()函数都能实现快排，应对编程题中的排序一般比自己手写的要快。
分别为三个单科和总分做排序，并将rank值记录到map结构中去，便于之后的查找。

需要注意并列排名的情况。比如`1 2 2 4`，由于并列第2的都两人，那之后的那个人就是第4而不是第3了。

另外，由于有多个需要分别排序、排名的项，抽象出公共逻辑到一个函数里比较必要，否则代码分散难于debug和维护。
这里稍微特殊点的用法是使用了[函数指针](http://blog.csdn.net/dyx1024/article/details/7562786)做参数。


[PAT1013](http://pat.zju.edu.cn/contests/pat-a-practise/1013)
---

#####题意
给定一张图和指定几个点。针对给出的每个点，要求计算在图中除掉连接该点的路径的情况下，保证整个图连通需要添加几条边。


#####分析
计算保证整个图连通需要几个点，亦即求出图中有几个连通分量。两种思路：

* 1.并查集
* 2.DFS

针对每个点，执行算法的过程中，需要注意去除掉改点对应的所有通路。


[PAT1014](http://pat.zju.edu.cn/contests/pat-a-practise/1014)
---

#####题意

这道题是排队模拟题。银行有N个窗口，每个窗口允许排队M个人，如果N个窗口占满了排队的人，更多的人需要在黄线外等待。
每个人都会选择尽可能人少的窗口排队，如果有多个窗口等待队列一样长，则选择编号小的窗口。
前N个用户设定在8:00开始接受服务。给定了K个用户所需要接受服务的时间长度，要求在这个排队模型下，每个人的完成处理的时间点。

#####分析

相对另外几个队列模拟题，这个题是很简单的。没有达到时间的差异，只需要不断的从等待队列中取出人员即可。
当然，由于黄线内等待的每个窗口都有M人，所以必须单独的模拟每个窗口。
可以使用queue模拟每个窗口，循环遍历下次离开窗口的人，继而从等待队列中补上。
需要注意结束条件，如果17:00以后还没有开始接受服务，则不用再等待。

[PAT1015](http://pat.zju.edu.cn/contests/pat-a-practise/1015)
---

#####题意

Reversible Primes是指在某个进制下，一个数本身和它翻转过来形成的新数都是素数。
题中给出多组数据，以负数结尾程序。每组数据包含一个数以及一个进制数。判定该数是否是Reversible Primes.

#####分析

两个功能点实现：判定素数和特定进制下的数据倒转。


[PAT1016](http://pat.zju.edu.cn/contests/pat-a-practise/1016)
---

#####题意
给出一天中每个不同的小时内的电话付费标准，给出一份分为打出和挂断两种记录的通话记录，包括记录发生的时刻和用户名字，
要求整理出当月有效用户的账单，输出格式中需要输出所有的通话记录，包括开始时刻和结束时刻，每次通话的话费以及总计的话费。

#####分析

模拟题。首先对输入的通话记录按照先姓名后时间做qsort()排序，然后遍历排序后的记录，找到合适的匹配对，计算每次通话的时间，并进行统计和输出。

实现的难点主要有两个：

* 1.在排序后的记录中，找到合适的配对。如果某人的通话记录为`1.on;2.on;3.off;`，则其中`1.on`将被抛弃，匹配到`2.on;3.off;`。
题中仅仅保证了所有记录中至少有一对有效记录，但并没有保证每个人都有有效通话记录，所以还需要做好过滤，
如果某人没有有效通话记录，则不输出。整体的控制流程需要谨慎。
* 2.由于不同时刻的话费不一样，计算一次有效通话的话费比较复杂。可以采用的方式是用起始时刻分阶段追赶结束时刻。追赶的过程分阶段，也就能计算好不同阶段的开销，
先将起始时间调整到跟结束时间为同一天，细节是先让分钟达到0，再让小时迭代到0，天进位，一直迭代到跟结束时间同天；再让起始时刻的小时数追平
结束时刻；最后让分钟追平。以此计算出最终话费。


[PAT1017](http://pat.zju.edu.cn/contests/pat-a-practise/1017)
---

#####题意
银行有K个窗口，所有到达银行的人都应该在黄线外等待，直到有窗口空余。
每个窗口对单个客人最多服务时间为1小时。N个用户的到达时间和需要处理的时间给出。
8:00到17:00接受服务，逾期不服务，也不计入统计数据。要求格式化输出用户的平均等待时间。

#####分析
又一道排队模拟题。相比PAT1014，此题更复杂在于用户的到达时间是不确定的。
首先使用qsort()按照到达时间对所有人排序。由于每个窗口同时只有一个人在处理，所以窗口之间没有差异，可以用priority_queue建立一个队列，
模拟所有K个窗口。
优先队列将结束时间最早的人放到队列的顶端，每次循环处理一个人的结束。然后步入一个黄线外等待的人。如果那个时刻，下一个人还没有达到，则可以将该人开始执行的时间记录为他的到达时间，并加入队列中。
还有一点需要注意的：HH:MM:SS的时间格式，可以转换为累积秒数的时间，方便计算比较。


[PAT10108](http://pat.zju.edu.cn/contests/pat-a-practise/1018)
---

#####题意
以杭州的公用自行车站点管理为背景。每个站点是一个节点，每个节点上最多停放Cmax辆自行车，Cmax/2为节点的最佳状态。不同节点间距离不同，整个构成了一张带权无向图。要求从起始点（公用自行车管理中心）出发，去目的地维护目的地节点的车辆状态，如果车辆低于Cmax/2，则给它添加车辆到Cmax/2辆，如果多于Cmax/2，则去除掉几辆车。同时，在去往目的地的过程中，也需要调整所有沿途站点的车辆（这里题目没有交代清楚，实际测试是只能在去往目的地的途中调整，回来的途上不可调整）。求到给定目的地的最短路径，如果有多条最短路径，则按照1.从管理中心送出的车辆越少越好；2.拿回到管理中心的车越少越好的优先级找到结果。

#####分析
题目的大体框架是有权最短路径问题。步骤如下：

* 1.使用Dijkstra找到最短路径，其中注意记录每个节点在最短路径中的【所有】前驱节点；
* 2.使用DFS的方法，得到所有的最短路径。
* 3.计算每条最短路径的带出和带回的车辆数量。

其中DFS时，归纳所有答案的过程比较通用，需要掌握。

另外值得注意的是，类比到PAT1003，该题采用了直接对每个节点增加状态记录的方式，直接得到最优解，而不是先找到最短路径，然后计算比较。本题是无法用这种方法实现的，需要送出和带回的自行车数量无法直接在Dij算法中每个节点的计算中体现，并不是前面的节点带回和送出的车辆越少，后面的节点就一定能得到更优解。

[PAT1019](http://pat.zju.edu.cn/contests/pat-a-practise/1019)
---

#####题意
给定一个十进制数和一个进制，要求计算出在给定进制下的表达并判定是否为回文。

#####分析
简单的数字处理。

[PAT1020](http://pat.zju.edu.cn/contests/pat-a-practise/1020)
---

#####题意
根据二叉树的后序遍历和中序遍历，求层序遍历。

#####分析
具体实现方式：

* 初始：用后序遍历序列确定根节点，在中序遍历序列中找到该根节点，则左右子树分别为中序中该节点左右的序列。
* 迭代：对各个子树分别执行三步操作，1.在后序序列中找子树的根节点；2。在中序序列中找子树的根节点，并划分开根节点的左右子树；3.根据新生成的左右子树，在后序序列中划分开这些节点，从而得到了两颗子树的后序、中序序列。

有一个结论：中序遍历配合另外任何一个遍历，能重建二叉树。其他的任意两个序列的组合都不能唯一的确定重建的二叉树。具体分析参见博文[《根据前中后序和层序重建二叉树(PAT1020、PAT1043)》](../../../../2013/04/27/pat1020-pat1043-rebuild-binary-tree/)。
