---
layout: post
title: "PAT 1065 - 1068 题解"
date: 2013-10-08 13:46
comments: true
categories: [tech]
tags: [pat, algorithm]
description: "浙大2013保研上机考试，PAT1065， PAT1066， PAT1067， PAT1086，PAT 1065， PAT 1066， PAT 1067， PAT 1086，比普通的PAT要难了0.5个点"

---

这次的题目来源是2013年10月7日下午的浙大计算机研究生招生机试题。

这次题目的难度，按姥姥的说法是：『比普通的PAT要难了0.5个点。我是把自己的题目从1.0到5.0以0.5的间距分难度级别的，PAT(A)难度一般在1.5-4.5之间，保研考试一般在2.0-5.0之间。PAT(B)大概是1.0-2.5的难度。』。

个人认为，其中1066模拟AVL插入的实现有些细节容易弄错，而1068只要会简单的DP，也就没有问题了，1065和1066都还是很简单的实现。

下面是各个题的分析（PAT advanced level本人实现的全部源码：[请戳](https://github.com/biaobiaoqi/CPractice/tree/master/PAT/advancedlevel)）。


[1065. A+B and C (64bit) (20)](http://pat.zju.edu.cn/contests/pat-a-practise/1065)
---

#####题意
输入三个数a，b，c，取值范围是 [`-2^63`, `2^63`]，要求判断` a + b < c ` 是否为真。


#####分析

很简单的签到题，想到两种方法：一是用Java的Big Decimal实现（应该不会超时吧-,-），二是对a+b造成的long long溢出的情况做特殊处理。

对于分情况的实现方式，实际上也就两种特殊情况，即a，b同号且两者之和溢出了（绝对值超过了2^63）。此时两者之和与c的值的相对关系也是确定的。

* `a < 0 && b < 0 && a + b >= 0`: a + b 必小于c
* `a > 0 && b > 0 && a + b <= 0`: a + b 必大于c

另在98看见有大神说可以用long double水过去-,-.

pat1065源码:[请戳](https://github.com/biaobiaoqi/CPractice/blob/master/PAT/advancedlevel/APAT1065.cpp)


[1066. Root of AVL Tree (25)](http://pat.zju.edu.cn/contests/pat-a-practise/1066)
---

#####题意

实现[AVL树](http://en.wikipedia.org/wiki/AVL_tree)的插入方法，给定N(<=20)个数，要求输出依次插入后的AVL树的根。

#####分析

由于节点少，可以使用相对简单的递归实现方法：

* 每个节点维护一个高度值，用在递归插入后检测子树是否平衡
* 完成4个旋转方法（参见[AVL Tree wikipedia](http://en.wikipedia.org/wiki/AVL_tree)中的示意图）
* 在递归插入方法中，完成对子树的插入后，检测子树高度差，根据子树的结构特点，做出相应的旋转
* 旋转后记得更新节点的高度值

机试时似乎没有人完全AC这道题，看来代码实现和Debug能力缺乏还是比较普遍的问题。

pat1066源码:[请戳](https://github.com/biaobiaoqi/CPractice/blob/master/PAT/advancedlevel/APAT1066.cpp)

<!--more-->
[1067. Sort with Swap(0,*) (25)](http://pat.zju.edu.cn/contests/pat-a-practise/1067)
---

#####题意
给定N(<=`10^5`)以及一个{0,1,…,N-1}的打乱的数列。

定义了一种交换方式：`Swap(0,*)`，表示将0和任意数进行位置交换。

限定只能使用`Swap(0,*)`，要求输出最少需要多少次交换操作，来完成整体的排序。


#####分析

很好玩的模拟题，从题目的两个测试数据入手，找到所需要的交换次数的特点：

假设用数组a存储输入的数组，数组的坐标为[0, N - 1]，而元素的所有值也是[0, N - 1]。

1. 输入的序列中本就在自己位置上的数字，是不用被交换的（比如序列`{4, 0, 2, 1, 3}`中2就是不用被交换），0除外

2. 0最终肯定会被放回到0的位置上，但交换过程中，0也可能被提前交换到了0的位置上，此时还有其他数没有处于正确的位置上（参见Sample Input`{10 3 5 7 2 6 4 9 0 8 1}`的情况）。此时需要多费一步将0和某一个处于不正确位置的数交换位置，来继续排序。

3. 每次的交换，0其实只是一个过渡作用。实际的交换过程遵循的链式关系如下所述：设定a[x] == b， 而 b != x，则需要将a[x]的值移动到a[b]上，此时a[b] == c, 那么接着又需要将 a[b]的值移动到a[c]上，以此类推，肯定能获得一个循环，且节点数 M 小于等于 N。如果循环中包含了0，那么这个循环中的数排序所需要的交换次数为 M - 1, 如果循环中不包含0，那么首先需要一次交换将0移动到循环链中，此时整个循环链节点数增加了1，于是共需要开销 M + 1 次交换。

4. 根据3的分析，在2的情况下，0与不同的不在正确位置的数的交换，是不会影响最终的结果的。

综上所述，用类似dfs或者并查集的思路找到集合中的所有循环链路，记录下他们的大小，即可计算出所需要的交换次数。

pat1067源码:[请戳](https://github.com/biaobiaoqi/CPractice/blob/master/PAT/advancedlevel/APAT1067.cpp)


[1068. Find More Coins (30)](http://pat.zju.edu.cn/contests/pat-a-practise/1068)
---

#####题意
给定 N(<=`10^4`) 枚硬币和一个价格 M(<=100)。

要求用这 N 枚硬币组合出价格 M，如果有多种组合，输出排序后硬币面值字典序最小的组合，如果没有组合，则输出 No Solution.

#####分析

裸背包问题，相关资料参见dd大神的总结：[《背包问题九讲》](http://cuitianyi.com/blog/%E3%80%8A%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E4%B9%9D%E8%AE%B2%E3%80%8B2-0-alpha1/)

按照常规的背包思路，构建10001 * 101 的二维数组f[i][j]，状态f[i][j]表示前i枚硬币能拼凑出的小于等于j的最大值（j这里代表一个价格）。

状态转移方程为：`f[i][j] = max(f[i - 1][j], f[i - 1][j - c[i]] + c[i])`， 其中c[i]为第i枚硬币的面值，c[i]为排序过的硬币面值数组。

由于最终的输出要求是排序的币值的字典序最小的组合，可以对c[i]做从大到小的排序，并另开一个数组has[i][j]来记录当前状态下，是否有包含c[i]。同时注意，当`f[i - 1][j] == f[i - 1][j - c[i]] + c[i]`时，采纳当前的c[i]，以满足字典序。

pat1068源码:[请戳](https://github.com/biaobiaoqi/CPractice/blob/master/PAT/advancedlevel/APAT1068.cpp)