---
layout: post
title: "PAT 1061 - 1064 题解"
date: 2013-08-31 13:32
comments: true
categories: [tech]
tags: [pat, algorithm]
description: "pat1061题解, pat1062题解, pat1063题解, pat1064题解，pat 1061题解, pat 1062题解, pat 1063题解, pat 1064题解"

---

这四道题来自13年08月30的PAT测试。

代码量不大，思路也比较直接。不过第一题的处理逻辑不太清晰，需要好好把握。稍有不慎就掉进坑里了（很多人被这道20‘的题坑了一个多小时心慌意乱我会乱说-，-？）。

PAT advanced level 全部源码：[请戳](https://github.com/biaobiaoqi/biaobiaoqiCode/tree/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel)

[1061. Dating (20)](http://pat.zju.edu.cn/contests/pat-a-practise/1061)
---

#####题意

题意比较模糊，需要仔细对照Sample的数据理清思路。给定四个字符串，每个不超过60个字符，不含空格。要求从中找到符合如下规定的三个字符（或者它们的位置），并转化成一个时间的表达：

* 1.依次比较前两个字符串中每个位置的元素，找到第一个相等的字符，且该字符属于['A', 'G']的字母，注意大小写敏感。转换成一周七天输出。
* 2.在1中的字符出现之后，继续比较前两个串，找到一个相等的字符，使它属于['0', '9'] || ['A', 'N']，同样，大小写敏感。转换成一天24小时的小时数输出。
* 3.比较后两个字符串，找到第一个相等的字母（isalpha()），将它在数组中的位置值转换分钟数输出。

为了便于理解，给出Sample数据:

```
Sample Input:

3485djDkxh4hhGE 
2984akDfkkkkggEdsb 
s&hgsfdk 
d&Hyscvnm

Sample Output:

THU 14:04

```

#####分析

理清题目的逻辑以后，实现起来是很简单的。

pat1061源码:[请戳](https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel/APAT1061.cpp)


[1062. Talent and Virtue (25)](http://pat.zju.edu.cn/contests/pat-a-practise/1062)
---

#####题意

给定一堆人，每个人有三条记录：id，道德值(v)，才能值(t)。给出两个值L和H，用作对这堆人的分类。按照如下规则输出排序结果：

<!--more-->
* 0.过滤掉v和t都小于L的人
* 1.v和t都不小于H的人是圣人，属于最高的层级，排序在其他层级之前。
* 2.v不小于H，而t小于H的人是君子，这个层级排在圣人之后。
* 3.剩下的人中，v不小于t的人是愚人，层级关系里排第三，排在所有圣人和君子之后。
* 4.最后剩下的人是小人，是最低的层级。
* 5.排名时，相同层级的人的排序关系是 1.按照v+t的总分non-increasing排序；2.按照v的分值按non-increasing排序；3.找到id按increasing排序。

#####分析

题意梳理清楚以后，定制比较函数用qsort()能很快的实现。

经测试，使用`cout`，`cin`会超时，改用'printf() scanf()'轻松过。

pat1062源码:[请戳](https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel/APAT1062.cpp)

[1063. Set Similarity (25)](http://pat.zju.edu.cn/contests/pat-a-practise/1063)
---

#####题意


题目给出了N(<=50)个正整数集合（实际上不是真正意义上的set，有重复数值），每个集合最多存M(<10^4)个元素，其中数值范围是[0, 10^9]。给出K次查询，每次查询条件为两个集合，要求求出两集合的相似度。

这里集合相似度的定义是 Nc/Nt*100%，其中Nc为两集合的交集元素数量，Nt为两集合的并集的元素数量。

#####分析

思路一： 

利用`sort()`对数组做排序，然后自行遍历去重是一个不错的方式。计算交集、并集的时候，直接用两个游标对数组遍历进行比较操作，复杂度为O(M*K)。这种游标遍历的思想，还是很common sense的处理流程。

思路二：

有不愿意透露姓名的[@草原](http://weibo.com/cloudbye)同学提出，使用set做去重是没问题的。

pat1063源码:[请戳](https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel/APAT1063.cpp)

[1064. Complete Binary Search Tree (30)](http://pat.zju.edu.cn/contests/pat-a-practise/1064)
---

#####题意
给定一串数据，要求构建完全二叉搜索树。

#####分析

常规思路是对数据排序，然后递归的构建二叉搜索树（且构建的递归过程要满足完全二叉的树形结构），实现起来稍微有些代码量。

后来[@Redow7](http://weibo.com/redow7)给介绍了一种更有趣的方法：

* 0.对数据排序，等待操作。
* 1.首先构建好完全二叉树。
* 2.利用二叉搜索树的中序遍历的有序性，在中序遍历的过程中，将排序好的数据插入其中。

如此一来，难点就转移到了构建完全二叉树上。

联想到最大堆的数组实现：父节点坐标为n时，左儿子为2*n，右儿子为2*n+1。对的，数组实现的二叉树就是满足完全二叉树的特点的。构建完全二叉树的步骤直接缩减为定义一个一定长度的数组。

于是，使用数组实现的二叉树做迭代的思路就出来了，30行代码搞定。

pat1064源码:[请戳](https://github.com/biaobiaoqi/biaobiaoqiCode/blob/master/src/biaobiaoqi/algorithm/oj/pat/advancedlevel/APAT1064.cpp)