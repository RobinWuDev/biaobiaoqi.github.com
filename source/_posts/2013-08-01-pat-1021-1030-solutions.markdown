---
layout: post
title: "PAT 1021-1030 题解"
date: 2013-08-01 01:43
comments: true
categories: [tech]
tags: [algorithm, pat]
description: "PAT 1021, PAT1021,PAT 1022, PAT1022,PAT 1023, PAT1023,PAT 1024, PAT1024,PAT 1025, PAT1025,PAT 1026, PAT1026,PAT 1027, PAT1027,PAT 1028, PAT1028,PAT 1029, PAT1029,PAT 1030, PAT1030, 题解， 解题报告"

---

早期部分代码用Java实现。由于PAT虽然支持各种语言，但只有C/C++标程来限定时间，许多题目用Java读入数据就已经超时，后来转投C/C++。浏览全部代码：[请戳](https://github.com/biaobiaoqi/CPractice/tree/master/PAT/advancedlevel)

本文谨代表个人思路，欢迎讨论;)


[1021. Deepest Root (25)](http://pat.zju.edu.cn/contests/pat-a-practise/1021)
---

#####题意
无环连通图也可以视为一棵树，选定图中任意一点作为根，如果这时候整个树的深度最大，则称其为deepest root。
给定一个图，按升序输出所有deepest root。如果给定的图有多个连通分量，则输出连通分量的数量。

#####分析

算法实现的步骤如下：

* 1.使用并查集判断图是否为连通的。
* 2.任意选取一点，做dfs搜索，选取其中一个最远距离的点A，再做一次dfs，找到的所有距离最远的点以及点A都是deepest root。


判定图是否连通使用union-find set即可。更关键的点在于找到deepest root。实际上，使用两次dfs就可以实现。
证明之前，先介绍两个概念，一个是直径，树的deepest root到最远叶子的路径我们暂称直径，而deepest root和最远叶子节点则成为端点。
注明关键在于以下两点：

* 从任意一个点dfs得到的最远点都是直径的端点。证明如下：

    任意选一点A，做dfs查找距离A最远的点，因为是dfs，所以肯定会经过某直径上的点B，从B出发最远的点是直径上的端点C。
    那么，这个端点C为何一定是A的最远居里点呢？可以反证证明，如果有一个点D，A->D不经过直径，且length(A->D) > length(A->C)，
    那么，从C所在直径上构造出经过D的比原直径更长的直径，得证。

* 所有的树的直径都交于一点（或者公用段路径上的几点）。
于是，从B点dfs出发的所有最长距离的点即为deepest root。证明如下：

    如果两条直径不相交，而树上任意两点肯定连通，则从两直径上，可以选取两点连通以组成更长的直径；如果三条直径相较于不同的两点，也可以根据相交截断的长度组合出更长的直径。





[1022. Digital Library (30)](http://pat.zju.edu.cn/contests/pat-a-practise/1022)
---

#####题意
给定N (<=10000) 本书的信息，包括7位ID，最多80字符的书名，最多80字符的作者名，
多个最多10字符的关键词，最多80字符的出版商和属于[1000, 3000]的出版时间。
另给出M (<=1000) 的查询请求，按照查询格式分为：

* 1: 书名
* 2: 作者
* 3: 关键词
* 4: 出版商
* 5: 年份

输出查询结果。如果有多个结果，按照书的ID的升序排列。

#####分析
简单模拟题。在使用Map结构来构建倒排索引的过程中，可以讨巧的避免根据不同查询类型使用两层map，
直接通过在key中增加查询标记来实现。另外C++的priority_queue支持对常规数据类型的最小堆实现：`priority_queue<string, vector<string>, greater<string>>`，方便了结果输出。

<!--more-->

[1023. Have Fun with Numbers (20)](http://pat.zju.edu.cn/contests/pat-a-practise/1023)
---
#####题意
给出一个20位的正整数，要求计算其乘以2的值，并判定结果的数值是否是原数字所有位数打乱的结果。结果输出Yes或No，以及乘以2以后的数字。

#####分析
判重使用Hash思想。过程如下：

* 1.原数字按字符串读入，并在一个int hash[10]的hash数组中标记每个数值出现的次数，比如如果出现了四次1，则hash[1]=4。
* 2.模拟实现乘以2的简单乘法过程，没计算出一位的值，在hash[]中对应位置上减一。
* 3.最后通过判定hash是否全为1和最后结果是否有进位来做判定。



[1024. Palindromic Number (25)](http://pat.zju.edu.cn/contests/pat-a-practise/1024)
---

#####题意
非回文数可以通过将它与它的倒转数相加，并不断迭代这一过程获得回文数的结果。比如67经过两次处理就得到了484：
`67 + 76 = 143, and 143 + 341 = 484.`

给定一个数和迭代的次数，判断能否在迭代次数内获得回文结果。

#####分析

简单模拟题，处理数字，做逻辑判断。

[1025. PAT Ranking (25)](http://pat.zju.edu.cn/contests/pat-a-practise/1025)
---

#####题意

以PAT考试为背景，给所有人做排名。给定的数据包括N(<=100)为赛区的数目，每个赛区的人数以及每个人的分数。
按照总排名、分区号、注册号的优先级排名。

#####分析
简单模拟题，使用qsort()排序，注意相同分数的人应该拥有相同的排名。



[1026. Table Tennis (30)](http://pat.zju.edu.cn/contests/pat-a-practise/1026)
---

#####题意

乒乓球俱乐部有K张乒乓球桌，其中有M张是VIP桌。有很多人到俱乐部打球，如果桌子都满了，多余的人只能排队等待。

有一个特殊的VIP制度：如果有空的VIP桌，那么等待队列中的第一对VIP会员可以使用这张卓，
如果等待队列中没有VIP会员，那么一般会员也可以使用VIP桌。当轮到VIP上的时候，没有VIP桌子，那么VIP用户也可以使用一般的桌子。

另外，每张桌服务一对会员的时间最大限制在两个小时。

给定了乒乓球桌的数量M(编号为1-M)，其中VIP卓的数量K，并指定是那几张桌子。给出来乒乓球俱乐部的N对会员的信息，每对会员有一个达到时间，
是否是VIP的标记以及打球的时间。要求计算出每对会员的等待时间，以及每张桌服务过的次数。

#####分析

排队模拟题。有两种思路：

* 1.主体循环处理人。将乒乓球桌和人都当做资源，乒乓球桌对应记录了available的时间，每次取出available最早的时间，从等待队列中选
则最早的会员使用乒乓球桌。其中vip处理逻辑为：如果available并列最早的桌子中有vip桌，则看等待队列中有没有vip会员，
如果有则直接处理他，否则按照正常逻辑处理。每次将某会员安置到一个乒乓球桌上，则可以输出该会员的等待时间的结果信息，并将该乒乓球桌的
服务人数增加一。
* 2.主体循环是时间。这样需要模拟同一时刻所有的乒乓球桌以及等待队列，相对比较复杂。



[1027. Colors in Mars (20)](http://pat.zju.edu.cn/contests/pat-a-practise/1027)
---
#####题意
给定三个十进制数，要求格式化输出其13进制表达。

#####分析
简单的数字处理和hash实现。

[1028. List Sorting (25)](http://pat.zju.edu.cn/contests/pat-a-practise/1028)
---

#####题意
模拟Excel中按列排序。N (<=100000) 为数据条数，每条数据由三列组成：ID，姓名，成绩。C可以等于1,2,3，分别对应到按三列中的哪一列排序。
输出排序结果。

#####分析
简单排序题。两种思路：

* 1.简单的直接使用qsort()实现。
* 2.自己手写排序算法，比如二叉搜索树实现。

[1029. Median (25)](http://pat.zju.edu.cn/contests/pat-a-practise/1029)
---
#####题意
给定两个已排序的整数序列，求出两组数的集合里中间大小的数。

#####分析
使用归并排序思路实现。


[1030. Travel Plan (30)](http://pat.zju.edu.cn/contests/pat-a-practise/1030)
---
#####题意
给定加权图，每条边有两种权值：一是路径长度，二是开销。要求求出给点两点间的最短路径，如果路径长度一样，则要求比较选择开销最小的路径。

#####分析
使用Dijkstra算法的变形，增加一个权重的判定，可以轻松解决。
